diff --git a/nimble/controller/include/controller/ble_ll_ctrl.h b/nimble/controller/include/controller/ble_ll_ctrl.h
index 89502a45..fad00462 100644
--- a/nimble/controller/include/controller/ble_ll_ctrl.h
+++ b/nimble/controller/include/controller/ble_ll_ctrl.h
@@ -29,90 +29,96 @@ extern "C" {
  * It is used to determine which LL control procedure is currently running
  * in a connection and which ones may be pending.
  */
-#define BLE_LL_CTRL_PROC_CONN_UPDATE    (0)
-#define BLE_LL_CTRL_PROC_CHAN_MAP_UPD   (1)
-#define BLE_LL_CTRL_PROC_ENCRYPT        (2)
-#define BLE_LL_CTRL_PROC_FEATURE_XCHG   (3)
-#define BLE_LL_CTRL_PROC_VERSION_XCHG   (4)
-#define BLE_LL_CTRL_PROC_TERMINATE      (5)
+#define BLE_LL_CTRL_PROC_CONN_UPDATE (0)
+#define BLE_LL_CTRL_PROC_CHAN_MAP_UPD (1)
+#define BLE_LL_CTRL_PROC_ENCRYPT (2)
+#define BLE_LL_CTRL_PROC_FEATURE_XCHG (3)
+#define BLE_LL_CTRL_PROC_VERSION_XCHG (4)
+#define BLE_LL_CTRL_PROC_TERMINATE (5)
 #define BLE_LL_CTRL_PROC_CONN_PARAM_REQ (6)
-#define BLE_LL_CTRL_PROC_LE_PING        (7)
-#define BLE_LL_CTRL_PROC_DATA_LEN_UPD   (8)
-#define BLE_LL_CTRL_PROC_PHY_UPDATE     (9)
-#define BLE_LL_CTRL_PROC_SCA_UPDATE     (10)
-#define BLE_LL_CTRL_PROC_CIS_CREATE     (11)
-#define BLE_LL_CTRL_PROC_SUBRATE_REQ    (12)
+#define BLE_LL_CTRL_PROC_LE_PING (7)
+#define BLE_LL_CTRL_PROC_DATA_LEN_UPD (8)
+#define BLE_LL_CTRL_PROC_PHY_UPDATE (9)
+#define BLE_LL_CTRL_PROC_SCA_UPDATE (10)
+#define BLE_LL_CTRL_PROC_CIS_CREATE (11)
+#define BLE_LL_CTRL_PROC_SUBRATE_REQ (12)
 #define BLE_LL_CTRL_PROC_SUBRATE_UPDATE (13)
-#define BLE_LL_CTRL_PROC_NUM            (14)
-#define BLE_LL_CTRL_PROC_IDLE           (255)
+#define BLE_LL_CTRL_PROC_NUM (14)
+#define BLE_LL_CTRL_PROC_IDLE (255)
 
 /* Checks if a particular control procedure is running */
-#define IS_PENDING_CTRL_PROC(sm, proc)  (sm->pending_ctrl_procs & (1 << proc))
+#define IS_PENDING_CTRL_PROC(sm, proc) (sm->pending_ctrl_procs & (1 << proc))
 #define CLR_PENDING_CTRL_PROC(sm, proc) (sm->pending_ctrl_procs &= ~(1 << proc))
 
 /* LL control procedure timeout */
-#define BLE_LL_CTRL_PROC_TIMEOUT_MS     (40000) /* ms */
+#define BLE_LL_CTRL_PROC_TIMEOUT_MS (40000) /* ms */
 
 /*
  * LL CTRL PDU format
  *  -> Opcode   (1 byte)
  *  -> Data     (0 - 26 bytes)
  */
-#define BLE_LL_CTRL_CONN_UPDATE_IND     (0x00)
-#define BLE_LL_CTRL_CHANNEL_MAP_REQ     (0x01)
-#define BLE_LL_CTRL_TERMINATE_IND       (0x02)
-#define BLE_LL_CTRL_ENC_REQ             (0x03)
-#define BLE_LL_CTRL_ENC_RSP             (0x04)
-#define BLE_LL_CTRL_START_ENC_REQ       (0x05)
-#define BLE_LL_CTRL_START_ENC_RSP       (0x06)
-#define BLE_LL_CTRL_UNKNOWN_RSP         (0x07)
-#define BLE_LL_CTRL_FEATURE_REQ         (0x08)
-#define BLE_LL_CTRL_FEATURE_RSP         (0x09)
-#define BLE_LL_CTRL_PAUSE_ENC_REQ       (0x0A)
-#define BLE_LL_CTRL_PAUSE_ENC_RSP       (0x0B)
-#define BLE_LL_CTRL_VERSION_IND         (0x0C)
-#define BLE_LL_CTRL_REJECT_IND          (0x0D)
-#define BLE_LL_CTRL_PERIPH_FEATURE_REQ   (0x0E)
-#define BLE_LL_CTRL_CONN_PARM_REQ       (0x0F)
-#define BLE_LL_CTRL_CONN_PARM_RSP       (0x10)
-#define BLE_LL_CTRL_REJECT_IND_EXT      (0x11)
-#define BLE_LL_CTRL_PING_REQ            (0x12)
-#define BLE_LL_CTRL_PING_RSP            (0x13)
-#define BLE_LL_CTRL_LENGTH_REQ          (0x14)
-#define BLE_LL_CTRL_LENGTH_RSP          (0x15)
-#define BLE_LL_CTRL_PHY_REQ             (0x16)
-#define BLE_LL_CTRL_PHY_RSP             (0x17)
-#define BLE_LL_CTRL_PHY_UPDATE_IND      (0x18)
-#define BLE_LL_CTRL_MIN_USED_CHAN_IND   (0x19)
-#define BLE_LL_CTRL_CTE_REQ             (0x1A)
-#define BLE_LL_CTRL_CTE_RSP             (0x1B)
-#define BLE_LL_CTRL_PERIODIC_SYNC_IND   (0x1C)
-#define BLE_LL_CTRL_CLOCK_ACCURACY_REQ  (0x1D)
-#define BLE_LL_CTRL_CLOCK_ACCURACY_RSP  (0x1E)
-#define BLE_LL_CTRL_CIS_REQ             (0x1F)
-#define BLE_LL_CTRL_CIS_RSP             (0x20)
-#define BLE_LL_CTRL_CIS_IND             (0x21)
-#define BLE_LL_CTRL_CIS_TERMINATE_IND   (0x22)
-#define BLE_LL_CTRL_POWER_CONTROL_REQ   (0x23)
-#define BLE_LL_CTRL_POWER_CONTROL_RSP   (0x24)
-#define BLE_LL_CTRL_POWER_CHANGE_IND    (0x25)
-#define BLE_LL_CTRL_SUBRATE_REQ         (0x26)
-#define BLE_LL_CTRL_SUBRATE_IND         (0x27)
-#define BLE_LL_CTRL_CHAN_REPORTING_IND  (0x28)
-#define BLE_LL_CTRL_CHAN_STATUS_IND     (0x29)
+#define BLE_LL_CTRL_CONN_UPDATE_IND (0x00)
+#define BLE_LL_CTRL_CHANNEL_MAP_REQ (0x01)
+#define BLE_LL_CTRL_TERMINATE_IND (0x02)
+#define BLE_LL_CTRL_ENC_REQ (0x03)
+#define BLE_LL_CTRL_ENC_RSP (0x04)
+#define BLE_LL_CTRL_START_ENC_REQ (0x05)
+#define BLE_LL_CTRL_START_ENC_RSP (0x06)
+#define BLE_LL_CTRL_UNKNOWN_RSP (0x07)
+#define BLE_LL_CTRL_FEATURE_REQ (0x08)
+#define BLE_LL_CTRL_FEATURE_RSP (0x09)
+#define BLE_LL_CTRL_PAUSE_ENC_REQ (0x0A)
+#define BLE_LL_CTRL_PAUSE_ENC_RSP (0x0B)
+#define BLE_LL_CTRL_VERSION_IND (0x0C)
+#define BLE_LL_CTRL_REJECT_IND (0x0D)
+#define BLE_LL_CTRL_PERIPH_FEATURE_REQ (0x0E)
+#define BLE_LL_CTRL_CONN_PARM_REQ (0x0F)
+#define BLE_LL_CTRL_CONN_PARM_RSP (0x10)
+#define BLE_LL_CTRL_REJECT_IND_EXT (0x11)
+#define BLE_LL_CTRL_PING_REQ (0x12)
+#define BLE_LL_CTRL_PING_RSP (0x13)
+#define BLE_LL_CTRL_LENGTH_REQ (0x14)
+#define BLE_LL_CTRL_LENGTH_RSP (0x15)
+#define BLE_LL_CTRL_PHY_REQ (0x16)
+#define BLE_LL_CTRL_PHY_RSP (0x17)
+#define BLE_LL_CTRL_PHY_UPDATE_IND (0x18)
+#define BLE_LL_CTRL_MIN_USED_CHAN_IND (0x19)
+#define BLE_LL_CTRL_CTE_REQ (0x1A)
+#define BLE_LL_CTRL_CTE_RSP (0x1B)
+#define BLE_LL_CTRL_PERIODIC_SYNC_IND (0x1C)
+#define BLE_LL_CTRL_CLOCK_ACCURACY_REQ (0x1D)
+#define BLE_LL_CTRL_CLOCK_ACCURACY_RSP (0x1E)
+#define BLE_LL_CTRL_CIS_REQ (0x1F)
+#define BLE_LL_CTRL_CIS_RSP (0x20)
+#define BLE_LL_CTRL_CIS_IND (0x21)
+#define BLE_LL_CTRL_CIS_TERMINATE_IND (0x22)
+#define BLE_LL_CTRL_POWER_CONTROL_REQ (0x23)
+#define BLE_LL_CTRL_POWER_CONTROL_RSP (0x24)
+#define BLE_LL_CTRL_POWER_CHANGE_IND (0x25)
+#define BLE_LL_CTRL_SUBRATE_REQ (0x26)
+#define BLE_LL_CTRL_SUBRATE_IND (0x27)
+#define BLE_LL_CTRL_CHAN_REPORTING_IND (0x28)
+#define BLE_LL_CTRL_CHAN_STATUS_IND (0x29)
+/* FAST ENCRYPTION PROCEDURE OPCODES */
+#define BLE_LL_CTRL_ENC_F_REQ (0x2A)
+#define BLE_LL_CTRL_ENC_F_RSP (0x2B)
+/* REKEY OPCODES */
+#define BLE_LL_CTRL_REKEY_REQ (0x2C)
+#define BLE_LL_CTRL_REKEY_RSP (0x2D)
 
 /* Maximum opcode value */
-#define BLE_LL_CTRL_OPCODES             (BLE_LL_CTRL_CHAN_STATUS_IND + 1)
+#define BLE_LL_CTRL_OPCODES (BLE_LL_CTRL_REKEY_RSP + 1)
 
 extern const uint8_t g_ble_ll_ctrl_pkt_lengths[BLE_LL_CTRL_OPCODES];
 
 /* Maximum LL control PDU size */
 #if MYNEWT_VAL(BLE_ISO)
-#define BLE_LL_CTRL_MAX_PDU_LEN         (42)
+#define BLE_LL_CTRL_MAX_PDU_LEN (42)
 #elif MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_PERIODIC_ADV_SYNC_TRANSFER)
-#define BLE_LL_CTRL_MAX_PDU_LEN         (35)
+#define BLE_LL_CTRL_MAX_PDU_LEN (35)
 #else
-#define BLE_LL_CTRL_MAX_PDU_LEN         (27)
+#define BLE_LL_CTRL_MAX_PDU_LEN (27)
 #endif
 
 /* LL control connection update request */
@@ -125,7 +131,7 @@ struct ble_ll_conn_upd_req
     uint16_t timeout;
     uint16_t instant;
 };
-#define BLE_LL_CTRL_CONN_UPD_REQ_LEN        (11)
+#define BLE_LL_CTRL_CONN_UPD_REQ_LEN (11)
 
 /* LL control channel map request */
 struct ble_ll_chan_map_req
@@ -133,13 +139,13 @@ struct ble_ll_chan_map_req
     uint8_t chmap[5];
     uint16_t instant;
 };
-#define BLE_LL_CTRL_CHAN_MAP_LEN            (7)
+#define BLE_LL_CTRL_CHAN_MAP_LEN (7)
 
 /*
  * LL control terminate ind
  *  -> error code (1 byte)
  */
-#define BLE_LL_CTRL_TERMINATE_IND_LEN      (1)
+#define BLE_LL_CTRL_TERMINATE_IND_LEN (1)
 
 /* LL control enc req */
 struct ble_ll_enc_req
@@ -150,7 +156,7 @@ struct ble_ll_enc_req
     uint32_t ivm;
 };
 
-#define BLE_LL_CTRL_ENC_REQ_LEN             (22)
+#define BLE_LL_CTRL_ENC_REQ_LEN (22)
 
 /* LL control enc rsp */
 struct ble_ll_enc_rsp
@@ -159,25 +165,33 @@ struct ble_ll_enc_rsp
     uint32_t ivs;
 };
 
-#define BLE_LL_CTRL_ENC_RSP_LEN             (12)
+#define BLE_LL_CTRL_ENC_RSP_LEN (12)
 
 /* LL control start/pause enc request and response */
-#define BLE_LL_CTRL_START_ENC_REQ_LEN       (0)
-#define BLE_LL_CTRL_START_ENC_RSP_LEN       (0)
-#define BLE_LL_CTRL_PAUSE_ENC_REQ_LEN       (0)
-#define BLE_LL_CTRL_PAUSE_ENC_RSP_LEN       (0)
+#define BLE_LL_CTRL_START_ENC_REQ_LEN (0)
+#define BLE_LL_CTRL_START_ENC_RSP_LEN (0)
+#define BLE_LL_CTRL_PAUSE_ENC_REQ_LEN (0)
+#define BLE_LL_CTRL_PAUSE_ENC_RSP_LEN (0)
 
 /*
  * LL control unknown response
  *  -> 1 byte which contains the unknown or un-supported opcode.
  */
-#define BLE_LL_CTRL_UNK_RSP_LEN             (1)
+#define BLE_LL_CTRL_UNK_RSP_LEN (1)
 
 /*
  * LL control feature req and LL control feature rsp
  *  -> 8 bytes of data containing features supported by device.
  */
-#define BLE_LL_CTRL_FEATURE_LEN             (8)
+#define BLE_LL_CTRL_FEATURE_LEN (8)
+
+/* FAST ENCRYPTION packet size */
+#define BLE_LL_CTRL_ENC_F_REQ_LEN (0)
+#define BLE_LL_CTRL_ENC_F_RSP_LEN (0)
+
+/* REKEY packet size */
+#define BLE_LL_CTRL_REKEY_REQ_LEN (0)
+#define BLE_LL_CTRL_REKEY_RSP_LEN (0)
 
 /*
  * LL control version ind
@@ -195,19 +209,19 @@ struct ble_ll_version_ind
     uint16_t sub_ver_num;
 };
 
-#define BLE_LL_CTRL_VERSION_IND_LEN         (5)
+#define BLE_LL_CTRL_VERSION_IND_LEN (5)
 
 /*
  * LL control reject ind
  *  -> error code (1 byte): contains reason why request was rejected.
  */
-#define BLE_LL_CTRL_REJ_IND_LEN             (1)
+#define BLE_LL_CTRL_REJ_IND_LEN (1)
 
 /*
  * LL control slave feature req
  *  -> 8 bytes of data containing features supported by device.
  */
-#define BLE_LL_CTRL_PERIPH_FEATURE_REQ_LEN   (8)
+#define BLE_LL_CTRL_PERIPH_FEATURE_REQ_LEN (8)
 
 /* LL control connection param req and connection param rsp */
 struct ble_ll_conn_params
@@ -226,7 +240,7 @@ struct ble_ll_conn_params
     uint16_t offset5;
 };
 
-#define BLE_LL_CTRL_CONN_PARAMS_LEN     (23)
+#define BLE_LL_CTRL_CONN_PARAMS_LEN (23)
 
 /* LL control reject ind ext */
 struct ble_ll_reject_ind_ext
@@ -235,10 +249,10 @@ struct ble_ll_reject_ind_ext
     uint8_t err_code;
 };
 
-#define BLE_LL_CTRL_REJECT_IND_EXT_LEN  (2)
+#define BLE_LL_CTRL_REJECT_IND_EXT_LEN (2)
 
 /* LL control ping req and ping rsp (contain no data) */
-#define BLE_LL_CTRL_PING_LEN            (0)
+#define BLE_LL_CTRL_PING_LEN (0)
 
 /*
  * LL control length req and length rsp
@@ -255,105 +269,157 @@ struct ble_ll_len_req
     uint16_t max_tx_time;
 };
 
-#define BLE_LL_CTRL_LENGTH_REQ_LEN      (8)
+#define BLE_LL_CTRL_LENGTH_REQ_LEN (8)
 
 /* PHY request/response */
-#define BLE_LL_CTRL_PHY_REQ_LEN         (2)
-#define BLE_LL_CTRL_PHY_RSP_LEN         (2)
-#define BLE_LL_CTRL_PHY_UPD_IND_LEN     (4)
+#define BLE_LL_CTRL_PHY_REQ_LEN (2)
+#define BLE_LL_CTRL_PHY_RSP_LEN (2)
+#define BLE_LL_CTRL_PHY_UPD_IND_LEN (4)
 
 /* Min used channels */
-#define BLE_LL_CTRL_MIN_USED_CHAN_LEN   (2)
+#define BLE_LL_CTRL_MIN_USED_CHAN_LEN (2)
 
 /* CTE REQ */
-#define BLE_LL_CTRL_CTE_REQ_LEN         (1)
+#define BLE_LL_CTRL_CTE_REQ_LEN (1)
 
 /* CTE RSP (contains no data) */
-#define BLE_LL_CTRL_CTE_RSP_LEN     (0)
+#define BLE_LL_CTRL_CTE_RSP_LEN (0)
 
 /* Periodic Sync Transfer IND */
-#define BLE_LL_CTRL_PERIODIC_SYNC_IND_LEN   (34)
+#define BLE_LL_CTRL_PERIODIC_SYNC_IND_LEN (34)
 
 /* Clock accuracy request/response */
-#define BLE_LL_CTRL_CLOCK_ACCURACY_REQ_LEN  (1)
-#define BLE_LL_CTRL_CLOCK_ACCURACY_RSP_LEN  (1)
+#define BLE_LL_CTRL_CLOCK_ACCURACY_REQ_LEN (1)
+#define BLE_LL_CTRL_CLOCK_ACCURACY_RSP_LEN (1)
 
 /* BLE ISO */
-#define BLE_LL_CTRL_CIS_REQ_LEN         (42)
-#define BLE_LL_CTRL_CIS_RSP_LEN         (8)
-#define BLE_LL_CTRL_CIS_IND_LEN         (15)
-#define BLE_LL_CTRL_CIS_TERMINATE_LEN   (3)
-
-#define BLE_LL_CTRL_POWER_CONTROL_REQ_LEN       (3)
-#define BLE_LL_CTRL_POWER_CONTROL_RSP_LEN       (4)
-#define BLE_LL_CTRL_POWER_CHANGE_IND_LEN        (4)
-#define BLE_LL_CTRL_SUBRATE_REQ_LEN             (10)
-#define BLE_LL_CTRL_SUBRATE_IND_LEN             (10)
-#define BLE_LL_CTRL_CHAN_REPORTING_IND_LEN      (3)
-#define BLE_LL_CTRL_CHAN_STATUS_IND_LEN         (10)
+#define BLE_LL_CTRL_CIS_REQ_LEN (42)
+#define BLE_LL_CTRL_CIS_RSP_LEN (8)
+#define BLE_LL_CTRL_CIS_IND_LEN (15)
+#define BLE_LL_CTRL_CIS_TERMINATE_LEN (3)
+
+#define BLE_LL_CTRL_POWER_CONTROL_REQ_LEN (3)
+#define BLE_LL_CTRL_POWER_CONTROL_RSP_LEN (4)
+#define BLE_LL_CTRL_POWER_CHANGE_IND_LEN (4)
+#define BLE_LL_CTRL_SUBRATE_REQ_LEN (10)
+#define BLE_LL_CTRL_SUBRATE_IND_LEN (10)
+#define BLE_LL_CTRL_CHAN_REPORTING_IND_LEN (3)
+#define BLE_LL_CTRL_CHAN_STATUS_IND_LEN (10)
 
 /* API */
 struct ble_ll_conn_sm;
-void ble_ll_ctrl_proc_start(struct ble_ll_conn_sm *connsm, int ctrl_proc,
-                            void *data);
-void ble_ll_ctrl_proc_stop(struct ble_ll_conn_sm *connsm, int ctrl_proc);
-int ble_ll_ctrl_rx_pdu(struct ble_ll_conn_sm *connsm, struct os_mbuf *om);
-void ble_ll_ctrl_chk_proc_start(struct ble_ll_conn_sm *connsm);
-void ble_ll_ctrl_terminate_start(struct ble_ll_conn_sm *connsm);
-int ble_ll_ctrl_is_terminate_ind(uint8_t hdr, uint8_t opcode);
-uint8_t ble_ll_ctrl_conn_param_reply(struct ble_ll_conn_sm *connsm,
-                                     uint8_t *rsp,
-                                     struct ble_ll_conn_params *req);
-int ble_ll_ctrl_reject_ind_send(struct ble_ll_conn_sm *connsm,
-                                uint8_t rej_opcode, uint8_t err);
-int ble_ll_ctrl_start_enc_send(struct ble_ll_conn_sm *connsm);
-int ble_ll_ctrl_enc_allowed_pdu_rx(struct os_mbuf *rxpdu);
-int ble_ll_ctrl_enc_allowed_pdu_tx(struct os_mbuf_pkthdr *pkthdr);
-int ble_ll_ctrl_tx_start(struct ble_ll_conn_sm *connsm, struct os_mbuf *txpdu);
-int ble_ll_ctrl_tx_done(struct os_mbuf *txpdu, struct ble_ll_conn_sm *connsm);
-int ble_ll_ctrl_is_start_enc_rsp(struct os_mbuf *txpdu);
-
-void ble_ll_hci_ev_datalen_chg(struct ble_ll_conn_sm *connsm);
-void ble_ll_hci_ev_rem_conn_parm_req(struct ble_ll_conn_sm *connsm,
-                                     struct ble_ll_conn_params *cp);
-void ble_ll_hci_ev_conn_update(struct ble_ll_conn_sm *connsm, uint8_t status);
-void ble_ll_hci_ev_rd_rem_used_feat(struct ble_ll_conn_sm *connsm,
-                                      uint8_t status);
-void ble_ll_hci_ev_rd_rem_ver(struct ble_ll_conn_sm *connsm, uint8_t status);
-void ble_ll_hci_ev_encrypt_chg(struct ble_ll_conn_sm *connsm, uint8_t status);
-int ble_ll_hci_ev_ltk_req(struct ble_ll_conn_sm *connsm);
-int ble_ll_hci_ev_hw_err(uint8_t hw_err);
-void ble_ll_hci_ev_databuf_overflow(void);
-void ble_ll_hci_ev_le_csa(struct ble_ll_conn_sm *connsm);
-void ble_ll_hci_ev_send_scan_req_recv(uint8_t adv_handle, const uint8_t *peer,
-                                      uint8_t peer_addr_type);
-void ble_ll_hci_ev_send_scan_timeout(void);
-void ble_ll_hci_ev_send_adv_set_terminated(uint8_t status, uint8_t adv_handle,
-                                           uint16_t conn_handle, uint8_t events);
-int ble_ll_hci_ev_phy_update(struct ble_ll_conn_sm *connsm, uint8_t status);
-void ble_ll_calc_session_key(struct ble_ll_conn_sm *connsm);
-void ble_ll_ctrl_phy_update_proc_complete(struct ble_ll_conn_sm *connsm);
-void ble_ll_ctrl_initiate_dle(struct ble_ll_conn_sm *connsm, bool initial);
-void ble_ll_hci_ev_send_vs_assert(const char *file, uint32_t line);
-void ble_ll_hci_ev_send_vs_printf(uint8_t id, const char *fmt, ...);
-void ble_ll_hci_ev_send_vs_llcp_trace(uint8_t type, uint16_t handle, uint16_t count,
-                                      void *pdu, size_t length);
-
-uint8_t ble_ll_ctrl_phy_tx_transition_get(uint8_t phy_mask);
-uint8_t ble_ll_ctrl_phy_from_phy_mask(uint8_t phy_mask);
+void
+ble_ll_ctrl_proc_start(struct ble_ll_conn_sm* connsm, int ctrl_proc,
+                       void* data);
+void
+ble_ll_ctrl_proc_stop(struct ble_ll_conn_sm* connsm, int ctrl_proc);
+int
+ble_ll_ctrl_rx_pdu(struct ble_ll_conn_sm* connsm, struct os_mbuf* om);
+void
+ble_ll_ctrl_chk_proc_start(struct ble_ll_conn_sm* connsm);
+void
+ble_ll_ctrl_terminate_start(struct ble_ll_conn_sm* connsm);
+int
+ble_ll_ctrl_is_terminate_ind(uint8_t hdr, uint8_t opcode);
+uint8_t
+ble_ll_ctrl_conn_param_reply(struct ble_ll_conn_sm* connsm, uint8_t* rsp,
+                             struct ble_ll_conn_params* req);
+int
+ble_ll_ctrl_reject_ind_send(struct ble_ll_conn_sm* connsm, uint8_t rej_opcode,
+                            uint8_t err);
+int
+ble_ll_ctrl_start_enc_send(struct ble_ll_conn_sm* connsm);
+int
+ble_ll_ctrl_enc_allowed_pdu_rx(struct os_mbuf* rxpdu);
+int
+ble_ll_ctrl_enc_allowed_pdu_tx(struct os_mbuf_pkthdr* pkthdr);
+int
+ble_ll_ctrl_tx_start(struct ble_ll_conn_sm* connsm, struct os_mbuf* txpdu);
+int
+ble_ll_ctrl_tx_done(struct os_mbuf* txpdu, struct ble_ll_conn_sm* connsm);
+int
+ble_ll_ctrl_is_start_enc_rsp(struct os_mbuf* txpdu);
+
+/* FAST ENCRYPTION */
+int
+ble_ll_ctrl_f_enc_req_send(struct ble_ll_conn_sm* connsm);
+int
+ble_ll_ctrl_rx_f_enc_req(struct ble_ll_conn_sm* connsm);
+void
+ble_ll_ctrl_rx_f_enc_rsp(struct ble_ll_conn_sm* connsm);
+
+/* REKEY */
+int
+ble_ll_ctrl_rekey_req_send(struct ble_ll_conn_sm* connsm);
+int
+ble_ll_ctrl_rx_rekey_req(struct ble_ll_conn_sm* connsm);
+void
+ble_ll_ctrl_rx_rekey_rsp(struct ble_ll_conn_sm* connsm);
+
+void
+ble_ll_hci_ev_datalen_chg(struct ble_ll_conn_sm* connsm);
+void
+ble_ll_hci_ev_rem_conn_parm_req(struct ble_ll_conn_sm* connsm,
+                                struct ble_ll_conn_params* cp);
+void
+ble_ll_hci_ev_conn_update(struct ble_ll_conn_sm* connsm, uint8_t status);
+void
+ble_ll_hci_ev_rd_rem_used_feat(struct ble_ll_conn_sm* connsm, uint8_t status);
+void
+ble_ll_hci_ev_rd_rem_ver(struct ble_ll_conn_sm* connsm, uint8_t status);
+void
+ble_ll_hci_ev_encrypt_chg(struct ble_ll_conn_sm* connsm, uint8_t status);
+int
+ble_ll_hci_ev_ltk_req(struct ble_ll_conn_sm* connsm);
+int
+ble_ll_hci_ev_hw_err(uint8_t hw_err);
+void
+ble_ll_hci_ev_databuf_overflow(void);
+void
+ble_ll_hci_ev_le_csa(struct ble_ll_conn_sm* connsm);
+void
+ble_ll_hci_ev_send_scan_req_recv(uint8_t adv_handle, const uint8_t* peer,
+                                 uint8_t peer_addr_type);
+void
+ble_ll_hci_ev_send_scan_timeout(void);
+void
+ble_ll_hci_ev_send_adv_set_terminated(uint8_t status, uint8_t adv_handle,
+                                      uint16_t conn_handle, uint8_t events);
+int
+ble_ll_hci_ev_phy_update(struct ble_ll_conn_sm* connsm, uint8_t status);
+void
+ble_ll_calc_session_key(struct ble_ll_conn_sm* connsm);
+void
+ble_ll_ctrl_phy_update_proc_complete(struct ble_ll_conn_sm* connsm);
+void
+ble_ll_ctrl_initiate_dle(struct ble_ll_conn_sm* connsm, bool initial);
+void
+ble_ll_hci_ev_send_vs_assert(const char* file, uint32_t line);
+void
+ble_ll_hci_ev_send_vs_printf(uint8_t id, const char* fmt, ...);
+void
+ble_ll_hci_ev_send_vs_llcp_trace(uint8_t type, uint16_t handle, uint16_t count,
+                                 void* pdu, size_t length);
+
+uint8_t
+ble_ll_ctrl_phy_tx_transition_get(uint8_t phy_mask);
+uint8_t
+ble_ll_ctrl_phy_from_phy_mask(uint8_t phy_mask);
 
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_SCA_UPDATE)
-void ble_ll_hci_ev_sca_update(struct ble_ll_conn_sm *connsm,
-                              uint8_t status, uint8_t peer_sca);
+void
+ble_ll_hci_ev_sca_update(struct ble_ll_conn_sm* connsm, uint8_t status,
+                         uint8_t peer_sca);
 #endif
 
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_ENHANCED_CONN_UPDATE)
-void ble_ll_hci_ev_subrate_change(struct ble_ll_conn_sm *connsm, uint8_t status);
+void
+ble_ll_hci_ev_subrate_change(struct ble_ll_conn_sm* connsm, uint8_t status);
 #endif
 
 #if MYNEWT_VAL(BLE_LL_HCI_VS_CONN_STRICT_SCHED)
-void ble_ll_hci_ev_send_vs_css_slot_changed(uint16_t conn_handle,
-                                            uint16_t slot_idx);
+void
+ble_ll_hci_ev_send_vs_css_slot_changed(uint16_t conn_handle, uint16_t slot_idx);
 #endif
 
 #ifdef __cplusplus
diff --git a/nimble/controller/src/ble_ll_conn.c b/nimble/controller/src/ble_ll_conn.c
index 789b948a..3bf7e335 100644
--- a/nimble/controller/src/ble_ll_conn.c
+++ b/nimble/controller/src/ble_ll_conn.c
@@ -50,11 +50,12 @@
 #endif
 
 #if (BLETEST_THROUGHPUT_TEST == 1)
-extern void bletest_completed_pkt(uint16_t handle);
+extern void
+bletest_completed_pkt(uint16_t handle);
 #endif
 
 #if MYNEWT_VAL(BLE_LL_CONN_STRICT_SCHED)
-struct ble_ll_conn_sm *g_ble_ll_conn_css_ref;
+struct ble_ll_conn_sm* g_ble_ll_conn_css_ref;
 #endif
 
 /* XXX TODO
@@ -143,12 +144,12 @@ struct ble_ll_empty_pdu
 
 /* We cannot have more than 254 connections given our current implementation */
 #if (MYNEWT_VAL(BLE_MAX_CONNECTIONS) >= 255)
-    #error "Maximum # of connections is 254"
+#error "Maximum # of connections is 254"
 #endif
 
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
 /* Global connection complete event. Used when initiating */
-uint8_t *g_ble_ll_conn_comp_ev;
+uint8_t* g_ble_ll_conn_comp_ev;
 #endif
 
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_PERIODIC_ADV_SYNC_TRANSFER)
@@ -161,7 +162,7 @@ struct ble_ll_conn_create_sm g_ble_ll_conn_create_sm;
 #endif
 
 /* Pointer to current connection */
-struct ble_ll_conn_sm *g_ble_ll_conn_cur_sm;
+struct ble_ll_conn_sm* g_ble_ll_conn_cur_sm;
 
 /* Connection state machine array */
 struct ble_ll_conn_sm g_ble_ll_conn_sm[MYNEWT_VAL(BLE_MAX_CONNECTIONS)];
@@ -178,74 +179,76 @@ struct ble_ll_conn_css_list g_ble_ll_conn_css_list;
 #endif
 
 STATS_SECT_START(ble_ll_conn_stats)
-    STATS_SECT_ENTRY(cant_set_sched)
-    STATS_SECT_ENTRY(conn_ev_late)
-    STATS_SECT_ENTRY(wfr_expirations)
-    STATS_SECT_ENTRY(handle_not_found)
-    STATS_SECT_ENTRY(no_conn_sm)
-    STATS_SECT_ENTRY(no_free_conn_sm)
-    STATS_SECT_ENTRY(rx_data_pdu_no_conn)
-    STATS_SECT_ENTRY(rx_data_pdu_bad_aa)
-    STATS_SECT_ENTRY(periph_rxd_bad_conn_req_params)
-    STATS_SECT_ENTRY(periph_ce_failures)
-    STATS_SECT_ENTRY(data_pdu_rx_dup)
-    STATS_SECT_ENTRY(data_pdu_txg)
-    STATS_SECT_ENTRY(data_pdu_txf)
-    STATS_SECT_ENTRY(conn_req_txd)
-    STATS_SECT_ENTRY(l2cap_enqueued)
-    STATS_SECT_ENTRY(rx_ctrl_pdus)
-    STATS_SECT_ENTRY(rx_l2cap_pdus)
-    STATS_SECT_ENTRY(rx_l2cap_bytes)
-    STATS_SECT_ENTRY(rx_malformed_ctrl_pdus)
-    STATS_SECT_ENTRY(rx_bad_llid)
-    STATS_SECT_ENTRY(tx_ctrl_pdus)
-    STATS_SECT_ENTRY(tx_ctrl_bytes)
-    STATS_SECT_ENTRY(tx_l2cap_pdus)
-    STATS_SECT_ENTRY(tx_l2cap_bytes)
-    STATS_SECT_ENTRY(tx_empty_pdus)
-    STATS_SECT_ENTRY(mic_failures)
-    STATS_SECT_ENTRY(sched_start_in_idle)
-    STATS_SECT_ENTRY(sched_end_in_idle)
-    STATS_SECT_ENTRY(conn_event_while_tmo)
+STATS_SECT_ENTRY(cant_set_sched)
+STATS_SECT_ENTRY(conn_ev_late)
+STATS_SECT_ENTRY(wfr_expirations)
+STATS_SECT_ENTRY(handle_not_found)
+STATS_SECT_ENTRY(no_conn_sm)
+STATS_SECT_ENTRY(no_free_conn_sm)
+STATS_SECT_ENTRY(rx_data_pdu_no_conn)
+STATS_SECT_ENTRY(rx_data_pdu_bad_aa)
+STATS_SECT_ENTRY(periph_rxd_bad_conn_req_params)
+STATS_SECT_ENTRY(periph_ce_failures)
+STATS_SECT_ENTRY(data_pdu_rx_dup)
+STATS_SECT_ENTRY(data_pdu_txg)
+STATS_SECT_ENTRY(data_pdu_txf)
+STATS_SECT_ENTRY(conn_req_txd)
+STATS_SECT_ENTRY(l2cap_enqueued)
+STATS_SECT_ENTRY(rx_ctrl_pdus)
+STATS_SECT_ENTRY(rx_l2cap_pdus)
+STATS_SECT_ENTRY(rx_l2cap_bytes)
+STATS_SECT_ENTRY(rx_malformed_ctrl_pdus)
+STATS_SECT_ENTRY(rx_bad_llid)
+STATS_SECT_ENTRY(tx_ctrl_pdus)
+STATS_SECT_ENTRY(tx_ctrl_bytes)
+STATS_SECT_ENTRY(tx_l2cap_pdus)
+STATS_SECT_ENTRY(tx_l2cap_bytes)
+STATS_SECT_ENTRY(tx_empty_pdus)
+STATS_SECT_ENTRY(mic_failures)
+STATS_SECT_ENTRY(sched_start_in_idle)
+STATS_SECT_ENTRY(sched_end_in_idle)
+STATS_SECT_ENTRY(conn_event_while_tmo)
 STATS_SECT_END
 STATS_SECT_DECL(ble_ll_conn_stats) ble_ll_conn_stats;
 
 STATS_NAME_START(ble_ll_conn_stats)
-    STATS_NAME(ble_ll_conn_stats, cant_set_sched)
-    STATS_NAME(ble_ll_conn_stats, conn_ev_late)
-    STATS_NAME(ble_ll_conn_stats, wfr_expirations)
-    STATS_NAME(ble_ll_conn_stats, handle_not_found)
-    STATS_NAME(ble_ll_conn_stats, no_conn_sm)
-    STATS_NAME(ble_ll_conn_stats, no_free_conn_sm)
-    STATS_NAME(ble_ll_conn_stats, rx_data_pdu_no_conn)
-    STATS_NAME(ble_ll_conn_stats, rx_data_pdu_bad_aa)
-    STATS_NAME(ble_ll_conn_stats, periph_rxd_bad_conn_req_params)
-    STATS_NAME(ble_ll_conn_stats, periph_ce_failures)
-    STATS_NAME(ble_ll_conn_stats, data_pdu_rx_dup)
-    STATS_NAME(ble_ll_conn_stats, data_pdu_txg)
-    STATS_NAME(ble_ll_conn_stats, data_pdu_txf)
-    STATS_NAME(ble_ll_conn_stats, conn_req_txd)
-    STATS_NAME(ble_ll_conn_stats, l2cap_enqueued)
-    STATS_NAME(ble_ll_conn_stats, rx_ctrl_pdus)
-    STATS_NAME(ble_ll_conn_stats, rx_l2cap_pdus)
-    STATS_NAME(ble_ll_conn_stats, rx_l2cap_bytes)
-    STATS_NAME(ble_ll_conn_stats, rx_malformed_ctrl_pdus)
-    STATS_NAME(ble_ll_conn_stats, rx_bad_llid)
-    STATS_NAME(ble_ll_conn_stats, tx_ctrl_pdus)
-    STATS_NAME(ble_ll_conn_stats, tx_ctrl_bytes)
-    STATS_NAME(ble_ll_conn_stats, tx_l2cap_pdus)
-    STATS_NAME(ble_ll_conn_stats, tx_l2cap_bytes)
-    STATS_NAME(ble_ll_conn_stats, tx_empty_pdus)
-    STATS_NAME(ble_ll_conn_stats, mic_failures)
-    STATS_NAME(ble_ll_conn_stats, sched_start_in_idle)
-    STATS_NAME(ble_ll_conn_stats, sched_end_in_idle)
-    STATS_NAME(ble_ll_conn_stats, conn_event_while_tmo)
+STATS_NAME(ble_ll_conn_stats, cant_set_sched)
+STATS_NAME(ble_ll_conn_stats, conn_ev_late)
+STATS_NAME(ble_ll_conn_stats, wfr_expirations)
+STATS_NAME(ble_ll_conn_stats, handle_not_found)
+STATS_NAME(ble_ll_conn_stats, no_conn_sm)
+STATS_NAME(ble_ll_conn_stats, no_free_conn_sm)
+STATS_NAME(ble_ll_conn_stats, rx_data_pdu_no_conn)
+STATS_NAME(ble_ll_conn_stats, rx_data_pdu_bad_aa)
+STATS_NAME(ble_ll_conn_stats, periph_rxd_bad_conn_req_params)
+STATS_NAME(ble_ll_conn_stats, periph_ce_failures)
+STATS_NAME(ble_ll_conn_stats, data_pdu_rx_dup)
+STATS_NAME(ble_ll_conn_stats, data_pdu_txg)
+STATS_NAME(ble_ll_conn_stats, data_pdu_txf)
+STATS_NAME(ble_ll_conn_stats, conn_req_txd)
+STATS_NAME(ble_ll_conn_stats, l2cap_enqueued)
+STATS_NAME(ble_ll_conn_stats, rx_ctrl_pdus)
+STATS_NAME(ble_ll_conn_stats, rx_l2cap_pdus)
+STATS_NAME(ble_ll_conn_stats, rx_l2cap_bytes)
+STATS_NAME(ble_ll_conn_stats, rx_malformed_ctrl_pdus)
+STATS_NAME(ble_ll_conn_stats, rx_bad_llid)
+STATS_NAME(ble_ll_conn_stats, tx_ctrl_pdus)
+STATS_NAME(ble_ll_conn_stats, tx_ctrl_bytes)
+STATS_NAME(ble_ll_conn_stats, tx_l2cap_pdus)
+STATS_NAME(ble_ll_conn_stats, tx_l2cap_bytes)
+STATS_NAME(ble_ll_conn_stats, tx_empty_pdus)
+STATS_NAME(ble_ll_conn_stats, mic_failures)
+STATS_NAME(ble_ll_conn_stats, sched_start_in_idle)
+STATS_NAME(ble_ll_conn_stats, sched_end_in_idle)
+STATS_NAME(ble_ll_conn_stats, conn_event_while_tmo)
 STATS_NAME_END(ble_ll_conn_stats)
 
-static void ble_ll_conn_event_end(struct ble_npl_event *ev);
+static void
+ble_ll_conn_event_end(struct ble_npl_event* ev);
 
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_CTRL_TO_HOST_FLOW_CONTROL)
-struct ble_ll_conn_cth_flow {
+struct ble_ll_conn_cth_flow
+{
     bool enabled;
     uint16_t max_buffers;
     uint16_t num_buffers;
@@ -262,9 +265,9 @@ ble_ll_conn_cth_flow_is_enabled(void)
 }
 
 static bool
-ble_ll_conn_cth_flow_alloc_credit(struct ble_ll_conn_sm *connsm)
+ble_ll_conn_cth_flow_alloc_credit(struct ble_ll_conn_sm* connsm)
 {
-    struct ble_ll_conn_cth_flow *cth = &g_ble_ll_conn_cth_flow;
+    struct ble_ll_conn_cth_flow* cth = &g_ble_ll_conn_cth_flow;
     os_sr_t sr;
 
     OS_ENTER_CRITICAL(sr);
@@ -283,9 +286,10 @@ ble_ll_conn_cth_flow_alloc_credit(struct ble_ll_conn_sm *connsm)
 }
 
 static void
-ble_ll_conn_cth_flow_free_credit(struct ble_ll_conn_sm *connsm, uint16_t credits)
+ble_ll_conn_cth_flow_free_credit(struct ble_ll_conn_sm* connsm,
+                                 uint16_t credits)
 {
-    struct ble_ll_conn_cth_flow *cth = &g_ble_ll_conn_cth_flow;
+    struct ble_ll_conn_cth_flow* cth = &g_ble_ll_conn_cth_flow;
     os_sr_t sr;
 
     OS_ENTER_CRITICAL(sr);
@@ -303,7 +307,8 @@ ble_ll_conn_cth_flow_free_credit(struct ble_ll_conn_sm *connsm, uint16_t credits
 
     if (connsm->cth_flow_pending < credits) {
         connsm->cth_flow_pending = 0;
-    } else {
+    }
+    else {
         connsm->cth_flow_pending -= credits;
     }
 
@@ -311,10 +316,10 @@ ble_ll_conn_cth_flow_free_credit(struct ble_ll_conn_sm *connsm, uint16_t credits
 }
 
 static void
-ble_ll_conn_cth_flow_error_fn(struct ble_npl_event *ev)
+ble_ll_conn_cth_flow_error_fn(struct ble_npl_event* ev)
 {
-    struct ble_hci_ev *hci_ev;
-    struct ble_hci_ev_command_complete *hci_ev_cp;
+    struct ble_hci_ev* hci_ev;
+    struct ble_hci_ev_command_complete* hci_ev_cp;
     uint16_t opcode;
 
     hci_ev = ble_transport_alloc_evt(0);
@@ -337,7 +342,7 @@ ble_ll_conn_cth_flow_error_fn(struct ble_npl_event *ev)
     hci_ev->opcode = BLE_HCI_EVCODE_COMMAND_COMPLETE;
     hci_ev->length = sizeof(*hci_ev_cp);
 
-    hci_ev_cp = (void *)hci_ev->data;
+    hci_ev_cp = (void*)hci_ev->data;
     hci_ev_cp->num_packets = BLE_LL_CFG_NUM_HCI_CMD_PKTS;
     hci_ev_cp->opcode = htole16(opcode);
     hci_ev_cp->status = BLE_ERR_INV_HCI_CMD_PARMS;
@@ -357,7 +362,7 @@ ble_ll_conn_cth_flow_set_buffers(uint16_t num_buffers)
 bool
 ble_ll_conn_cth_flow_enable(bool enabled)
 {
-    struct ble_ll_conn_cth_flow *cth = &g_ble_ll_conn_cth_flow;
+    struct ble_ll_conn_cth_flow* cth = &g_ble_ll_conn_cth_flow;
 
     if (cth->enabled == enabled) {
         return true;
@@ -373,15 +378,15 @@ ble_ll_conn_cth_flow_enable(bool enabled)
 }
 
 void
-ble_ll_conn_cth_flow_process_cmd(const uint8_t *cmdbuf)
+ble_ll_conn_cth_flow_process_cmd(const uint8_t* cmdbuf)
 {
-    const struct ble_hci_cmd *cmd;
-    const struct ble_hci_cb_host_num_comp_pkts_cp *cp;
-    struct ble_ll_conn_sm *connsm;
+    const struct ble_hci_cmd* cmd;
+    const struct ble_hci_cb_host_num_comp_pkts_cp* cp;
+    struct ble_ll_conn_sm* connsm;
     int i;
 
-    cmd = (const void *)cmdbuf;
-    cp = (const void *)cmd->data;
+    cmd = (const void*)cmdbuf;
+    cp = (const void*)cmd->data;
 
     if (cmd->length != sizeof(cp->handles) + cp->handles * sizeof(cp->h[0])) {
         ble_ll_event_add(&g_ble_ll_conn_cth_flow_error_ev);
@@ -406,18 +411,20 @@ ble_ll_conn_cth_flow_process_cmd(const uint8_t *cmdbuf)
 
 #if MYNEWT_VAL(BLE_LL_CONN_STRICT_SCHED)
 static void
-ble_ll_conn_css_update_list(struct ble_ll_conn_sm *connsm)
+ble_ll_conn_css_update_list(struct ble_ll_conn_sm* connsm)
 {
-    struct ble_ll_conn_sm *e;
-    struct ble_ll_conn_sm *e_last;
-    struct ble_ll_conn_sm *e_insert_after = NULL;
+    struct ble_ll_conn_sm* e;
+    struct ble_ll_conn_sm* e_last;
+    struct ble_ll_conn_sm* e_insert_after = NULL;
     bool found_to_insert = false;
 
     if (SLIST_FIRST(&g_ble_ll_conn_css_list) == connsm) {
         SLIST_REMOVE_HEAD(&g_ble_ll_conn_css_list, css_sle);
-    } else {
+    }
+    else {
         e_last = NULL;
-        SLIST_FOREACH(e, &g_ble_ll_conn_css_list, css_sle) {
+        SLIST_FOREACH(e, &g_ble_ll_conn_css_list, css_sle)
+        {
             if (e == connsm) {
                 SLIST_NEXT(e_last, css_sle) = SLIST_NEXT(e, css_sle);
                 break;
@@ -432,7 +439,8 @@ ble_ll_conn_css_update_list(struct ble_ll_conn_sm *connsm)
     }
 
     e_last = NULL;
-    SLIST_FOREACH(e, &g_ble_ll_conn_css_list, css_sle) {
+    SLIST_FOREACH(e, &g_ble_ll_conn_css_list, css_sle)
+    {
         if (e->css_slot_idx > connsm->css_slot_idx) {
             found_to_insert = true;
             e_insert_after = e_last;
@@ -445,10 +453,12 @@ ble_ll_conn_css_update_list(struct ble_ll_conn_sm *connsm)
     if (found_to_insert) {
         if (e_insert_after) {
             SLIST_INSERT_AFTER(e_last, connsm, css_sle);
-        } else {
+        }
+        else {
             SLIST_INSERT_HEAD(&g_ble_ll_conn_css_list, connsm, css_sle);
         }
-    } else {
+    }
+    else {
         SLIST_INSERT_AFTER(e_last, connsm, css_sle);
     }
 }
@@ -462,7 +472,7 @@ ble_ll_conn_css_set_next_slot(uint16_t slot_idx)
 uint16_t
 ble_ll_conn_css_get_next_slot(void)
 {
-    struct ble_ll_conn_sm *connsm;
+    struct ble_ll_conn_sm* connsm;
     uint16_t slot_idx = 0;
 
     if (g_ble_ll_conn_css_next_slot != BLE_LL_CONN_CSS_NO_SLOT) {
@@ -472,7 +482,8 @@ ble_ll_conn_css_get_next_slot(void)
     /* CSS connections are sorted in active conn list so just need to find 1st
      * free value.
      */
-    SLIST_FOREACH(connsm, &g_ble_ll_conn_css_list, css_sle) {
+    SLIST_FOREACH(connsm, &g_ble_ll_conn_css_list, css_sle)
+    {
         if ((connsm->css_slot_idx != slot_idx) &&
             (connsm->css_slot_idx_pending != slot_idx)) {
             break;
@@ -490,13 +501,14 @@ ble_ll_conn_css_get_next_slot(void)
 int
 ble_ll_conn_css_is_slot_busy(uint16_t slot_idx)
 {
-    struct ble_ll_conn_sm *connsm;
+    struct ble_ll_conn_sm* connsm;
 
     if (g_ble_ll_conn_css_next_slot == slot_idx) {
         return 1;
     }
 
-    SLIST_FOREACH(connsm, &g_ble_ll_conn_css_list, css_sle) {
+    SLIST_FOREACH(connsm, &g_ble_ll_conn_css_list, css_sle)
+    {
         if ((connsm->css_slot_idx == slot_idx) ||
             (connsm->css_slot_idx_pending == slot_idx)) {
             return 1;
@@ -507,7 +519,7 @@ ble_ll_conn_css_is_slot_busy(uint16_t slot_idx)
 }
 
 int
-ble_ll_conn_css_move(struct ble_ll_conn_sm *connsm, uint16_t slot_idx)
+ble_ll_conn_css_move(struct ble_ll_conn_sm* connsm, uint16_t slot_idx)
 {
     int16_t slot_diff;
     uint32_t offset;
@@ -524,7 +536,8 @@ ble_ll_conn_css_move(struct ble_ll_conn_sm *connsm, uint16_t slot_idx)
         slot_diff += ble_ll_sched_css_get_period_slots();
     }
 
-    offset = slot_diff * ble_ll_sched_css_get_slot_us() / BLE_LL_CONN_ITVL_USECS;
+    offset =
+        slot_diff * ble_ll_sched_css_get_slot_us() / BLE_LL_CONN_ITVL_USECS;
 
     if (offset >= 0xffff) {
         return -1;
@@ -539,12 +552,13 @@ ble_ll_conn_css_move(struct ble_ll_conn_sm *connsm, uint16_t slot_idx)
 }
 #endif
 
-struct ble_ll_conn_sm *
-ble_ll_conn_find_by_peer_addr(const uint8_t *addr, uint8_t addr_type)
+struct ble_ll_conn_sm*
+ble_ll_conn_find_by_peer_addr(const uint8_t* addr, uint8_t addr_type)
 {
-    struct ble_ll_conn_sm *connsm;
+    struct ble_ll_conn_sm* connsm;
 
-    SLIST_FOREACH(connsm, &g_ble_ll_conn_active_list, act_sle) {
+    SLIST_FOREACH(connsm, &g_ble_ll_conn_active_list, act_sle)
+    {
         if (!memcmp(&connsm->peer_addr, addr, BLE_DEV_ADDR_LEN) &&
             !((connsm->peer_addr_type ^ addr_type) & 1)) {
             return connsm;
@@ -574,7 +588,7 @@ ble_ll_conn_phy_should_update(uint8_t pref_mask, uint8_t curr_mask)
 }
 
 int
-ble_ll_conn_phy_update_if_needed(struct ble_ll_conn_sm *connsm)
+ble_ll_conn_phy_update_if_needed(struct ble_ll_conn_sm* connsm)
 {
     if (!ble_ll_conn_phy_should_update(connsm->phy_data.pref_mask_tx,
                                        CONN_CUR_TX_PHY_MASK(connsm)) &&
@@ -593,8 +607,8 @@ ble_ll_conn_phy_update_if_needed(struct ble_ll_conn_sm *connsm)
 #endif
 
 void
-ble_ll_conn_itvl_to_ticks(uint32_t itvl, uint32_t *itvl_ticks,
-                          uint8_t *itvl_usecs)
+ble_ll_conn_itvl_to_ticks(uint32_t itvl, uint32_t* itvl_ticks,
+                          uint8_t* itvl_usecs)
 {
     *itvl_ticks = ble_ll_tmr_u2t_r(itvl * BLE_LL_CONN_ITVL_USECS, itvl_usecs);
 }
@@ -606,10 +620,10 @@ ble_ll_conn_itvl_to_ticks(uint32_t itvl, uint32_t *itvl_ticks,
  * @return uint8_t*
  */
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
-static uint8_t *
+static uint8_t*
 ble_ll_init_get_conn_comp_ev(void)
 {
-    uint8_t *evbuf;
+    uint8_t* evbuf;
 
     evbuf = g_ble_ll_conn_comp_ev;
     BLE_LL_ASSERT(evbuf != NULL);
@@ -624,7 +638,7 @@ ble_ll_init_get_conn_comp_ev(void)
  * Called to determine if the received PDU is an empty PDU or not.
  */
 static int
-ble_ll_conn_is_empty_pdu(uint8_t *rxbuf)
+ble_ll_conn_is_empty_pdu(uint8_t* rxbuf)
 {
     int rc;
     uint8_t llid;
@@ -632,7 +646,8 @@ ble_ll_conn_is_empty_pdu(uint8_t *rxbuf)
     llid = rxbuf[0] & BLE_LL_DATA_HDR_LLID_MASK;
     if ((llid == BLE_LL_LLID_DATA_FRAG) && (rxbuf[1] == 0)) {
         rc = 1;
-    } else {
+    }
+    else {
         rc = 0;
     }
     return rc;
@@ -646,14 +661,15 @@ ble_ll_conn_is_empty_pdu(uint8_t *rxbuf)
  * @return int 0: s1 is not least recently used. 1: s1 is least recently used
  */
 int
-ble_ll_conn_is_lru(struct ble_ll_conn_sm *s1, struct ble_ll_conn_sm *s2)
+ble_ll_conn_is_lru(struct ble_ll_conn_sm* s1, struct ble_ll_conn_sm* s2)
 {
     int rc;
 
     /* Set time that we last serviced the schedule */
     if (LL_TMR_LT(s1->last_scheduled, s2->last_scheduled)) {
         rc = 1;
-    } else {
+    }
+    else {
         rc = 0;
     }
 
@@ -673,7 +689,8 @@ ble_ll_conn_get_ce_end_time(void)
 
     if (g_ble_ll_conn_cur_sm) {
         ce_end_time = g_ble_ll_conn_cur_sm->ce_end_time;
-    } else {
+    }
+    else {
         ce_end_time = ble_ll_tmr_get();
     }
     return ce_end_time;
@@ -703,7 +720,7 @@ ble_ll_conn_halt(void)
  * Called when the current connection state machine is no longer being used.
  */
 static void
-ble_ll_conn_current_sm_over(struct ble_ll_conn_sm *connsm)
+ble_ll_conn_current_sm_over(struct ble_ll_conn_sm* connsm)
 {
 
     ble_ll_conn_halt();
@@ -725,10 +742,10 @@ ble_ll_conn_current_sm_over(struct ble_ll_conn_sm *connsm)
  *
  * @return struct ble_ll_conn_sm*
  */
-struct ble_ll_conn_sm *
+struct ble_ll_conn_sm*
 ble_ll_conn_find_by_handle(uint16_t handle)
 {
-    struct ble_ll_conn_sm *connsm;
+    struct ble_ll_conn_sm* connsm;
 
     connsm = NULL;
     if ((handle != 0) && (handle <= MYNEWT_VAL(BLE_MAX_CONNECTIONS))) {
@@ -743,15 +760,16 @@ ble_ll_conn_find_by_handle(uint16_t handle)
 /**
  * Get a connection state machine.
  */
-struct ble_ll_conn_sm *
+struct ble_ll_conn_sm*
 ble_ll_conn_sm_get(void)
 {
-    struct ble_ll_conn_sm *connsm;
+    struct ble_ll_conn_sm* connsm;
 
     connsm = STAILQ_FIRST(&g_ble_ll_conn_free_list);
     if (connsm) {
         STAILQ_REMOVE_HEAD(&g_ble_ll_conn_free_list, free_stqe);
-    } else {
+    }
+    else {
         STATS_INC(ble_ll_conn_stats, no_free_conn_sm);
     }
 
@@ -759,7 +777,7 @@ ble_ll_conn_sm_get(void)
 }
 
 static uint8_t
-ble_ll_conn_calc_dci_csa1(struct ble_ll_conn_sm *conn)
+ble_ll_conn_calc_dci_csa1(struct ble_ll_conn_sm* conn)
 {
     uint8_t curchan;
     uint8_t remap_index;
@@ -796,7 +814,7 @@ ble_ll_conn_calc_dci_csa1(struct ble_ll_conn_sm *conn)
  * @return uint8_t
  */
 uint8_t
-ble_ll_conn_calc_dci(struct ble_ll_conn_sm *conn, uint16_t latency)
+ble_ll_conn_calc_dci(struct ble_ll_conn_sm* conn, uint16_t latency)
 {
     uint8_t index;
 
@@ -826,7 +844,7 @@ ble_ll_conn_calc_dci(struct ble_ll_conn_sm *conn, uint16_t latency)
 void
 ble_ll_conn_wfr_timer_exp(void)
 {
-    struct ble_ll_conn_sm *connsm;
+    struct ble_ll_conn_sm* connsm;
 
     connsm = g_ble_ll_conn_cur_sm;
     ble_ll_conn_current_sm_over(connsm);
@@ -843,22 +861,43 @@ ble_ll_conn_wfr_timer_exp(void)
  *
  */
 static void
-ble_ll_conn_wait_txend(void *arg)
+ble_ll_conn_wait_txend(void* arg)
 {
-    struct ble_ll_conn_sm *connsm;
+    struct ble_ll_conn_sm* connsm;
 
-    connsm = (struct ble_ll_conn_sm *)arg;
+    connsm = (struct ble_ll_conn_sm*)arg;
     ble_ll_conn_current_sm_over(connsm);
 }
 
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LE_ENCRYPTION)
 static void
-ble_ll_conn_start_rx_encrypt(void *arg)
+ble_ll_conn_key_refresh(void* arg)
 {
-    struct ble_ll_conn_sm *connsm;
+    struct ble_ll_conn_sm* connsm;
+    connsm = (struct ble_ll_conn_sm*)arg;
+    memcpy(connsm->enc_data.enc_block.cipher_text,
+           connsm->enc_data.enc_block.key,
+           sizeof(connsm->enc_data.enc_block.cipher_text));
+    memset(connsm->enc_data.iv, 0, 8);
+
+    // place keys in the right place
+    ble_phy_encrypt_enable(connsm->enc_data.enc_block.cipher_text);
+    ble_phy_encrypt_iv_set(connsm->enc_data.iv);
+    ble_phy_encrypt_counter_set(connsm->enc_data.rx_pkt_cntr,
+                                !CONN_IS_CENTRAL(connsm));
+    ble_phy_encrypt_counter_set(connsm->enc_data.tx_pkt_cntr,
+                                CONN_IS_CENTRAL(connsm));
+}
+
+static void
+ble_ll_conn_start_rx_encrypt(void* arg)
+{
+    struct ble_ll_conn_sm* connsm;
 
-    connsm = (struct ble_ll_conn_sm *)arg;
+    connsm = (struct ble_ll_conn_sm*)arg;
     connsm->flags.encrypted = 1;
+    // TODO: for test leave it zero
+    // memset(connsm->enc_data.iv, 0, 8);
     ble_phy_encrypt_enable(connsm->enc_data.enc_block.cipher_text);
     ble_phy_encrypt_iv_set(connsm->enc_data.iv);
     ble_phy_encrypt_counter_set(connsm->enc_data.rx_pkt_cntr,
@@ -867,44 +906,44 @@ ble_ll_conn_start_rx_encrypt(void *arg)
 
 #if MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL)
 static void
-ble_ll_conn_start_rx_unencrypt(void *arg)
+ble_ll_conn_start_rx_unencrypt(void* arg)
 {
-    struct ble_ll_conn_sm *connsm;
+    struct ble_ll_conn_sm* connsm;
 
-    connsm = (struct ble_ll_conn_sm *)arg;
+    connsm = (struct ble_ll_conn_sm*)arg;
     connsm->flags.encrypted = 0;
     ble_phy_encrypt_disable();
 }
 #endif
 
 static void
-ble_ll_conn_txend_encrypt(void *arg)
+ble_ll_conn_txend_encrypt(void* arg)
 {
-    struct ble_ll_conn_sm *connsm;
+    struct ble_ll_conn_sm* connsm;
 
-    connsm = (struct ble_ll_conn_sm *)arg;
+    connsm = (struct ble_ll_conn_sm*)arg;
     connsm->flags.encrypted = 1;
     ble_ll_conn_current_sm_over(connsm);
 }
 
 #if MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL)
 static void
-ble_ll_conn_rxend_unencrypt(void *arg)
+ble_ll_conn_rxend_unencrypt(void* arg)
 {
-    struct ble_ll_conn_sm *connsm;
+    struct ble_ll_conn_sm* connsm;
 
-    connsm = (struct ble_ll_conn_sm *)arg;
+    connsm = (struct ble_ll_conn_sm*)arg;
     connsm->flags.encrypted = 0;
     ble_ll_conn_current_sm_over(connsm);
 }
 #endif
 
 static void
-ble_ll_conn_continue_rx_encrypt(void *arg)
+ble_ll_conn_continue_rx_encrypt(void* arg)
 {
-    struct ble_ll_conn_sm *connsm;
+    struct ble_ll_conn_sm* connsm;
 
-    connsm = (struct ble_ll_conn_sm *)arg;
+    connsm = (struct ble_ll_conn_sm*)arg;
     ble_phy_encrypt_counter_set(connsm->enc_data.rx_pkt_cntr,
                                 !CONN_IS_CENTRAL(connsm));
 }
@@ -927,7 +966,7 @@ ble_ll_conn_continue_rx_encrypt(void *arg)
  * @return uint32_t
  */
 static uint32_t
-ble_ll_conn_get_next_sched_time(struct ble_ll_conn_sm *connsm)
+ble_ll_conn_get_next_sched_time(struct ble_ll_conn_sm* connsm)
 {
     uint32_t ce_end;
     uint32_t next_sched_time;
@@ -936,14 +975,15 @@ ble_ll_conn_get_next_sched_time(struct ble_ll_conn_sm *connsm)
     /* Calculate time at which next connection event will start */
     /* NOTE: We dont care if this time is tick short. */
     ce_end = connsm->anchor_point + connsm->conn_itvl_ticks -
-        g_ble_ll_sched_offset_ticks;
+             g_ble_ll_sched_offset_ticks;
     rem_us = connsm->anchor_point_usecs;
     ble_ll_tmr_add_u(&ce_end, &rem_us, connsm->conn_itvl_usecs);
 
     ce_end -= ble_ll_tmr_u2t_up(MYNEWT_VAL(BLE_LL_CONN_EVENT_END_MARGIN));
 
     if (connsm->max_ce_len_ticks) {
-        if (LL_TMR_LT(connsm->anchor_point + connsm->max_ce_len_ticks, ce_end)) {
+        if (LL_TMR_LT(connsm->anchor_point + connsm->max_ce_len_ticks,
+                      ce_end)) {
             ce_end = connsm->anchor_point + connsm->max_ce_len_ticks;
         }
     }
@@ -964,7 +1004,7 @@ ble_ll_conn_get_next_sched_time(struct ble_ll_conn_sm *connsm)
  * @param connsm
  */
 static void
-ble_ll_conn_chk_csm_flags(struct ble_ll_conn_sm *connsm)
+ble_ll_conn_chk_csm_flags(struct ble_ll_conn_sm* connsm)
 {
     uint8_t update_status;
 
@@ -992,7 +1032,8 @@ ble_ll_conn_chk_csm_flags(struct ble_ll_conn_sm *connsm)
         update_status = BLE_ERR_SUCCESS;
         if (IS_PENDING_CTRL_PROC(connsm, BLE_LL_CTRL_PROC_CONN_UPDATE)) {
             ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_CONN_UPDATE);
-        } else {
+        }
+        else {
             if (IS_PENDING_CTRL_PROC(connsm, BLE_LL_CTRL_PROC_CONN_PARAM_REQ)) {
                 ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_CONN_PARAM_REQ);
                 update_status = connsm->reject_reason;
@@ -1035,7 +1076,7 @@ ble_ll_conn_chk_csm_flags(struct ble_ll_conn_sm *connsm)
  * @return int 0: success; otherwise failure to transmit
  */
 static uint16_t
-ble_ll_conn_adjust_pyld_len(struct ble_ll_conn_sm *connsm, uint16_t pyld_len)
+ble_ll_conn_adjust_pyld_len(struct ble_ll_conn_sm* connsm, uint16_t pyld_len)
 {
     uint16_t max_pyld_len;
     uint16_t ret;
@@ -1046,16 +1087,17 @@ ble_ll_conn_adjust_pyld_len(struct ble_ll_conn_sm *connsm, uint16_t pyld_len)
     if (connsm->phy_tx_transition) {
         phy_mode = ble_ll_phy_to_phy_mode(connsm->phy_tx_transition,
                                           connsm->phy_data.pref_opts);
-    } else {
+    }
+    else {
         phy_mode = connsm->phy_data.tx_phy_mode;
     }
 
-    max_pyld_len = ble_ll_pdu_max_tx_octets_get(connsm->eff_max_tx_time,
-                                                phy_mode);
+    max_pyld_len =
+        ble_ll_pdu_max_tx_octets_get(connsm->eff_max_tx_time, phy_mode);
 
 #else
-    max_pyld_len = ble_ll_pdu_max_tx_octets_get(connsm->eff_max_tx_time,
-                                                BLE_PHY_MODE_1M);
+    max_pyld_len =
+        ble_ll_pdu_max_tx_octets_get(connsm->eff_max_tx_time, BLE_PHY_MODE_1M);
 #endif
 
     ret = pyld_len;
@@ -1078,7 +1120,7 @@ ble_ll_conn_adjust_pyld_len(struct ble_ll_conn_sm *connsm, uint16_t pyld_len)
 }
 
 static int
-ble_ll_conn_tx_pdu(struct ble_ll_conn_sm *connsm)
+ble_ll_conn_tx_pdu(struct ble_ll_conn_sm* connsm)
 {
     int rc;
     uint8_t md;
@@ -1090,10 +1132,10 @@ ble_ll_conn_tx_pdu(struct ble_ll_conn_sm *connsm)
     uint16_t pktlen;
     uint32_t next_event_time;
     uint32_t ticks;
-    struct os_mbuf *m;
-    struct ble_mbuf_hdr *ble_hdr;
-    struct os_mbuf_pkthdr *pkthdr = NULL;
-    struct os_mbuf_pkthdr *nextpkthdr;
+    struct os_mbuf* m;
+    struct ble_mbuf_hdr* ble_hdr;
+    struct os_mbuf_pkthdr* pkthdr = NULL;
+    struct os_mbuf_pkthdr* nextpkthdr;
     struct ble_ll_empty_pdu empty_pdu;
     ble_phy_tx_end_func txend_func;
     int tx_phy_mode;
@@ -1160,9 +1202,8 @@ ble_ll_conn_tx_pdu(struct ble_ll_conn_sm *connsm)
              * to wait to receive the START_ENC_RSP from the peripheral before
              * packets can be let go.
              */
-            if (nextpkthdr && !ble_ll_ctrl_enc_allowed_pdu_tx(nextpkthdr)
-                && (CONN_IS_CENTRAL(connsm) ||
-                    !ble_ll_ctrl_is_start_enc_rsp(m))) {
+            if (nextpkthdr && !ble_ll_ctrl_enc_allowed_pdu_tx(nextpkthdr) &&
+                (CONN_IS_CENTRAL(connsm) || !ble_ll_ctrl_is_start_enc_rsp(m))) {
                 nextpkthdr = NULL;
             }
         }
@@ -1185,7 +1226,8 @@ ble_ll_conn_tx_pdu(struct ble_ll_conn_sm *connsm)
         if (llid == BLE_LL_LLID_CTRL) {
             cur_txlen = pktlen;
             ble_ll_ctrl_tx_start(connsm, m);
-        } else {
+        }
+        else {
             cur_txlen = ble_ll_conn_adjust_pyld_len(connsm, pktlen);
         }
         ble_hdr->txinfo.pyld_len = cur_txlen;
@@ -1193,7 +1235,8 @@ ble_ll_conn_tx_pdu(struct ble_ll_conn_sm *connsm)
         /* NOTE: header was set when first enqueued */
         hdr_byte = ble_hdr->txinfo.hdr_byte;
         connsm->cur_tx_pdu = m;
-    } else {
+    }
+    else {
         nextpkthdr = pkthdr;
         if (connsm->cur_tx_pdu) {
             m = connsm->cur_tx_pdu;
@@ -1208,14 +1251,15 @@ ble_ll_conn_tx_pdu(struct ble_ll_conn_sm *connsm)
             if (connsm->enc_data.enc_state > CONN_ENC_S_ENCRYPTED) {
                 /* We will allow a next packet if it itself is allowed */
                 pkthdr = OS_MBUF_PKTHDR(connsm->cur_tx_pdu);
-                if (nextpkthdr && !ble_ll_ctrl_enc_allowed_pdu_tx(nextpkthdr)
-                    && (CONN_IS_CENTRAL(connsm) ||
-                        !ble_ll_ctrl_is_start_enc_rsp(connsm->cur_tx_pdu))) {
+                if (nextpkthdr && !ble_ll_ctrl_enc_allowed_pdu_tx(nextpkthdr) &&
+                    (CONN_IS_CENTRAL(connsm) ||
+                     !ble_ll_ctrl_is_start_enc_rsp(connsm->cur_tx_pdu))) {
                     nextpkthdr = NULL;
                 }
             }
 #endif
-        } else {
+        }
+        else {
             /* Empty PDU here. NOTE: header byte gets set later */
             pktlen = 0;
             cur_txlen = 0;
@@ -1255,7 +1299,8 @@ ble_ll_conn_tx_pdu(struct ble_ll_conn_sm *connsm)
          */
         if ((cur_offset + cur_txlen) < pktlen) {
             next_txlen = pktlen - (cur_offset + cur_txlen);
-        } else {
+        }
+        else {
             next_txlen = connsm->eff_max_tx_octets;
         }
         if (next_txlen > connsm->eff_max_tx_octets) {
@@ -1297,8 +1342,8 @@ conn_tx_pdu:
          * This looks strange, but we dont use the data pointer in the mbuf
          * when we have an empty pdu.
          */
-        m = (struct os_mbuf *)&empty_pdu;
-        m->om_data = (uint8_t *)&empty_pdu;
+        m = (struct os_mbuf*)&empty_pdu;
+        m->om_data = (uint8_t*)&empty_pdu;
         m->om_data += BLE_MBUF_MEMBLOCK_OVERHEAD;
         ble_hdr = &empty_pdu.ble_hdr;
         ble_hdr->txinfo.flags = 0;
@@ -1345,7 +1390,8 @@ conn_tx_pdu:
         /* We will end the connection event */
         end_transition = BLE_PHY_TRANSITION_NONE;
         txend_func = ble_ll_conn_wait_txend;
-    } else {
+    }
+    else {
         /* Wait for a response here */
         end_transition = BLE_PHY_TRANSITION_TX_RX;
         txend_func = NULL;
@@ -1356,7 +1402,8 @@ conn_tx_pdu:
     if (llid == BLE_LL_LLID_CTRL) {
         is_ctrl = 1;
         opcode = m->om_data[0];
-    } else {
+    }
+    else {
         is_ctrl = 0;
         opcode = 0;
     }
@@ -1375,7 +1422,8 @@ conn_tx_pdu:
         if (txend_func == NULL) {
             txend_func = ble_ll_conn_continue_rx_encrypt;
         }
-    } else if (is_ctrl && (opcode == BLE_LL_CTRL_START_ENC_REQ)) {
+    }
+    else if (is_ctrl && (opcode == BLE_LL_CTRL_START_ENC_REQ)) {
         /*
          * Only the peripheral sends this and it gets sent unencrypted but
          * we receive encrypted
@@ -1386,10 +1434,30 @@ conn_tx_pdu:
         ble_phy_encrypt_disable();
         if (txend_func == NULL) {
             txend_func = ble_ll_conn_start_rx_encrypt;
-        } else {
+        }
+        else {
             txend_func = ble_ll_conn_txend_encrypt;
         }
-    } else if (is_ctrl && (opcode == BLE_LL_CTRL_PAUSE_ENC_RSP)) {
+    }
+    else if (is_ctrl && (opcode == BLE_LL_CTRL_REKEY_REQ)) {
+        // this should be done only by central btw
+        // Central must send with the new session key
+        if (connsm->flags.encrypted) {
+            if (txend_func == NULL) {
+                txend_func = ble_ll_conn_key_refresh;
+            }
+        }
+    }
+    else if (is_ctrl && (opcode == BLE_LL_CTRL_ENC_F_REQ)) {
+        connsm->enc_data.rx_pkt_cntr = 0;
+        connsm->enc_data.tx_pkt_cntr = 0;
+        /* After sending F ENC REQ if we are not encrypted, we start it*/
+        if (!connsm->flags.encrypted) {
+            txend_func = ble_ll_conn_start_rx_encrypt;
+        }
+        // else TODO
+    }
+    else if (is_ctrl && (opcode == BLE_LL_CTRL_PAUSE_ENC_RSP)) {
         /*
          * The peripheral sends the PAUSE_ENC_RSP encrypted. The central sends
          * it unencrypted (note that link was already set unencrypted).
@@ -1413,7 +1481,8 @@ conn_tx_pdu:
                                         CONN_IS_CENTRAL(connsm));
             if (txend_func == NULL) {
                 txend_func = ble_ll_conn_start_rx_unencrypt;
-            } else {
+            }
+            else {
                 txend_func = ble_ll_conn_rxend_unencrypt;
             }
             break;
@@ -1422,7 +1491,8 @@ conn_tx_pdu:
             BLE_LL_ASSERT(0);
             break;
         }
-    } else {
+    }
+    else {
         /* If encrypted set packet counter */
         if (connsm->flags.encrypted) {
             connsm->enc_data.tx_encrypted = 1;
@@ -1453,13 +1523,15 @@ conn_tx_pdu:
                 connsm->flags.terminate_ind_rxd_acked = 1;
             }
             STATS_INC(ble_ll_conn_stats, tx_empty_pdus);
-        } else if ((hdr_byte & BLE_LL_DATA_HDR_LLID_MASK) == BLE_LL_LLID_CTRL) {
+        }
+        else if ((hdr_byte & BLE_LL_DATA_HDR_LLID_MASK) == BLE_LL_LLID_CTRL) {
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_ENHANCED_CONN_UPDATE)
             connsm->has_nonempty_pdu = 1;
 #endif
             STATS_INC(ble_ll_conn_stats, tx_ctrl_pdus);
             STATS_INCN(ble_ll_conn_stats, tx_ctrl_bytes, cur_txlen);
-        } else {
+        }
+        else {
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_ENHANCED_CONN_UPDATE)
             connsm->has_nonempty_pdu = 1;
 #endif
@@ -1480,19 +1552,19 @@ conn_tx_pdu:
  * @return int 0: scheduled item is still running. 1: schedule item is done.
  */
 static int
-ble_ll_conn_event_start_cb(struct ble_ll_sched_item *sch)
+ble_ll_conn_event_start_cb(struct ble_ll_sched_item* sch)
 {
     int rc = 0;
 #if MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL)
     uint32_t usecs;
 #endif
     uint32_t start;
-    struct ble_ll_conn_sm *connsm;
+    struct ble_ll_conn_sm* connsm;
 
     /* XXX: note that we can extend end time here if we want. Look at this */
 
     /* Set current connection state machine */
-    connsm = (struct ble_ll_conn_sm *)sch->cb_arg;
+    connsm = (struct ble_ll_conn_sm*)sch->cb_arg;
     g_ble_ll_conn_cur_sm = connsm;
     BLE_LL_ASSERT(connsm);
 
@@ -1523,7 +1595,8 @@ ble_ll_conn_event_start_cb(struct ble_ll_sched_item *sch)
 #endif
 
 #if MYNEWT_VAL(BLE_LL_PHY)
-    ble_phy_mode_set(connsm->phy_data.tx_phy_mode, connsm->phy_data.rx_phy_mode);
+    ble_phy_mode_set(connsm->phy_data.tx_phy_mode,
+                     connsm->phy_data.rx_phy_mode);
 #endif
 
     /* Set the power */
@@ -1541,18 +1614,21 @@ ble_ll_conn_event_start_cb(struct ble_ll_sched_item *sch)
                 ble_phy_encrypt_enable(connsm->enc_data.enc_block.cipher_text);
                 ble_phy_encrypt_iv_set(connsm->enc_data.iv);
                 ble_phy_encrypt_counter_set(connsm->enc_data.tx_pkt_cntr, 1);
-            } else {
+            }
+            else {
                 ble_phy_encrypt_disable();
             }
 #endif
             rc = ble_ll_conn_tx_pdu(connsm);
             if (!rc) {
                 rc = BLE_LL_SCHED_STATE_RUNNING;
-            } else {
+            }
+            else {
                 /* Inform LL task of connection event end */
                 rc = BLE_LL_SCHED_STATE_DONE;
             }
-        } else {
+        }
+        else {
             STATS_INC(ble_ll_conn_stats, conn_ev_late);
             rc = BLE_LL_SCHED_STATE_DONE;
         }
@@ -1565,7 +1641,8 @@ ble_ll_conn_event_start_cb(struct ble_ll_sched_item *sch)
             ble_phy_encrypt_enable(connsm->enc_data.enc_block.cipher_text);
             ble_phy_encrypt_iv_set(connsm->enc_data.iv);
             ble_phy_encrypt_counter_set(connsm->enc_data.rx_pkt_cntr, 1);
-        } else {
+        }
+        else {
             ble_phy_encrypt_disable();
         }
 #endif
@@ -1577,7 +1654,8 @@ ble_ll_conn_event_start_cb(struct ble_ll_sched_item *sch)
             /* End the connection event as we have no more buffers */
             STATS_INC(ble_ll_conn_stats, periph_ce_failures);
             rc = BLE_LL_SCHED_STATE_DONE;
-        } else {
+        }
+        else {
             /*
              * Set flag that tells peripheral to set last anchor point if a packet
              * has been received.
@@ -1644,7 +1722,7 @@ ble_ll_conn_event_start_cb(struct ble_ll_sched_item *sch)
  * @return int 0: not allowed to send 1: allowed to send
  */
 static int
-ble_ll_conn_can_send_next_pdu(struct ble_ll_conn_sm *connsm, uint32_t begtime,
+ble_ll_conn_can_send_next_pdu(struct ble_ll_conn_sm* connsm, uint32_t begtime,
                               uint32_t add_usecs)
 {
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
@@ -1653,9 +1731,9 @@ ble_ll_conn_can_send_next_pdu(struct ble_ll_conn_sm *connsm, uint32_t begtime,
     uint32_t ticks;
     uint32_t usecs;
     uint32_t next_sched_time;
-    struct os_mbuf *txpdu;
-    struct os_mbuf_pkthdr *pkthdr;
-    struct ble_mbuf_hdr *txhdr;
+    struct os_mbuf* txpdu;
+    struct os_mbuf_pkthdr* pkthdr;
+    struct ble_mbuf_hdr* txhdr;
     uint32_t allowed_usecs;
     int tx_phy_mode;
 
@@ -1676,7 +1754,8 @@ ble_ll_conn_can_send_next_pdu(struct ble_ll_conn_sm *connsm, uint32_t begtime,
             if (pkthdr) {
                 txpdu = OS_MBUF_PKTHDR_TO_MBUF(pkthdr);
             }
-        } else {
+        }
+        else {
             pkthdr = OS_MBUF_PKTHDR(txpdu);
         }
 
@@ -1689,7 +1768,8 @@ ble_ll_conn_can_send_next_pdu(struct ble_ll_conn_sm *connsm, uint32_t begtime,
                 rem_bytes = connsm->eff_max_tx_octets;
             }
             usecs = ble_ll_pdu_us(rem_bytes, tx_phy_mode);
-        } else {
+        }
+        else {
             /* We will send empty pdu (just a LL header) */
             usecs = ble_ll_pdu_us(0, tx_phy_mode);
         }
@@ -1720,11 +1800,11 @@ ble_ll_conn_can_send_next_pdu(struct ble_ll_conn_sm *connsm, uint32_t begtime,
  * @param arg
  */
 void
-ble_ll_conn_auth_pyld_timer_cb(struct ble_npl_event *ev)
+ble_ll_conn_auth_pyld_timer_cb(struct ble_npl_event* ev)
 {
-    struct ble_ll_conn_sm *connsm;
+    struct ble_ll_conn_sm* connsm;
 
-    connsm = (struct ble_ll_conn_sm *)ble_npl_event_get_arg(ev);
+    connsm = (struct ble_ll_conn_sm*)ble_npl_event_get_arg(ev);
     ble_ll_auth_pyld_tmo_event_send(connsm);
     ble_ll_ctrl_proc_start(connsm, BLE_LL_CTRL_PROC_LE_PING, NULL);
     ble_ll_conn_auth_pyld_timer_start(connsm);
@@ -1736,7 +1816,7 @@ ble_ll_conn_auth_pyld_timer_cb(struct ble_npl_event *ev)
  * @param connsm
  */
 void
-ble_ll_conn_auth_pyld_timer_start(struct ble_ll_conn_sm *connsm)
+ble_ll_conn_auth_pyld_timer_start(struct ble_ll_conn_sm* connsm)
 {
     int32_t tmo;
 
@@ -1748,7 +1828,7 @@ ble_ll_conn_auth_pyld_timer_start(struct ble_ll_conn_sm *connsm)
 
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
 static void
-ble_ll_conn_central_common_init(struct ble_ll_conn_sm *connsm)
+ble_ll_conn_central_common_init(struct ble_ll_conn_sm* connsm)
 {
 
     /* Set central role */
@@ -1796,9 +1876,9 @@ ble_ll_conn_central_common_init(struct ble_ll_conn_sm *connsm)
  * @param hcc
  */
 void
-ble_ll_conn_central_init(struct ble_ll_conn_sm *connsm,
-                         struct ble_ll_conn_create_scan *cc_scan,
-                         struct ble_ll_conn_create_params *cc_params)
+ble_ll_conn_central_init(struct ble_ll_conn_sm* connsm,
+                         struct ble_ll_conn_create_scan* cc_scan,
+                         struct ble_ll_conn_create_params* cc_params)
 {
 
     ble_ll_conn_central_common_init(connsm);
@@ -1812,15 +1892,15 @@ ble_ll_conn_central_init(struct ble_ll_conn_sm *connsm,
     connsm->conn_itvl_usecs = cc_params->conn_itvl_usecs;
     connsm->periph_latency = cc_params->conn_latency;
     connsm->supervision_tmo = cc_params->supervision_timeout;
-    connsm->max_ce_len_ticks = ble_ll_tmr_u2t_up(cc_params->max_ce_len * BLE_LL_CONN_CE_USECS);
+    connsm->max_ce_len_ticks =
+        ble_ll_tmr_u2t_up(cc_params->max_ce_len * BLE_LL_CONN_CE_USECS);
 }
 #endif
 
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_DATA_LEN_EXT)
 int
-ble_ll_conn_set_data_len(struct ble_ll_conn_sm *connsm,
-                         uint16_t tx_octets, uint16_t tx_time,
-                         uint16_t rx_octets, uint16_t rx_time)
+ble_ll_conn_set_data_len(struct ble_ll_conn_sm* connsm, uint16_t tx_octets,
+                         uint16_t tx_time, uint16_t rx_octets, uint16_t rx_time)
 {
     int init_dle = 0;
 
@@ -1871,25 +1951,24 @@ ble_ll_conn_set_data_len(struct ble_ll_conn_sm *connsm,
 #if MYNEWT_VAL(BLE_LL_PHY)
 
 static void
-ble_ll_conn_set_phy(struct ble_ll_conn_sm *connsm, int tx_phy, int rx_phy)
+ble_ll_conn_set_phy(struct ble_ll_conn_sm* connsm, int tx_phy, int rx_phy)
 {
 
-    struct ble_ll_conn_phy_data *phy_data = &connsm->phy_data;
+    struct ble_ll_conn_phy_data* phy_data = &connsm->phy_data;
 
-    phy_data->rx_phy_mode = ble_ll_phy_to_phy_mode(rx_phy,
-                                                   BLE_HCI_LE_PHY_CODED_ANY);
+    phy_data->rx_phy_mode =
+        ble_ll_phy_to_phy_mode(rx_phy, BLE_HCI_LE_PHY_CODED_ANY);
     phy_data->cur_rx_phy = rx_phy;
 
-    phy_data->tx_phy_mode = ble_ll_phy_to_phy_mode(tx_phy,
-                                                   BLE_HCI_LE_PHY_CODED_ANY);
+    phy_data->tx_phy_mode =
+        ble_ll_phy_to_phy_mode(tx_phy, BLE_HCI_LE_PHY_CODED_ANY);
     phy_data->cur_tx_phy = tx_phy;
-
 }
 
 static void
-ble_ll_conn_init_phy(struct ble_ll_conn_sm *connsm, int phy)
+ble_ll_conn_init_phy(struct ble_ll_conn_sm* connsm, int phy)
 {
-    struct ble_ll_conn_global_params *conngp;
+    struct ble_ll_conn_global_params* conngp;
 
     /* Always initialize symmetric PHY - controller can change this later */
     ble_ll_conn_set_phy(connsm, phy, phy);
@@ -1905,7 +1984,8 @@ ble_ll_conn_init_phy(struct ble_ll_conn_sm *connsm, int phy)
         connsm->rem_max_rx_time = BLE_LL_CONN_SUPP_TIME_MIN_CODED;
         /* Assume peer does support coded */
         ble_ll_conn_rem_feature_add(connsm, BLE_LL_FEAT_LE_CODED_PHY);
-    } else {
+    }
+    else {
         connsm->max_tx_time = conngp->conn_init_max_tx_time_uncoded;
         connsm->max_rx_time = BLE_LL_CONN_SUPP_TIME_MAX_UNCODED;
         connsm->rem_max_tx_time = BLE_LL_CONN_SUPP_TIME_MIN_UNCODED;
@@ -1924,9 +2004,9 @@ ble_ll_conn_init_phy(struct ble_ll_conn_sm *connsm, int phy)
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_EXT_ADV)
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
 static void
-ble_ll_conn_create_set_params(struct ble_ll_conn_sm *connsm, uint8_t phy)
+ble_ll_conn_create_set_params(struct ble_ll_conn_sm* connsm, uint8_t phy)
 {
-    struct ble_ll_conn_create_params *cc_params;
+    struct ble_ll_conn_create_params* cc_params;
 
     cc_params = &g_ble_ll_conn_create_sm.params[phy - 1];
 
@@ -1941,13 +2021,13 @@ ble_ll_conn_create_set_params(struct ble_ll_conn_sm *connsm, uint8_t phy)
 #endif
 
 static void
-ble_ll_conn_set_csa(struct ble_ll_conn_sm *connsm, bool chsel)
+ble_ll_conn_set_csa(struct ble_ll_conn_sm* connsm, bool chsel)
 {
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LE_CSA2)
     if (chsel) {
         connsm->flags.csa2 = 1;
         connsm->channel_id = ((connsm->access_addr & 0xffff0000) >> 16) ^
-                              (connsm->access_addr & 0x0000ffff);
+                             (connsm->access_addr & 0x0000ffff);
 
         /* calculate the next data channel */
         connsm->data_chan_index = ble_ll_conn_calc_dci(connsm, 0);
@@ -1971,9 +2051,9 @@ ble_ll_conn_set_csa(struct ble_ll_conn_sm *connsm, bool chsel)
  * @param connsm
  */
 void
-ble_ll_conn_sm_new(struct ble_ll_conn_sm *connsm)
+ble_ll_conn_sm_new(struct ble_ll_conn_sm* connsm)
 {
-    struct ble_ll_conn_global_params *conn_params;
+    struct ble_ll_conn_global_params* conn_params;
 
     /* Reset following elements */
     memset(&connsm->flags, 0, sizeof(connsm->flags));
@@ -1999,7 +2079,8 @@ ble_ll_conn_sm_new(struct ble_ll_conn_sm *connsm)
 #endif
 
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_PERIODIC_ADV_SYNC_TRANSFER)
-    connsm->sync_transfer_sync_timeout = g_ble_ll_conn_sync_transfer_params.sync_timeout_us;
+    connsm->sync_transfer_sync_timeout =
+        g_ble_ll_conn_sync_transfer_params.sync_timeout_us;
     connsm->sync_transfer_mode = g_ble_ll_conn_sync_transfer_params.mode;
     connsm->sync_transfer_skip = g_ble_ll_conn_sync_transfer_params.max_skip;
 #endif
@@ -2084,7 +2165,7 @@ ble_ll_conn_sm_new(struct ble_ll_conn_sm *connsm)
 }
 
 void
-ble_ll_conn_update_eff_data_len(struct ble_ll_conn_sm *connsm)
+ble_ll_conn_update_eff_data_len(struct ble_ll_conn_sm* connsm)
 {
     int ota_max_rx_time_calc = 0;
     int send_event;
@@ -2160,10 +2241,10 @@ ble_ll_conn_update_eff_data_len(struct ble_ll_conn_sm *connsm)
  * @param ble_err
  */
 void
-ble_ll_conn_end(struct ble_ll_conn_sm *connsm, uint8_t ble_err)
+ble_ll_conn_end(struct ble_ll_conn_sm* connsm, uint8_t ble_err)
 {
-    struct os_mbuf *m;
-    struct os_mbuf_pkthdr *pkthdr;
+    struct os_mbuf* m;
+    struct os_mbuf_pkthdr* pkthdr;
     os_sr_t sr;
 
     /* Remove scheduler events just in case */
@@ -2225,7 +2306,7 @@ ble_ll_conn_end(struct ble_ll_conn_sm *connsm, uint8_t ble_err)
         }
         STAILQ_REMOVE_HEAD(&connsm->conn_txq, omp_next);
 
-        m = (struct os_mbuf *)((uint8_t *)pkthdr - sizeof(struct os_mbuf));
+        m = (struct os_mbuf*)((uint8_t*)pkthdr - sizeof(struct os_mbuf));
         os_mbuf_free_chain(m);
     }
 
@@ -2239,8 +2320,7 @@ ble_ll_conn_end(struct ble_ll_conn_sm *connsm, uint8_t ble_err)
      * If we have features and there's pending HCI command, send an event before
      * disconnection event so it does make sense to host.
      */
-    if (connsm->flags.features_host_req &&
-        connsm->flags.features_rxd) {
+    if (connsm->flags.features_host_req && connsm->flags.features_rxd) {
         ble_ll_hci_ev_rd_rem_used_feat(connsm, BLE_ERR_SUCCESS);
         connsm->flags.features_host_req = 0;
     }
@@ -2262,8 +2342,8 @@ ble_ll_conn_end(struct ble_ll_conn_sm *connsm, uint8_t ble_err)
      * If the ble error is "success" it means that the reset command was
      * received and we should not send an event.
      */
-    if (ble_err && (ble_err != BLE_ERR_UNK_CONN_ID ||
-                    connsm->flags.terminate_ind_rxd)) {
+    if (ble_err &&
+        (ble_err != BLE_ERR_UNK_CONN_ID || connsm->flags.terminate_ind_rxd)) {
         ble_ll_disconn_comp_event_send(connsm, ble_err);
     }
 
@@ -2276,8 +2356,8 @@ ble_ll_conn_end(struct ble_ll_conn_sm *connsm, uint8_t ble_err)
 }
 
 void
-ble_ll_conn_anchor_get(struct ble_ll_conn_sm *connsm, uint16_t *event_cntr,
-                       uint32_t *anchor, uint8_t *anchor_usecs)
+ble_ll_conn_anchor_get(struct ble_ll_conn_sm* connsm, uint16_t* event_cntr,
+                       uint32_t* anchor, uint8_t* anchor_usecs)
 {
     *event_cntr = connsm->event_cntr;
     *anchor = connsm->anchor_point;
@@ -2286,9 +2366,9 @@ ble_ll_conn_anchor_get(struct ble_ll_conn_sm *connsm, uint16_t *event_cntr,
 
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_PERIODIC_ADV_SYNC_TRANSFER)
 void
-ble_ll_conn_anchor_event_cntr_get(struct ble_ll_conn_sm *connsm,
-                                  uint16_t event_cntr, uint32_t *anchor,
-                                  uint8_t *anchor_usecs)
+ble_ll_conn_anchor_event_cntr_get(struct ble_ll_conn_sm* connsm,
+                                  uint16_t event_cntr, uint32_t* anchor,
+                                  uint8_t* anchor_usecs)
 {
     uint32_t itvl;
 
@@ -2300,7 +2380,8 @@ ble_ll_conn_anchor_event_cntr_get(struct ble_ll_conn_sm *connsm,
     if ((int16_t)(event_cntr - connsm->event_cntr) < 0) {
         itvl *= connsm->event_cntr - event_cntr;
         ble_ll_tmr_sub(anchor, anchor_usecs, itvl);
-    } else {
+    }
+    else {
         itvl *= event_cntr - connsm->event_cntr;
         ble_ll_tmr_add(anchor, anchor_usecs, itvl);
     }
@@ -2309,7 +2390,7 @@ ble_ll_conn_anchor_event_cntr_get(struct ble_ll_conn_sm *connsm,
 
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
 int
-ble_ll_conn_move_anchor(struct ble_ll_conn_sm *connsm, uint16_t offset)
+ble_ll_conn_move_anchor(struct ble_ll_conn_sm* connsm, uint16_t offset)
 {
     BLE_LL_ASSERT(connsm->conn_role == BLE_LL_CONN_ROLE_CENTRAL);
 
@@ -2335,7 +2416,7 @@ ble_ll_conn_move_anchor(struct ble_ll_conn_sm *connsm, uint16_t offset)
  * @return int
  */
 static int
-ble_ll_conn_next_event(struct ble_ll_conn_sm *connsm)
+ble_ll_conn_next_event(struct ble_ll_conn_sm* connsm)
 {
     uint32_t conn_itvl_us;
     uint32_t ce_duration;
@@ -2343,7 +2424,7 @@ ble_ll_conn_next_event(struct ble_ll_conn_sm *connsm)
     uint32_t cur_ww;
     uint32_t max_ww;
 #endif
-    struct ble_ll_conn_upd_req *upd;
+    struct ble_ll_conn_upd_req* upd;
     uint8_t skip_anchor_calc = 0;
     uint32_t usecs;
     uint8_t use_periph_latency;
@@ -2353,7 +2434,7 @@ ble_ll_conn_next_event(struct ble_ll_conn_sm *connsm)
     uint16_t subrate_factor;
     uint16_t event_cntr_diff;
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_ENHANCED_CONN_UPDATE)
-    struct ble_ll_conn_subrate_params *cstp;
+    struct ble_ll_conn_subrate_params* cstp;
     uint16_t trans_next_event_cntr;
     uint16_t subrate_conn_upd_event_cntr;
 #endif
@@ -2395,7 +2476,8 @@ ble_ll_conn_next_event(struct ble_ll_conn_sm *connsm)
     if (connsm->has_nonempty_pdu) {
         connsm->cont_num_left = connsm->cont_num;
         connsm->has_nonempty_pdu = 0;
-    } else if (connsm->event_cntr == connsm->subrate_base_event) {
+    }
+    else if (connsm->event_cntr == connsm->subrate_base_event) {
         connsm->cont_num_left = 0;
     }
 
@@ -2422,12 +2504,10 @@ ble_ll_conn_next_event(struct ble_ll_conn_sm *connsm)
      */
     /* Set event counter to the next connection event that we will tx/rx in */
 
-    use_periph_latency = next_is_subrated &&
-                         connsm->flags.periph_use_latency &&
-                         !connsm->flags.conn_update_sched &&
-                         !connsm->flags.phy_update_sched &&
-                         !connsm->flags.chanmap_update_sched &&
-                         connsm->flags.pkt_rxd;
+    use_periph_latency =
+        next_is_subrated && connsm->flags.periph_use_latency &&
+        !connsm->flags.conn_update_sched && !connsm->flags.phy_update_sched &&
+        !connsm->flags.chanmap_update_sched && connsm->flags.pkt_rxd;
 
     if (next_is_subrated) {
         next_event_cntr = base_event_cntr + subrate_factor;
@@ -2455,17 +2535,16 @@ ble_ll_conn_next_event(struct ble_ll_conn_sm *connsm)
             }
         }
 #endif
-    } else {
+    }
+    else {
         next_event_cntr = connsm->event_cntr + 1;
     }
 
-
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_ENHANCED_CONN_UPDATE)
     /* If connection update is scheduled, peripheral shall listen at instant
      * and one connection event before instant regardless of subrating.
      */
-    if (CONN_IS_PERIPHERAL(connsm) &&
-        connsm->flags.conn_update_sched &&
+    if (CONN_IS_PERIPHERAL(connsm) && connsm->flags.conn_update_sched &&
         (connsm->subrate_factor > 1)) {
         subrate_conn_upd_event_cntr = connsm->conn_update_req.instant - 1;
         if (connsm->event_cntr == subrate_conn_upd_event_cntr) {
@@ -2485,8 +2564,8 @@ ble_ll_conn_next_event(struct ble_ll_conn_sm *connsm)
      * valid value.
      */
     if (next_is_subrated ||
-        (connsm->subrate_base_event +
-         connsm->subrate_factor == next_event_cntr)) {
+        (connsm->subrate_base_event + connsm->subrate_factor ==
+         next_event_cntr)) {
         connsm->subrate_base_event = next_event_cntr;
     }
 #endif
@@ -2520,7 +2599,8 @@ ble_ll_conn_next_event(struct ble_ll_conn_sm *connsm)
             connsm->anchor_point += connsm->conn_itvl_ticks;
             ble_ll_tmr_add_u(&connsm->anchor_point, &connsm->anchor_point_usecs,
                              connsm->conn_itvl_usecs);
-        } else {
+        }
+        else {
             conn_itvl_us = connsm->conn_itvl * BLE_LL_CONN_ITVL_USECS;
 
             ble_ll_tmr_add(&connsm->anchor_point, &connsm->anchor_point_usecs,
@@ -2598,7 +2678,8 @@ ble_ll_conn_next_event(struct ble_ll_conn_sm *connsm)
                                   &connsm->conn_itvl_usecs);
 
         if (connsm->conn_param_req.handle != 0) {
-            connsm->max_ce_len_ticks = ble_ll_tmr_u2t_up(connsm->conn_param_req.max_ce_len * BLE_LL_CONN_CE_USECS);
+            connsm->max_ce_len_ticks = ble_ll_tmr_u2t_up(
+                connsm->conn_param_req.max_ce_len * BLE_LL_CONN_CE_USECS);
             connsm->conn_param_req.handle = 0;
         }
 
@@ -2656,16 +2737,14 @@ ble_ll_conn_next_event(struct ble_ll_conn_sm *connsm)
         /* Set cur phy to new phy */
         if (connsm->phy_data.new_tx_phy) {
             connsm->phy_data.cur_tx_phy = connsm->phy_data.new_tx_phy;
-            connsm->phy_data.tx_phy_mode =
-                                ble_ll_phy_to_phy_mode(connsm->phy_data.cur_tx_phy,
-                                                   connsm->phy_data.pref_opts);
+            connsm->phy_data.tx_phy_mode = ble_ll_phy_to_phy_mode(
+                connsm->phy_data.cur_tx_phy, connsm->phy_data.pref_opts);
         }
 
         if (connsm->phy_data.new_rx_phy) {
             connsm->phy_data.cur_rx_phy = connsm->phy_data.new_rx_phy;
-            connsm->phy_data.rx_phy_mode =
-                                ble_ll_phy_to_phy_mode(connsm->phy_data.cur_rx_phy,
-                                                   connsm->phy_data.pref_opts);
+            connsm->phy_data.rx_phy_mode = ble_ll_phy_to_phy_mode(
+                connsm->phy_data.cur_rx_phy, connsm->phy_data.pref_opts);
         }
 
         /* Clear flags and set flag to send event at next instant */
@@ -2720,13 +2799,14 @@ ble_ll_conn_next_event(struct ble_ll_conn_sm *connsm)
     if (ble_ll_sched_css_is_enabled() &&
         connsm->conn_role == BLE_LL_CONN_ROLE_CENTRAL) {
         ce_duration = ble_ll_tmr_u2t(ble_ll_sched_css_get_slot_us());
-    } else {
+    }
+    else {
         ce_duration = ble_ll_tmr_u2t(MYNEWT_VAL(BLE_LL_CONN_INIT_SLOTS) *
                                      BLE_LL_SCHED_USECS_PER_SLOT);
     }
 #else
     ce_duration = ble_ll_tmr_u2t(MYNEWT_VAL(BLE_LL_CONN_INIT_SLOTS) *
-                                     BLE_LL_SCHED_USECS_PER_SLOT);
+                                 BLE_LL_SCHED_USECS_PER_SLOT);
 #endif
 
 #if MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL)
@@ -2735,14 +2815,14 @@ ble_ll_conn_next_event(struct ble_ll_conn_sm *connsm)
         cur_ww = ble_ll_utils_calc_window_widening(connsm->anchor_point,
                                                    connsm->last_anchor_point,
                                                    connsm->central_sca);
-        max_ww = (connsm->conn_itvl * (BLE_LL_CONN_ITVL_USECS/2)) - BLE_LL_IFS;
+        max_ww =
+            (connsm->conn_itvl * (BLE_LL_CONN_ITVL_USECS / 2)) - BLE_LL_IFS;
         if (cur_ww >= max_ww) {
             return -1;
         }
         cur_ww += BLE_LL_JITTER_USECS;
         connsm->periph_cur_window_widening = cur_ww;
-        ce_duration += ble_ll_tmr_u2t(cur_ww +
-                                      connsm->periph_cur_tx_win_usecs);
+        ce_duration += ble_ll_tmr_u2t(cur_ww + connsm->periph_cur_tx_win_usecs);
     }
 #endif
     ce_duration -= g_ble_ll_sched_offset_ticks;
@@ -2767,11 +2847,11 @@ ble_ll_conn_next_event(struct ble_ll_conn_sm *connsm)
  * @ return 0: connection NOT created. 1: connection created
  */
 static int
-ble_ll_conn_created(struct ble_ll_conn_sm *connsm, struct ble_mbuf_hdr *rxhdr)
+ble_ll_conn_created(struct ble_ll_conn_sm* connsm, struct ble_mbuf_hdr* rxhdr)
 {
     int rc;
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
-    uint8_t *evbuf;
+    uint8_t* evbuf;
 #endif
 #if MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL)
     uint32_t usecs;
@@ -2812,8 +2892,7 @@ ble_ll_conn_created(struct ble_ll_conn_sm *connsm, struct ble_mbuf_hdr *rxhdr)
 
         usecs = rxhdr->rem_usecs + 1250 +
                 (connsm->tx_win_off * BLE_LL_CONN_TX_WIN_USECS) +
-                ble_ll_pdu_us(BLE_CONNECT_REQ_LEN,
-                                       rxhdr->rxinfo.phy_mode);
+                ble_ll_pdu_us(BLE_CONNECT_REQ_LEN, rxhdr->rxinfo.phy_mode);
 
         if (rxhdr->rxinfo.channel < BLE_PHY_NUM_DATA_CHANS) {
             switch (rxhdr->rxinfo.phy) {
@@ -2838,10 +2917,12 @@ ble_ll_conn_created(struct ble_ll_conn_sm *connsm, struct ble_mbuf_hdr *rxhdr)
 
         connsm->periph_cur_tx_win_usecs =
             connsm->tx_win_size * BLE_LL_CONN_TX_WIN_USECS;
-        connsm->ce_end_time = connsm->anchor_point +
-                              ble_ll_tmr_u2t(MYNEWT_VAL(BLE_LL_CONN_INIT_SLOTS) *
-                                             BLE_LL_SCHED_USECS_PER_SLOT +
-                                             connsm->periph_cur_tx_win_usecs) + 1;
+        connsm->ce_end_time =
+            connsm->anchor_point +
+            ble_ll_tmr_u2t(MYNEWT_VAL(BLE_LL_CONN_INIT_SLOTS) *
+                               BLE_LL_SCHED_USECS_PER_SLOT +
+                           connsm->periph_cur_tx_win_usecs) +
+            1;
 
         /* Start the scheduler for the first connection event */
         while (ble_ll_sched_conn_periph_new(connsm)) {
@@ -2893,8 +2974,7 @@ ble_ll_conn_created(struct ble_ll_conn_sm *connsm, struct ble_mbuf_hdr *rxhdr)
              * models; for peripheral just assume central will initiate features xchg
              * if it has some additional features to use.
              */
-            ble_ll_ctrl_proc_start(connsm, BLE_LL_CTRL_PROC_FEATURE_XCHG,
-                                   NULL);
+            ble_ll_ctrl_proc_start(connsm, BLE_LL_CTRL_PROC_FEATURE_XCHG, NULL);
             break;
 #endif
 #if MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL)
@@ -2920,16 +3000,16 @@ ble_ll_conn_created(struct ble_ll_conn_sm *connsm, struct ble_mbuf_hdr *rxhdr)
  *
  */
 static void
-ble_ll_conn_event_end(struct ble_npl_event *ev)
+ble_ll_conn_event_end(struct ble_npl_event* ev)
 {
     uint8_t ble_err;
     uint32_t tmo;
-    struct ble_ll_conn_sm *connsm;
+    struct ble_ll_conn_sm* connsm;
 
     ble_ll_rfmgmt_release();
 
     /* Better be a connection state machine! */
-    connsm = (struct ble_ll_conn_sm *)ble_npl_event_get_arg(ev);
+    connsm = (struct ble_ll_conn_sm*)ble_npl_event_get_arg(ev);
     BLE_LL_ASSERT(connsm);
 
     /* Log event end */
@@ -2944,7 +3024,8 @@ ble_ll_conn_event_end(struct ble_npl_event *ev)
          connsm->flags.terminate_ind_rxd_acked)) {
         if (connsm->flags.terminate_ind_txd) {
             ble_err = BLE_ERR_CONN_TERM_LOCAL;
-        } else {
+        }
+        else {
             /* Make sure the disconnect reason is valid! */
             ble_err = connsm->rxd_disconnect_reason;
             if (ble_err == 0) {
@@ -3025,7 +3106,8 @@ ble_ll_conn_event_end(struct ble_npl_event *ev)
     if (connsm->conn_state == BLE_LL_CONN_STATE_CREATED) {
         tmo = (uint32_t)connsm->conn_itvl * BLE_LL_CONN_ITVL_USECS * 6UL;
         ble_err = BLE_ERR_CONN_ESTABLISHMENT;
-    } else {
+    }
+    else {
         tmo = connsm->supervision_tmo * BLE_HCI_CONN_SPVN_TMO_UNITS * 1000UL;
         ble_err = BLE_ERR_CONN_SPVN_TMO;
     }
@@ -3040,8 +3122,7 @@ ble_ll_conn_event_end(struct ble_npl_event *ev)
     ble_ll_conn_num_comp_pkts_event_send(connsm);
 
     /* If we have features and there's pending HCI command, send an event */
-    if (connsm->flags.features_host_req &&
-        connsm->flags.features_rxd) {
+    if (connsm->flags.features_host_req && connsm->flags.features_rxd) {
         ble_ll_hci_ev_rd_rem_used_feat(connsm, BLE_ERR_SUCCESS);
         connsm->flags.features_host_req = 0;
     }
@@ -3060,15 +3141,15 @@ ble_ll_conn_event_end(struct ble_npl_event *ev)
  * @param txoffset      The tx window offset for this connection
  */
 void
-ble_ll_conn_prepare_connect_ind(struct ble_ll_conn_sm *connsm,
-                                struct ble_ll_scan_pdu_data *pdu_data,
-                                struct ble_ll_scan_addr_data *addrd,
+ble_ll_conn_prepare_connect_ind(struct ble_ll_conn_sm* connsm,
+                                struct ble_ll_scan_pdu_data* pdu_data,
+                                struct ble_ll_scan_addr_data* addrd,
                                 uint8_t channel)
 {
     uint8_t hdr;
-    uint8_t *addr;
+    uint8_t* addr;
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_PRIVACY)
-    struct ble_ll_resolv_entry *rl;
+    struct ble_ll_resolv_entry* rl;
 #endif
 
     hdr = BLE_ADV_PDU_TYPE_CONNECT_IND;
@@ -3096,16 +3177,19 @@ ble_ll_conn_prepare_connect_ind(struct ble_ll_conn_sm *connsm,
                 rl = &g_ble_ll_resolv_list[addrd->rpa_index];
                 hdr |= BLE_ADV_PDU_HDR_TXADD_RAND;
                 ble_ll_resolv_get_priv_addr(rl, 1, pdu_data->inita);
-            } else {
+            }
+            else {
                 /* Host does not want us to use RPA so use identity */
                 if ((connsm->own_addr_type & 1) == 0) {
                     memcpy(pdu_data->inita, g_dev_addr, BLE_DEV_ADDR_LEN);
-                } else {
+                }
+                else {
                     hdr |= BLE_ADV_PDU_HDR_TXADD_RAND;
                     memcpy(pdu_data->inita, g_random_addr, BLE_DEV_ADDR_LEN);
                 }
             }
-        } else {
+        }
+        else {
             memcpy(pdu_data->inita, addrd->targeta, BLE_DEV_ADDR_LEN);
             if (addrd->targeta_type) {
                 hdr |= BLE_ADV_PDU_HDR_TXADD_RAND;
@@ -3117,16 +3201,18 @@ ble_ll_conn_prepare_connect_ind(struct ble_ll_conn_sm *connsm,
             hdr |= BLE_ADV_PDU_HDR_TXADD_RAND;
         }
 #endif
-    } else {
+    }
+    else {
         /* Get pointer to our device address */
         if ((connsm->own_addr_type & 1) == 0) {
             addr = g_dev_addr;
-        } else {
+        }
+        else {
             hdr |= BLE_ADV_PDU_HDR_TXADD_RAND;
             addr = g_random_addr;
         }
 
-    /* XXX: do this ahead of time? Calculate the local rpa I mean */
+        /* XXX: do this ahead of time? Calculate the local rpa I mean */
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_PRIVACY)
         if (connsm->own_addr_type > BLE_HCI_ADV_OWN_ADDR_RANDOM) {
             if (addrd->rpa_index >= 0) {
@@ -3139,8 +3225,9 @@ ble_ll_conn_prepare_connect_ind(struct ble_ll_conn_sm *connsm,
                     ble_ll_resolv_get_priv_addr(rl, 1, pdu_data->inita);
                     addr = NULL;
                 }
-            } else if (ble_ll_resolv_local_rpa_get(connsm->own_addr_type & 1,
-                                                   pdu_data->inita) == 0) {
+            }
+            else if (ble_ll_resolv_local_rpa_get(connsm->own_addr_type & 1,
+                                                 pdu_data->inita) == 0) {
                 hdr |= BLE_ADV_PDU_HDR_TXADD_RAND;
                 addr = NULL;
             }
@@ -3160,10 +3247,11 @@ ble_ll_conn_prepare_connect_ind(struct ble_ll_conn_sm *connsm,
 }
 
 uint8_t
-ble_ll_conn_tx_connect_ind_pducb(uint8_t *dptr, void *pducb_arg, uint8_t *hdr_byte)
+ble_ll_conn_tx_connect_ind_pducb(uint8_t* dptr, void* pducb_arg,
+                                 uint8_t* hdr_byte)
 {
-    struct ble_ll_conn_sm *connsm;
-    struct ble_ll_scan_pdu_data *pdu_data;
+    struct ble_ll_conn_sm* connsm;
+    struct ble_ll_scan_pdu_data* pdu_data;
 
     connsm = pducb_arg;
     /*
@@ -3215,12 +3303,11 @@ ble_ll_conn_event_halt(void)
 
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
 int
-ble_ll_conn_send_connect_req(struct os_mbuf *rxpdu,
-                             struct ble_ll_scan_addr_data *addrd,
-                             uint8_t ext)
+ble_ll_conn_send_connect_req(struct os_mbuf* rxpdu,
+                             struct ble_ll_scan_addr_data* addrd, uint8_t ext)
 {
-    struct ble_ll_conn_sm *connsm;
-    struct ble_mbuf_hdr *rxhdr;
+    struct ble_ll_conn_sm* connsm;
+    struct ble_mbuf_hdr* rxhdr;
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_EXT_ADV)
     uint8_t phy;
 #endif
@@ -3267,7 +3354,7 @@ ble_ll_conn_send_connect_req(struct os_mbuf *rxpdu,
 void
 ble_ll_conn_send_connect_req_cancel(void)
 {
-    struct ble_ll_conn_sm *connsm;
+    struct ble_ll_conn_sm* connsm;
 
     connsm = g_ble_ll_conn_create_sm.connsm;
 
@@ -3276,9 +3363,9 @@ ble_ll_conn_send_connect_req_cancel(void)
 
 static void
 ble_ll_conn_central_start(uint8_t phy, uint8_t csa,
-                          struct ble_ll_scan_addr_data *addrd, uint8_t *targeta)
+                          struct ble_ll_scan_addr_data* addrd, uint8_t* targeta)
 {
-    struct ble_ll_conn_sm *connsm;
+    struct ble_ll_conn_sm* connsm;
 
     connsm = g_ble_ll_conn_create_sm.connsm;
     g_ble_ll_conn_create_sm.connsm = NULL;
@@ -3292,7 +3379,8 @@ ble_ll_conn_central_start(uint8_t phy, uint8_t csa,
         connsm->peer_addr_resolved = 1;
         ble_ll_resolv_set_peer_rpa(addrd->rpa_index, addrd->adva);
         ble_ll_scan_set_peer_rpa(addrd->adva);
-    } else {
+    }
+    else {
         connsm->peer_addr_resolved = 0;
     }
 
@@ -3310,11 +3398,11 @@ ble_ll_conn_central_start(uint8_t phy, uint8_t csa,
 }
 
 void
-ble_ll_conn_created_on_legacy(struct os_mbuf *rxpdu,
-                              struct ble_ll_scan_addr_data *addrd,
-                              uint8_t *targeta)
+ble_ll_conn_created_on_legacy(struct os_mbuf* rxpdu,
+                              struct ble_ll_scan_addr_data* addrd,
+                              uint8_t* targeta)
 {
-    uint8_t *rxbuf;
+    uint8_t* rxbuf;
     uint8_t csa;
 
     rxbuf = rxpdu->om_data;
@@ -3327,12 +3415,12 @@ ble_ll_conn_created_on_legacy(struct os_mbuf *rxpdu,
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_EXT_ADV)
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
 void
-ble_ll_conn_created_on_aux(struct os_mbuf *rxpdu,
-                           struct ble_ll_scan_addr_data *addrd,
-                           uint8_t *targeta)
+ble_ll_conn_created_on_aux(struct os_mbuf* rxpdu,
+                           struct ble_ll_scan_addr_data* addrd,
+                           uint8_t* targeta)
 {
 #if MYNEWT_VAL(BLE_LL_PHY)
-    struct ble_mbuf_hdr *rxhdr;
+    struct ble_mbuf_hdr* rxhdr;
 #endif
     uint8_t phy;
 
@@ -3359,7 +3447,7 @@ ble_ll_conn_created_on_aux(struct os_mbuf *rxpdu,
  * @param ble_err
  */
 void
-ble_ll_conn_timeout(struct ble_ll_conn_sm *connsm, uint8_t ble_err)
+ble_ll_conn_timeout(struct ble_ll_conn_sm* connsm, uint8_t ble_err)
 {
     int was_current;
     os_sr_t sr;
@@ -3390,9 +3478,9 @@ ble_ll_conn_timeout(struct ble_ll_conn_sm *connsm, uint8_t ble_err)
  * @param rxhdr
  */
 int
-ble_ll_conn_rx_isr_start(struct ble_mbuf_hdr *rxhdr, uint32_t aa)
+ble_ll_conn_rx_isr_start(struct ble_mbuf_hdr* rxhdr, uint32_t aa)
 {
-    struct ble_ll_conn_sm *connsm;
+    struct ble_ll_conn_sm* connsm;
 
     /*
      * Disable wait for response timer since we receive a response. We dont
@@ -3440,15 +3528,15 @@ ble_ll_conn_rx_isr_start(struct ble_mbuf_hdr *rxhdr, uint32_t aa)
  * @param rxpdu Pointer to ble mbuf header of received pdu
  */
 void
-ble_ll_conn_rx_data_pdu(struct os_mbuf *rxpdu, struct ble_mbuf_hdr *hdr)
+ble_ll_conn_rx_data_pdu(struct os_mbuf* rxpdu, struct ble_mbuf_hdr* hdr)
 {
     uint8_t hdr_byte;
     uint8_t rxd_sn;
-    uint8_t *rxbuf;
+    uint8_t* rxbuf;
     uint8_t llid;
     uint16_t acl_len;
     uint16_t acl_hdr;
-    struct ble_ll_conn_sm *connsm;
+    struct ble_ll_conn_sm* connsm;
 
     /* Packets with invalid CRC are not sent to LL */
     BLE_LL_ASSERT(BLE_MBUF_HDR_CRC_OK(hdr));
@@ -3458,8 +3546,8 @@ ble_ll_conn_rx_data_pdu(struct os_mbuf *rxpdu, struct ble_mbuf_hdr *hdr)
     /* We better have a connection state machine */
     connsm = ble_ll_conn_find_by_handle(hdr->rxinfo.handle);
     if (!connsm) {
-       STATS_INC(ble_ll_conn_stats, no_conn_sm);
-       goto conn_rx_data_pdu_end;
+        STATS_INC(ble_ll_conn_stats, no_conn_sm);
+        goto conn_rx_data_pdu_end;
     }
 
     /* Check state machine */
@@ -3544,9 +3632,9 @@ ble_ll_conn_rx_data_pdu(struct os_mbuf *rxpdu, struct ble_mbuf_hdr *hdr)
      * as the last received sequence number
      */
     if (rxd_sn == connsm->last_rxd_sn) {
-       STATS_INC(ble_ll_conn_stats, data_pdu_rx_dup);
-       goto conn_rx_data_pdu_end;
-   }
+        STATS_INC(ble_ll_conn_stats, data_pdu_rx_dup);
+        goto conn_rx_data_pdu_end;
+    }
 
     /* Update last rxd sn */
     connsm->last_rxd_sn = rxd_sn;
@@ -3566,7 +3654,8 @@ ble_ll_conn_rx_data_pdu(struct os_mbuf *rxpdu, struct ble_mbuf_hdr *hdr)
         if (ble_ll_ctrl_rx_pdu(connsm, rxpdu)) {
             STATS_INC(ble_ll_conn_stats, rx_malformed_ctrl_pdus);
         }
-    } else {
+    }
+    else {
         /* Count # of received l2cap frames and byes */
         STATS_INC(ble_ll_conn_stats, rx_l2cap_pdus);
         STATS_INCN(ble_ll_conn_stats, rx_l2cap_bytes, acl_len);
@@ -3617,7 +3706,7 @@ conn_rx_data_pdu_end:
  *       > 0: Do not disable PHY as that has already been done.
  */
 int
-ble_ll_conn_rx_isr_end(uint8_t *rxbuf, struct ble_mbuf_hdr *rxhdr)
+ble_ll_conn_rx_isr_end(uint8_t* rxbuf, struct ble_mbuf_hdr* rxhdr)
 {
     int rc;
     uint8_t hdr_byte;
@@ -3631,10 +3720,10 @@ ble_ll_conn_rx_isr_end(uint8_t *rxbuf, struct ble_mbuf_hdr *rxhdr)
     uint8_t rx_pyld_len;
     uint32_t begtime;
     uint32_t add_usecs;
-    struct os_mbuf *txpdu;
-    struct ble_ll_conn_sm *connsm;
-    struct os_mbuf *rxpdu = NULL;
-    struct ble_mbuf_hdr *txhdr;
+    struct os_mbuf* txpdu;
+    struct ble_ll_conn_sm* connsm;
+    struct os_mbuf* rxpdu = NULL;
+    struct ble_mbuf_hdr* txhdr;
     int rx_phy_mode;
     bool alloc_rxpdu = true;
 
@@ -3660,7 +3749,8 @@ ble_ll_conn_rx_isr_end(uint8_t *rxbuf, struct ble_mbuf_hdr *rxhdr)
     if (alloc_rxpdu && BLE_LL_LLID_IS_DATA(hdr_byte) && (rx_pyld_len > 0)) {
         if (hci_ipc_get(HCI_IPC_TYPE_ACL)) {
             rxhdr->rxinfo.flags |= BLE_MBUF_HDR_F_CONN_CREDIT_INT;
-        } else {
+        }
+        else {
             alloc_rxpdu = false;
         }
     }
@@ -3677,7 +3767,8 @@ ble_ll_conn_rx_isr_end(uint8_t *rxbuf, struct ble_mbuf_hdr *rxhdr)
         BLE_LL_LLID_IS_DATA(hdr_byte) && (rx_pyld_len > 0)) {
         if (ble_ll_conn_cth_flow_alloc_credit(connsm)) {
             rxhdr->rxinfo.flags |= BLE_MBUF_HDR_F_CONN_CREDIT;
-        } else {
+        }
+        else {
 #if MYNEWT_PKG_apache_mynewt_nimble__nimble_transport_common_hci_ipc
             /* Need to return app buffer to pool since we won't use it */
             hci_ipc_put(HCI_IPC_TYPE_ACL);
@@ -3718,8 +3809,7 @@ ble_ll_conn_rx_isr_end(uint8_t *rxbuf, struct ble_mbuf_hdr *rxhdr)
 #else
     rx_phy_mode = BLE_PHY_MODE_1M;
 #endif
-    add_usecs = rxhdr->rem_usecs +
-                ble_ll_pdu_us(rx_pyld_len, rx_phy_mode);
+    add_usecs = rxhdr->rem_usecs + ble_ll_pdu_us(rx_pyld_len, rx_phy_mode);
 
     /*
      * Check the packet CRC. A connection event can continue even if the
@@ -3734,7 +3824,8 @@ ble_ll_conn_rx_isr_end(uint8_t *rxbuf, struct ble_mbuf_hdr *rxhdr)
         ++connsm->cons_rxd_bad_crc;
         if (connsm->cons_rxd_bad_crc >= 2) {
             reply = 0;
-        } else {
+        }
+        else {
             switch (connsm->conn_role) {
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
             case BLE_LL_CONN_ROLE_CENTRAL:
@@ -3752,7 +3843,8 @@ ble_ll_conn_rx_isr_end(uint8_t *rxbuf, struct ble_mbuf_hdr *rxhdr)
                 break;
             }
         }
-    } else {
+    }
+    else {
         /* Reset consecutively received bad crcs (since this one was good!) */
         connsm->cons_rxd_bad_crc = 0;
 
@@ -3794,7 +3886,8 @@ ble_ll_conn_rx_isr_end(uint8_t *rxbuf, struct ble_mbuf_hdr *rxhdr)
             if ((hdr_nesn && conn_sn) || (!hdr_nesn && !conn_sn)) {
                 /* We did not get an ACK. Must retry the PDU */
                 STATS_INC(ble_ll_conn_stats, data_pdu_txf);
-            } else {
+            }
+            else {
                 /* Transmit success */
                 connsm->tx_seqnum ^= 1;
                 STATS_INC(ble_ll_conn_stats, data_pdu_txg);
@@ -3817,15 +3910,16 @@ ble_ll_conn_rx_isr_end(uint8_t *rxbuf, struct ble_mbuf_hdr *rxhdr)
                     }
 #endif
                     txhdr = BLE_MBUF_HDR_PTR(txpdu);
-                    if ((txhdr->txinfo.hdr_byte & BLE_LL_DATA_HDR_LLID_MASK)
-                        == BLE_LL_LLID_CTRL) {
+                    if ((txhdr->txinfo.hdr_byte & BLE_LL_DATA_HDR_LLID_MASK) ==
+                        BLE_LL_LLID_CTRL) {
                         connsm->cur_tx_pdu = NULL;
                         /* Note: the mbuf is freed by this call */
                         rc = ble_ll_ctrl_tx_done(txpdu, connsm);
                         if (rc) {
                             /* Means we transmitted a TERMINATE_IND */
                             goto conn_exit;
-                        } else {
+                        }
+                        else {
                             goto chk_rx_terminate_ind;
                         }
                     }
@@ -3845,8 +3939,10 @@ ble_ll_conn_rx_isr_end(uint8_t *rxbuf, struct ble_mbuf_hdr *rxhdr)
                         }
                         os_mbuf_free_chain(txpdu);
                         connsm->cur_tx_pdu = NULL;
-                    } else {
-                        rem_bytes = OS_MBUF_PKTLEN(txpdu) - txhdr->txinfo.offset;
+                    }
+                    else {
+                        rem_bytes =
+                            OS_MBUF_PKTLEN(txpdu) - txhdr->txinfo.offset;
                         /* Adjust payload for max TX time and octets */
 
 #if MYNEWT_VAL(BLE_LL_PHY)
@@ -3854,11 +3950,12 @@ ble_ll_conn_rx_isr_end(uint8_t *rxbuf, struct ble_mbuf_hdr *rxhdr)
                             CONN_IS_PERIPHERAL(connsm) &&
                             (opcode == BLE_LL_CTRL_PHY_UPDATE_IND)) {
                             connsm->phy_tx_transition =
-                                    ble_ll_ctrl_phy_tx_transition_get(rxbuf[3]);
+                                ble_ll_ctrl_phy_tx_transition_get(rxbuf[3]);
                         }
 #endif
 
-                        rem_bytes = ble_ll_conn_adjust_pyld_len(connsm, rem_bytes);
+                        rem_bytes =
+                            ble_ll_conn_adjust_pyld_len(connsm, rem_bytes);
                         txhdr->txinfo.pyld_len = rem_bytes;
                     }
                 }
@@ -3867,7 +3964,7 @@ ble_ll_conn_rx_isr_end(uint8_t *rxbuf, struct ble_mbuf_hdr *rxhdr)
 
         /* Should we continue connection event? */
         /* If this is a TERMINATE_IND, we have to reply */
-chk_rx_terminate_ind:
+    chk_rx_terminate_ind:
         /* If we received a terminate IND, we must set some flags */
         if (BLE_LL_LLID_IS_CTRL(hdr_byte) &&
             (opcode == BLE_LL_CTRL_TERMINATE_IND) &&
@@ -3879,7 +3976,8 @@ chk_rx_terminate_ind:
         switch (connsm->conn_role) {
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
         case BLE_LL_CONN_ROLE_CENTRAL:
-            reply = connsm->flags.last_txd_md || (hdr_byte & BLE_LL_DATA_HDR_MD_MASK);
+            reply = connsm->flags.last_txd_md ||
+                    (hdr_byte & BLE_LL_DATA_HDR_MD_MASK);
             break;
 #endif
 #if MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL)
@@ -3933,12 +4031,12 @@ conn_exit:
  * @param om
  */
 void
-ble_ll_conn_enqueue_pkt(struct ble_ll_conn_sm *connsm, struct os_mbuf *om,
+ble_ll_conn_enqueue_pkt(struct ble_ll_conn_sm* connsm, struct os_mbuf* om,
                         uint8_t hdr_byte, uint16_t length)
 {
     os_sr_t sr;
-    struct os_mbuf_pkthdr *pkthdr;
-    struct ble_mbuf_hdr *ble_hdr;
+    struct os_mbuf_pkthdr* pkthdr;
+    struct ble_mbuf_hdr* ble_hdr;
     int lifo;
 
     /* Set mbuf length and packet length if a control PDU */
@@ -3975,6 +4073,10 @@ ble_ll_conn_enqueue_pkt(struct ble_ll_conn_sm *connsm, struct os_mbuf *om,
             case BLE_LL_CTRL_REJECT_IND_EXT:
             case BLE_LL_CTRL_START_ENC_REQ:
             case BLE_LL_CTRL_START_ENC_RSP:
+            case BLE_LL_CTRL_ENC_F_REQ:
+            case BLE_LL_CTRL_ENC_F_RSP:
+            case BLE_LL_CTRL_REKEY_REQ:
+            case BLE_LL_CTRL_REKEY_RSP:
                 lifo = 1;
                 break;
             case BLE_LL_CTRL_PAUSE_ENC_RSP:
@@ -4005,7 +4107,8 @@ ble_ll_conn_enqueue_pkt(struct ble_ll_conn_sm *connsm, struct os_mbuf *om,
     OS_ENTER_CRITICAL(sr);
     if (lifo) {
         STAILQ_INSERT_HEAD(&connsm->conn_txq, pkthdr, omp_next);
-    } else {
+    }
+    else {
         STAILQ_INSERT_TAIL(&connsm->conn_txq, pkthdr, omp_next);
     }
     OS_EXIT_CRITICAL(sr);
@@ -4023,12 +4126,12 @@ ble_ll_conn_enqueue_pkt(struct ble_ll_conn_sm *connsm, struct os_mbuf *om,
  * @return int
  */
 void
-ble_ll_conn_tx_pkt_in(struct os_mbuf *om, uint16_t handle, uint16_t length)
+ble_ll_conn_tx_pkt_in(struct os_mbuf* om, uint16_t handle, uint16_t length)
 {
     uint8_t hdr_byte;
     uint16_t conn_handle;
     uint16_t pb;
-    struct ble_ll_conn_sm *connsm;
+    struct ble_ll_conn_sm* connsm;
 
     /* See if we have an active matching connection handle */
     conn_handle = handle & 0x0FFF;
@@ -4038,7 +4141,8 @@ ble_ll_conn_tx_pkt_in(struct os_mbuf *om, uint16_t handle, uint16_t length)
         pb = handle & 0x3000;
         if (pb == 0) {
             hdr_byte = BLE_LL_LLID_DATA_START;
-        } else {
+        }
+        else {
             hdr_byte = BLE_LL_LLID_DATA_FRAG;
         }
 
@@ -4047,7 +4151,8 @@ ble_ll_conn_tx_pkt_in(struct os_mbuf *om, uint16_t handle, uint16_t length)
 
         /* Clear flags field in BLE header */
         ble_ll_conn_enqueue_pkt(connsm, om, hdr_byte, length);
-    } else {
+    }
+    else {
         /* No connection found! */
         STATS_INC(ble_ll_conn_stats, handle_not_found);
         os_mbuf_free_chain(om);
@@ -4059,10 +4164,11 @@ void
 ble_ll_conn_chan_map_update(void)
 {
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
-    struct ble_ll_conn_sm *connsm;
+    struct ble_ll_conn_sm* connsm;
 
     /* Perform channel map update */
-    SLIST_FOREACH(connsm, &g_ble_ll_conn_active_list, act_sle) {
+    SLIST_FOREACH(connsm, &g_ble_ll_conn_active_list, act_sle)
+    {
         if (connsm->conn_role == BLE_LL_CONN_ROLE_CENTRAL) {
             ble_ll_ctrl_proc_start(connsm, BLE_LL_CTRL_PROC_CHAN_MAP_UPD, NULL);
         }
@@ -4086,25 +4192,27 @@ ble_ll_conn_chan_map_update(void)
  */
 #if MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL)
 int
-ble_ll_conn_periph_start(uint8_t *rxbuf, uint8_t pat, struct ble_mbuf_hdr *rxhdr,
-                         bool force_csa2)
+ble_ll_conn_periph_start(uint8_t* rxbuf, uint8_t pat,
+                         struct ble_mbuf_hdr* rxhdr, bool force_csa2)
 {
     int rc;
     uint32_t temp;
     uint32_t crcinit;
-    uint8_t *inita;
-    uint8_t *dptr;
-    struct ble_ll_conn_sm *connsm;
+    uint8_t* inita;
+    uint8_t* dptr;
+    struct ble_ll_conn_sm* connsm;
 
     /* Ignore the connection request if we are already connected*/
     inita = rxbuf + BLE_LL_PDU_HDR_LEN;
-    SLIST_FOREACH(connsm, &g_ble_ll_conn_active_list, act_sle) {
+    SLIST_FOREACH(connsm, &g_ble_ll_conn_active_list, act_sle)
+    {
         if (!memcmp(&connsm->peer_addr, inita, BLE_DEV_ADDR_LEN)) {
             if (rxbuf[0] & BLE_ADV_PDU_HDR_TXADD_MASK) {
                 if (connsm->peer_addr_type & 1) {
                     return 0;
                 }
-            } else {
+            }
+            else {
                 if ((connsm->peer_addr_type & 1) == 0) {
                     return 0;
                 }
@@ -4149,7 +4257,7 @@ ble_ll_conn_periph_start(uint8_t *rxbuf, uint8_t pat, struct ble_mbuf_hdr *rxhdr
     /* Slave latency cannot cause a supervision timeout */
     temp = (connsm->periph_latency + 1) * (connsm->conn_itvl * 2) *
            BLE_LL_CONN_ITVL_USECS;
-    if ((connsm->supervision_tmo * 10000) <= temp ) {
+    if ((connsm->supervision_tmo * 10000) <= temp) {
         goto err_periph_start;
     }
 
@@ -4194,7 +4302,8 @@ ble_ll_conn_periph_start(uint8_t *rxbuf, uint8_t pat, struct ble_mbuf_hdr *rxhdr
     connsm->conn_sch.sched_cb = ble_ll_conn_event_start_cb;
     rc = ble_ll_conn_created(connsm, rxhdr);
     if (!rc) {
-        SLIST_REMOVE(&g_ble_ll_conn_active_list, connsm, ble_ll_conn_sm, act_sle);
+        SLIST_REMOVE(&g_ble_ll_conn_active_list, connsm, ble_ll_conn_sm,
+                     act_sle);
         STAILQ_INSERT_TAIL(&g_ble_ll_conn_free_list, connsm, free_stqe);
     }
     return rc;
@@ -4208,8 +4317,8 @@ err_periph_start:
 
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_ENHANCED_CONN_UPDATE)
 int
-ble_ll_conn_subrate_req_hci(struct ble_ll_conn_sm *connsm,
-                            struct ble_ll_conn_subrate_req_params *srp)
+ble_ll_conn_subrate_req_hci(struct ble_ll_conn_sm* connsm,
+                            struct ble_ll_conn_subrate_req_params* srp)
 {
     uint32_t t1, t2;
 
@@ -4274,13 +4383,12 @@ ble_ll_conn_subrate_req_hci(struct ble_ll_conn_sm *connsm,
         BLE_LL_ASSERT(0);
     }
 
-
     return 0;
 }
 
 int
-ble_ll_conn_subrate_req_llcp(struct ble_ll_conn_sm *connsm,
-                             struct ble_ll_conn_subrate_req_params *srp)
+ble_ll_conn_subrate_req_llcp(struct ble_ll_conn_sm* connsm,
+                             struct ble_ll_conn_subrate_req_params* srp)
 {
     BLE_LL_ASSERT(connsm->conn_role == BLE_LL_CONN_ROLE_CENTRAL);
 
@@ -4300,21 +4408,22 @@ ble_ll_conn_subrate_req_llcp(struct ble_ll_conn_sm *connsm,
         (srp->subrate_max < connsm->acc_subrate_min) ||
         (srp->subrate_min > connsm->acc_subrate_max) ||
         ((connsm->conn_itvl * BLE_LL_CONN_ITVL_USECS * srp->subrate_min *
-          (srp->max_latency + 1)) * 2 >= srp->supervision_tmo *
-                                         BLE_HCI_CONN_SPVN_TMO_UNITS * 1000)) {
+          (srp->max_latency + 1)) *
+             2 >=
+         srp->supervision_tmo * BLE_HCI_CONN_SPVN_TMO_UNITS * 1000)) {
         return -EINVAL;
     }
 
-    connsm->subrate_trans.subrate_factor = MIN(connsm->acc_subrate_max,
-                                               srp->subrate_max);
+    connsm->subrate_trans.subrate_factor =
+        MIN(connsm->acc_subrate_max, srp->subrate_max);
     connsm->subrate_trans.subrate_base_event = connsm->event_cntr;
-    connsm->subrate_trans.periph_latency = MIN(connsm->acc_max_latency,
-                                               srp->max_latency);
-    connsm->subrate_trans.cont_num = MIN(MAX(connsm->acc_cont_num,
-                                             srp->cont_num),
-                                         connsm->subrate_trans.subrate_factor - 1);
-    connsm->subrate_trans.supervision_tmo = MIN(connsm->supervision_tmo,
-                                                srp->supervision_tmo);
+    connsm->subrate_trans.periph_latency =
+        MIN(connsm->acc_max_latency, srp->max_latency);
+    connsm->subrate_trans.cont_num =
+        MIN(MAX(connsm->acc_cont_num, srp->cont_num),
+            connsm->subrate_trans.subrate_factor - 1);
+    connsm->subrate_trans.supervision_tmo =
+        MIN(connsm->supervision_tmo, srp->supervision_tmo);
 
     ble_ll_ctrl_proc_start(connsm, BLE_LL_CTRL_PROC_SUBRATE_UPDATE, NULL);
 
@@ -4322,8 +4431,8 @@ ble_ll_conn_subrate_req_llcp(struct ble_ll_conn_sm *connsm,
 }
 
 void
-ble_ll_conn_subrate_set(struct ble_ll_conn_sm *connsm,
-                        struct ble_ll_conn_subrate_params *sp)
+ble_ll_conn_subrate_set(struct ble_ll_conn_sm* connsm,
+                        struct ble_ll_conn_subrate_params* sp)
 {
     int16_t event_cntr_diff;
     int16_t subrate_events_diff;
@@ -4354,9 +4463,9 @@ ble_ll_conn_subrate_set(struct ble_ll_conn_sm *connsm,
 }
 #endif
 
-#define MAX_TIME_UNCODED(_maxbytes) \
+#define MAX_TIME_UNCODED(_maxbytes)                                            \
     ble_ll_pdu_us(_maxbytes + BLE_LL_DATA_MIC_LEN, BLE_PHY_MODE_1M);
-#define MAX_TIME_CODED(_maxbytes) \
+#define MAX_TIME_CODED(_maxbytes)                                              \
     ble_ll_pdu_us(_maxbytes + BLE_LL_DATA_MIC_LEN, BLE_PHY_MODE_CODED_125KBPS);
 
 /**
@@ -4371,8 +4480,8 @@ ble_ll_conn_module_reset(void)
 {
     uint8_t max_phy_pyld;
     uint16_t maxbytes;
-    struct ble_ll_conn_sm *connsm;
-    struct ble_ll_conn_global_params *conn_params;
+    struct ble_ll_conn_sm* connsm;
+    struct ble_ll_conn_global_params* conn_params;
 
     /* Kill the current one first (if one is running) */
     if (g_ble_ll_conn_cur_sm) {
@@ -4467,7 +4576,7 @@ ble_ll_conn_module_init(void)
 {
     int rc;
     uint16_t i;
-    struct ble_ll_conn_sm *connsm;
+    struct ble_ll_conn_sm* connsm;
 
     /* Initialize list of active connections */
     SLIST_INIT(&g_ble_ll_conn_active_list);
@@ -4499,10 +4608,10 @@ ble_ll_conn_module_init(void)
     }
 
     /* Register connection statistics */
-    rc = stats_init_and_reg(STATS_HDR(ble_ll_conn_stats),
-                            STATS_SIZE_INIT_PARMS(ble_ll_conn_stats, STATS_SIZE_32),
-                            STATS_NAME_INIT_PARMS(ble_ll_conn_stats),
-                            "ble_ll_conn");
+    rc = stats_init_and_reg(
+        STATS_HDR(ble_ll_conn_stats),
+        STATS_SIZE_INIT_PARMS(ble_ll_conn_stats, STATS_SIZE_32),
+        STATS_NAME_INIT_PARMS(ble_ll_conn_stats), "ble_ll_conn");
     BLE_LL_ASSERT(rc == 0);
 
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_CTRL_TO_HOST_FLOW_CONTROL)
diff --git a/nimble/controller/src/ble_ll_conn_hci.c b/nimble/controller/src/ble_ll_conn_hci.c
index a7bb136f..55927738 100644
--- a/nimble/controller/src/ble_ll_conn_hci.c
+++ b/nimble/controller/src/ble_ll_conn_hci.c
@@ -41,25 +41,25 @@
  * event to the host. This is the os time at which we can send an event.
  */
 static ble_npl_time_t g_ble_ll_last_num_comp_pkt_evt;
-extern uint8_t *g_ble_ll_conn_comp_ev;
+extern uint8_t* g_ble_ll_conn_comp_ev;
 
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_EXT_ADV)
-static const uint8_t ble_ll_conn_create_valid_phy_mask = (
-        BLE_HCI_LE_PHY_1M_PREF_MASK |
+static const uint8_t ble_ll_conn_create_valid_phy_mask =
+    (BLE_HCI_LE_PHY_1M_PREF_MASK |
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LE_2M_PHY)
-        BLE_HCI_LE_PHY_2M_PREF_MASK |
+     BLE_HCI_LE_PHY_2M_PREF_MASK |
 #endif
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LE_CODED_PHY)
-        BLE_HCI_LE_PHY_CODED_PREF_MASK |
+     BLE_HCI_LE_PHY_CODED_PREF_MASK |
 #endif
-        0);
+     0);
 
-static const uint8_t ble_ll_conn_create_required_phy_mask = (
-        BLE_HCI_LE_PHY_1M_PREF_MASK |
+static const uint8_t ble_ll_conn_create_required_phy_mask =
+    (BLE_HCI_LE_PHY_1M_PREF_MASK |
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LE_CODED_PHY)
-        BLE_HCI_LE_PHY_CODED_PREF_MASK |
+     BLE_HCI_LE_PHY_CODED_PREF_MASK |
 #endif
-        0);
+     0);
 #endif
 
 /**
@@ -71,7 +71,7 @@ static int
 ble_ll_init_alloc_conn_comp_ev(void)
 {
     int rc;
-    uint8_t *evbuf;
+    uint8_t* evbuf;
 
     rc = 0;
     evbuf = g_ble_ll_conn_comp_ev;
@@ -79,7 +79,8 @@ ble_ll_init_alloc_conn_comp_ev(void)
         evbuf = ble_transport_alloc_evt(0);
         if (!evbuf) {
             rc = -1;
-        } else {
+        }
+        else {
             g_ble_ll_conn_comp_ev = evbuf;
         }
     }
@@ -104,8 +105,7 @@ ble_ll_conn_hci_chk_conn_params(uint16_t itvl_min, uint16_t itvl_max,
     uint32_t spvn_tmo_usecs;
     uint32_t min_spvn_tmo_usecs;
 
-    if ((itvl_min > itvl_max) ||
-        (itvl_min < BLE_HCI_CONN_ITVL_MIN) ||
+    if ((itvl_min > itvl_max) || (itvl_min < BLE_HCI_CONN_ITVL_MIN) ||
         (itvl_max > BLE_HCI_CONN_ITVL_MAX) ||
         (latency > BLE_HCI_CONN_LATENCY_MAX) ||
         (spvn_tmo < BLE_HCI_CONN_SPVN_TIMEOUT_MIN) ||
@@ -134,20 +134,20 @@ ble_ll_conn_hci_chk_conn_params(uint16_t itvl_min, uint16_t itvl_max,
  * @param status The BLE error code associated with the event
  */
 void
-ble_ll_conn_comp_event_send(struct ble_ll_conn_sm *connsm, uint8_t status,
-                            uint8_t *evbuf, struct ble_ll_adv_sm *advsm)
+ble_ll_conn_comp_event_send(struct ble_ll_conn_sm* connsm, uint8_t status,
+                            uint8_t* evbuf, struct ble_ll_adv_sm* advsm)
 {
-    struct ble_hci_ev_le_subev_enh_conn_complete *enh_ev;
-    struct ble_hci_ev_le_subev_conn_complete *ev;
-    struct ble_hci_ev *hci_ev = (void *) evbuf;
-    uint8_t *rpa = NULL;
+    struct ble_hci_ev_le_subev_enh_conn_complete* enh_ev;
+    struct ble_hci_ev_le_subev_conn_complete* ev;
+    struct ble_hci_ev* hci_ev = (void*)evbuf;
+    uint8_t* rpa = NULL;
 
     BLE_LL_ASSERT(evbuf);
 
     if (ble_ll_hci_is_le_event_enabled(BLE_HCI_LE_SUBEV_ENH_CONN_COMPLETE)) {
         hci_ev->opcode = BLE_HCI_EVCODE_LE_META;
         hci_ev->length = sizeof(*enh_ev);
-        enh_ev = (void *) hci_ev->data;
+        enh_ev = (void*)hci_ev->data;
 
         memset(enh_ev, 0, sizeof(*enh_ev));
 
@@ -172,9 +172,11 @@ ble_ll_conn_comp_event_send(struct ble_ll_conn_sm *connsm, uint8_t status,
                      * b) peer uses RPA and this is first time we connect to him
                      */
                     rpa = NULL;
-                } else  if (connsm->own_addr_type > BLE_HCI_ADV_OWN_ADDR_RANDOM) {
+                }
+                else if (connsm->own_addr_type > BLE_HCI_ADV_OWN_ADDR_RANDOM) {
                     rpa = ble_ll_scan_get_local_rpa();
-                } else {
+                }
+                else {
                     rpa = NULL;
                 }
                 break;
@@ -195,30 +197,30 @@ ble_ll_conn_comp_event_send(struct ble_ll_conn_sm *connsm, uint8_t status,
 
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_PRIVACY)
             /* Adjust address type if peer address was resolved */
-             if (connsm->peer_addr_resolved) {
-                 enh_ev->peer_addr_type += 2;
-             }
+            if (connsm->peer_addr_resolved) {
+                enh_ev->peer_addr_type += 2;
+            }
 #endif
 
-             if (enh_ev->peer_addr_type > BLE_HCI_CONN_PEER_ADDR_RANDOM) {
-                 switch (connsm->conn_role) {
+            if (enh_ev->peer_addr_type > BLE_HCI_CONN_PEER_ADDR_RANDOM) {
+                switch (connsm->conn_role) {
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
-                 case BLE_LL_CONN_ROLE_CENTRAL:
-                     rpa = ble_ll_scan_get_peer_rpa();
-                     break;
+                case BLE_LL_CONN_ROLE_CENTRAL:
+                    rpa = ble_ll_scan_get_peer_rpa();
+                    break;
 #endif
 #if MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL)
-                 case BLE_LL_CONN_ROLE_PERIPHERAL:
-                     rpa = ble_ll_adv_get_peer_rpa(advsm);
-                 break;
+                case BLE_LL_CONN_ROLE_PERIPHERAL:
+                    rpa = ble_ll_adv_get_peer_rpa(advsm);
+                    break;
 #endif
-                 default:
-                     BLE_LL_ASSERT(0);
-                     break;
-                 }
+                default:
+                    BLE_LL_ASSERT(0);
+                    break;
+                }
 
-                 memcpy(enh_ev->peer_rpa, rpa, BLE_DEV_ADDR_LEN);
-             }
+                memcpy(enh_ev->peer_rpa, rpa, BLE_DEV_ADDR_LEN);
+            }
 
             enh_ev->conn_itvl = htole16(connsm->conn_itvl);
             enh_ev->conn_latency = htole16(connsm->periph_latency);
@@ -237,7 +239,7 @@ ble_ll_conn_comp_event_send(struct ble_ll_conn_sm *connsm, uint8_t status,
     if (ble_ll_hci_is_le_event_enabled(BLE_HCI_LE_SUBEV_CONN_COMPLETE)) {
         hci_ev->opcode = BLE_HCI_EVCODE_LE_META;
         hci_ev->length = sizeof(*ev);
-        ev = (void *) hci_ev->data;
+        ev = (void*)hci_ev->data;
 
         memset(ev, 0, sizeof(*ev));
 
@@ -271,13 +273,13 @@ ble_ll_conn_comp_event_send(struct ble_ll_conn_sm *connsm, uint8_t status,
  * host.
  */
 void
-ble_ll_conn_num_comp_pkts_event_send(struct ble_ll_conn_sm *connsm)
+ble_ll_conn_num_comp_pkts_event_send(struct ble_ll_conn_sm* connsm)
 {
     /** The maximum number of handles that will fit in an event buffer. */
     static const int max_handles =
-            (BLE_LL_MAX_EVT_LEN - sizeof(struct ble_hci_ev_num_comp_pkts) - 1) / 4;
-    struct ble_hci_ev_num_comp_pkts *ev;
-    struct ble_hci_ev *hci_ev;
+        (BLE_LL_MAX_EVT_LEN - sizeof(struct ble_hci_ev_num_comp_pkts) - 1) / 4;
+    struct ble_hci_ev_num_comp_pkts* ev;
+    struct ble_hci_ev* hci_ev;
     int event_sent;
 
     if (connsm == NULL) {
@@ -303,7 +305,7 @@ ble_ll_conn_num_comp_pkts_event_send(struct ble_ll_conn_sm *connsm)
             if (hci_ev) {
                 hci_ev->opcode = BLE_HCI_EVCODE_NUM_COMP_PKTS;
                 hci_ev->length = sizeof(*ev);
-                ev = (void *)hci_ev->data;
+                ev = (void*)hci_ev->data;
 
                 ev->count = 1;
                 ev->completed[0].handle = htole16(connsm->conn_handle);
@@ -324,7 +326,8 @@ skip_conn:
     ev = NULL;
 
     event_sent = 0;
-    SLIST_FOREACH(connsm, &g_ble_ll_conn_active_list, act_sle) {
+    SLIST_FOREACH(connsm, &g_ble_ll_conn_active_list, act_sle)
+    {
         /*
          * Only look at connections that we have sent a connection complete
          * event and that either has packets enqueued or has completed packets.
@@ -340,7 +343,7 @@ skip_conn:
 
                 hci_ev->opcode = BLE_HCI_EVCODE_NUM_COMP_PKTS;
                 hci_ev->length = sizeof(*ev);
-                ev = (void *)hci_ev->data;
+                ev = (void*)hci_ev->data;
 
                 ev->count = 0;
             }
@@ -383,10 +386,10 @@ skip_conn:
  * @param reason The BLE error code to send as a disconnect reason
  */
 void
-ble_ll_auth_pyld_tmo_event_send(struct ble_ll_conn_sm *connsm)
+ble_ll_auth_pyld_tmo_event_send(struct ble_ll_conn_sm* connsm)
 {
-    struct ble_hci_ev_auth_pyld_tmo *ev;
-    struct ble_hci_ev *hci_ev;
+    struct ble_hci_ev_auth_pyld_tmo* ev;
+    struct ble_hci_ev* hci_ev;
 
     if (ble_ll_hci_is_event_enabled(BLE_HCI_EVCODE_AUTH_PYLD_TMO)) {
         hci_ev = ble_transport_alloc_evt(0);
@@ -394,7 +397,7 @@ ble_ll_auth_pyld_tmo_event_send(struct ble_ll_conn_sm *connsm)
             hci_ev->opcode = BLE_HCI_EVCODE_AUTH_PYLD_TMO;
             hci_ev->length = sizeof(*ev);
 
-            ev = (void *) hci_ev->data;
+            ev = (void*)hci_ev->data;
             ev->conn_handle = htole16(connsm->conn_handle);
 
             ble_ll_hci_event_send(hci_ev);
@@ -412,10 +415,10 @@ ble_ll_auth_pyld_tmo_event_send(struct ble_ll_conn_sm *connsm)
  * @param reason The BLE error code to send as a disconnect reason
  */
 void
-ble_ll_disconn_comp_event_send(struct ble_ll_conn_sm *connsm, uint8_t reason)
+ble_ll_disconn_comp_event_send(struct ble_ll_conn_sm* connsm, uint8_t reason)
 {
-    struct ble_hci_ev_disconn_cmp *ev;
-    struct ble_hci_ev *hci_ev;
+    struct ble_hci_ev_disconn_cmp* ev;
+    struct ble_hci_ev* hci_ev;
 
     if (ble_ll_hci_is_event_enabled(BLE_HCI_EVCODE_DISCONN_CMP)) {
         hci_ev = ble_transport_alloc_evt(0);
@@ -423,7 +426,7 @@ ble_ll_disconn_comp_event_send(struct ble_ll_conn_sm *connsm, uint8_t reason)
             hci_ev->opcode = BLE_HCI_EVCODE_DISCONN_CMP;
             hci_ev->length = sizeof(*ev);
 
-            ev = (void *) hci_ev->data;
+            ev = (void*)hci_ev->data;
 
             ev->status = BLE_ERR_SUCCESS;
             ev->conn_handle = htole16(connsm->conn_handle);
@@ -435,7 +438,7 @@ ble_ll_disconn_comp_event_send(struct ble_ll_conn_sm *connsm, uint8_t reason)
 }
 
 int
-ble_ll_conn_hci_create_check_scan(struct ble_ll_conn_create_scan *p)
+ble_ll_conn_hci_create_check_scan(struct ble_ll_conn_create_scan* p)
 {
     if (p->filter_policy > BLE_HCI_INITIATOR_FILT_POLICY_MAX) {
         return BLE_ERR_INV_HCI_CMD_PARMS;
@@ -464,14 +467,13 @@ ble_ll_conn_hci_create_check_scan(struct ble_ll_conn_create_scan *p)
 }
 
 static int
-ble_ll_conn_hci_create_check_params(struct ble_ll_conn_create_params *cc_params)
+ble_ll_conn_hci_create_check_params(struct ble_ll_conn_create_params* cc_params)
 {
     int rc;
 
-    rc = ble_ll_conn_hci_chk_conn_params(cc_params->conn_itvl,
-                                         cc_params->conn_itvl,
-                                         cc_params->conn_latency,
-                                         cc_params->supervision_timeout);
+    rc = ble_ll_conn_hci_chk_conn_params(
+        cc_params->conn_itvl, cc_params->conn_itvl, cc_params->conn_latency,
+        cc_params->supervision_timeout);
     if (rc) {
         return BLE_ERR_INV_HCI_CMD_PARMS;
     }
@@ -507,12 +509,12 @@ ble_ll_conn_hci_create_check_params(struct ble_ll_conn_create_params *cc_params)
  * @return int
  */
 int
-ble_ll_conn_hci_create(const uint8_t *cmdbuf, uint8_t len)
+ble_ll_conn_hci_create(const uint8_t* cmdbuf, uint8_t len)
 {
-    const struct ble_hci_le_create_conn_cp *cmd = (const void *) cmdbuf;
+    const struct ble_hci_le_create_conn_cp* cmd = (const void*)cmdbuf;
     struct ble_ll_conn_create_scan cc_scan;
     struct ble_ll_conn_create_params cc_params;
-    struct ble_ll_conn_sm *connsm;
+    struct ble_ll_conn_sm* connsm;
     uint16_t conn_itvl_min;
     uint16_t conn_itvl_max;
 #if MYNEWT_VAL(BLE_LL_CONN_STRICT_SCHED)
@@ -552,7 +554,8 @@ ble_ll_conn_hci_create(const uint8_t *cmdbuf, uint8_t len)
     if (cc_scan.filter_policy == 0) {
         cc_scan.peer_addr_type = cmd->peer_addr_type;
         memcpy(&cc_scan.peer_addr, cmd->peer_addr, BLE_DEV_ADDR_LEN);
-    } else {
+    }
+    else {
         cc_scan.peer_addr_type = 0;
         memset(&cc_scan.peer_addr, 0, BLE_DEV_ADDR_LEN);
     }
@@ -585,7 +588,8 @@ ble_ll_conn_hci_create(const uint8_t *cmdbuf, uint8_t len)
             (cc_params.conn_itvl > conn_itvl_max)) {
             return BLE_ERR_INV_HCI_CMD_PARMS;
         }
-    } else {
+    }
+    else {
         cc_params.conn_itvl = conn_itvl_max;
     }
 #else
@@ -624,11 +628,13 @@ ble_ll_conn_hci_create(const uint8_t *cmdbuf, uint8_t len)
     /* Start scanning */
     rc = ble_ll_scan_initiator_start(connsm, 0, &cc_scan);
     if (rc) {
-        SLIST_REMOVE(&g_ble_ll_conn_active_list,connsm,ble_ll_conn_sm,act_sle);
+        SLIST_REMOVE(&g_ble_ll_conn_active_list, connsm, ble_ll_conn_sm,
+                     act_sle);
         STAILQ_INSERT_TAIL(&g_ble_ll_conn_free_list, connsm, free_stqe);
 #if MYNEWT_VAL(BLE_LL_CONN_STRICT_SCHED)
         if (ble_ll_sched_css_is_enabled()) {
-            SLIST_REMOVE(&g_ble_ll_conn_css_list, connsm, ble_ll_conn_sm, css_sle);
+            SLIST_REMOVE(&g_ble_ll_conn_css_list, connsm, ble_ll_conn_sm,
+                         css_sle);
         }
 #endif
     }
@@ -638,8 +644,8 @@ ble_ll_conn_hci_create(const uint8_t *cmdbuf, uint8_t len)
 
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_EXT_ADV)
 static void
-ble_ll_conn_hci_ext_create_set_fb_params(uint8_t init_phy_mask,
-                                         struct ble_ll_conn_create_params *cc_params_fb)
+ble_ll_conn_hci_ext_create_set_fb_params(
+    uint8_t init_phy_mask, struct ble_ll_conn_create_params* cc_params_fb)
 {
     if ((init_phy_mask & BLE_PHY_MASK_1M) == 0) {
         g_ble_ll_conn_create_sm.params[BLE_PHY_IDX_1M] = *cc_params_fb;
@@ -659,10 +665,10 @@ ble_ll_conn_hci_ext_create_set_fb_params(uint8_t init_phy_mask,
 }
 
 static int
-ble_ll_conn_hci_ext_create_parse_params(const struct conn_params *params,
-                                        uint8_t phy,
-                                        struct ble_ll_conn_create_scan *cc_scan,
-                                        struct ble_ll_conn_create_params *cc_params)
+ble_ll_conn_hci_ext_create_parse_params(
+    const struct conn_params* params, uint8_t phy,
+    struct ble_ll_conn_create_scan* cc_scan,
+    struct ble_ll_conn_create_params* cc_params)
 {
     uint16_t conn_itvl_min;
     uint16_t conn_itvl_max;
@@ -687,7 +693,8 @@ ble_ll_conn_hci_ext_create_parse_params(const struct conn_params *params,
             (cc_params->conn_itvl > conn_itvl_max)) {
             return BLE_ERR_INV_HCI_CMD_PARMS;
         }
-    } else {
+    }
+    else {
         cc_params->conn_itvl = conn_itvl_max;
     }
 #else
@@ -712,13 +719,14 @@ ble_ll_conn_hci_ext_create_parse_params(const struct conn_params *params,
             (scan_window < BLE_HCI_SCAN_WINDOW_MIN) ||
             (scan_window > BLE_HCI_SCAN_WINDOW_MAX) ||
             (scan_itvl < scan_window)) {
-                return BLE_ERR_INV_HCI_CMD_PARMS;
+            return BLE_ERR_INV_HCI_CMD_PARMS;
         }
 
         if (phy == BLE_PHY_1M) {
             cc_scan->scan_params[PHY_UNCODED].itvl = scan_itvl;
             cc_scan->scan_params[PHY_UNCODED].window = scan_window;
-        } else {
+        }
+        else {
             cc_scan->scan_params[PHY_CODED].itvl = scan_itvl;
             cc_scan->scan_params[PHY_CODED].window = scan_window;
         }
@@ -728,29 +736,30 @@ ble_ll_conn_hci_ext_create_parse_params(const struct conn_params *params,
 }
 
 int
-ble_ll_conn_hci_ext_create(const uint8_t *cmdbuf, uint8_t len)
+ble_ll_conn_hci_ext_create(const uint8_t* cmdbuf, uint8_t len)
 {
-    static const struct init_phy {
+    static const struct init_phy
+    {
         uint8_t idx;
         uint8_t mask;
         uint8_t phy;
     } init_phys[] = {
-            {BLE_PHY_IDX_1M, BLE_PHY_MASK_1M, BLE_PHY_1M},
+        {BLE_PHY_IDX_1M, BLE_PHY_MASK_1M, BLE_PHY_1M},
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LE_2M_PHY)
-            {BLE_PHY_IDX_2M, BLE_PHY_MASK_2M, BLE_PHY_2M},
+        {BLE_PHY_IDX_2M, BLE_PHY_MASK_2M, BLE_PHY_2M},
 #endif
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LE_CODED_PHY)
-            {BLE_PHY_IDX_CODED, BLE_PHY_MASK_CODED, BLE_PHY_CODED},
+        {BLE_PHY_IDX_CODED, BLE_PHY_MASK_CODED, BLE_PHY_CODED},
 #endif
     };
 
-    const struct ble_hci_le_ext_create_conn_cp *cmd = (const void *)cmdbuf;
-    const struct conn_params *params = cmd->conn_params;
+    const struct ble_hci_le_ext_create_conn_cp* cmd = (const void*)cmdbuf;
+    const struct conn_params* params = cmd->conn_params;
     struct ble_ll_conn_create_scan cc_scan;
-    struct ble_ll_conn_create_params *cc_params;
-    struct ble_ll_conn_create_params *cc_params_fb;
-    struct ble_ll_conn_sm *connsm;
-    const struct init_phy *init_phy;
+    struct ble_ll_conn_create_params* cc_params;
+    struct ble_ll_conn_create_params* cc_params_fb;
+    struct ble_ll_conn_sm* connsm;
+    const struct init_phy* init_phy;
 #if MYNEWT_VAL(BLE_LL_CONN_STRICT_SCHED)
     uint16_t css_slot_idx = 0;
 #endif
@@ -758,7 +767,7 @@ ble_ll_conn_hci_ext_create(const uint8_t *cmdbuf, uint8_t len)
 
     /* validate length */
     if (len < sizeof(*cmd) +
-              __builtin_popcount(cmd->init_phy_mask) * sizeof(*params)) {
+                  __builtin_popcount(cmd->init_phy_mask) * sizeof(*params)) {
         return BLE_ERR_INV_HCI_CMD_PARMS;
     }
 
@@ -790,7 +799,8 @@ ble_ll_conn_hci_ext_create(const uint8_t *cmdbuf, uint8_t len)
     if (cc_scan.filter_policy == 0) {
         cc_scan.peer_addr_type = cmd->peer_addr_type;
         memcpy(cc_scan.peer_addr, cmd->peer_addr, BLE_DEV_ADDR_LEN);
-    } else {
+    }
+    else {
         cc_scan.peer_addr_type = 0;
         memset(cc_scan.peer_addr, 0, BLE_DEV_ADDR_LEN);
     }
@@ -851,11 +861,13 @@ ble_ll_conn_hci_ext_create(const uint8_t *cmdbuf, uint8_t len)
     /* Start scanning */
     rc = ble_ll_scan_initiator_start(connsm, 1, &cc_scan);
     if (rc) {
-        SLIST_REMOVE(&g_ble_ll_conn_active_list,connsm,ble_ll_conn_sm,act_sle);
+        SLIST_REMOVE(&g_ble_ll_conn_active_list, connsm, ble_ll_conn_sm,
+                     act_sle);
         STAILQ_INSERT_TAIL(&g_ble_ll_conn_free_list, connsm, free_stqe);
 #if MYNEWT_VAL(BLE_LL_CONN_STRICT_SCHED)
         if (ble_ll_sched_css_is_enabled()) {
-            SLIST_REMOVE(&g_ble_ll_conn_css_list, connsm, ble_ll_conn_sm, css_sle);
+            SLIST_REMOVE(&g_ble_ll_conn_css_list, connsm, ble_ll_conn_sm,
+                         css_sle);
         }
 #endif
     }
@@ -865,11 +877,12 @@ ble_ll_conn_hci_ext_create(const uint8_t *cmdbuf, uint8_t len)
 #endif
 
 static int
-ble_ll_conn_process_conn_params(const struct ble_hci_le_rem_conn_param_rr_cp *cmd,
-                                struct ble_ll_conn_sm *connsm)
+ble_ll_conn_process_conn_params(
+    const struct ble_hci_le_rem_conn_param_rr_cp* cmd,
+    struct ble_ll_conn_sm* connsm)
 {
     int rc;
-    struct hci_conn_update *hcu;
+    struct hci_conn_update* hcu;
 
     /* Retrieve command data */
     hcu = &connsm->conn_param_req;
@@ -885,8 +898,7 @@ ble_ll_conn_process_conn_params(const struct ble_hci_le_rem_conn_param_rr_cp *cm
     hcu->max_ce_len = le16toh(cmd->max_ce);
 
     /* Check that parameter values are in range */
-    rc = ble_ll_conn_hci_chk_conn_params(hcu->conn_itvl_min,
-                                         hcu->conn_itvl_max,
+    rc = ble_ll_conn_hci_chk_conn_params(hcu->conn_itvl_min, hcu->conn_itvl_max,
                                          hcu->conn_latency,
                                          hcu->supervision_timeout);
 
@@ -905,10 +917,10 @@ ble_ll_conn_process_conn_params(const struct ble_hci_le_rem_conn_param_rr_cp *cm
  * @return int
  */
 int
-ble_ll_conn_hci_read_rem_features(const uint8_t *cmdbuf, uint8_t len)
+ble_ll_conn_hci_read_rem_features(const uint8_t* cmdbuf, uint8_t len)
 {
-    const struct ble_hci_le_rd_rem_feat_cp *cmd = (const void *) cmdbuf;
-    struct ble_ll_conn_sm *connsm;
+    const struct ble_hci_le_rd_rem_feat_cp* cmd = (const void*)cmdbuf;
+    struct ble_ll_conn_sm* connsm;
 
     if (len != sizeof(*cmd)) {
         return BLE_ERR_INV_HCI_CMD_PARMS;
@@ -934,7 +946,7 @@ ble_ll_conn_hci_read_rem_features(const uint8_t *cmdbuf, uint8_t len)
 #if MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL)
         if ((connsm->conn_role == BLE_LL_CONN_ROLE_PERIPHERAL) &&
             !(ble_ll_read_supp_features() & BLE_LL_FEAT_PERIPH_INIT)) {
-                return BLE_ERR_CMD_DISALLOWED;
+            return BLE_ERR_CMD_DISALLOWED;
         }
 #endif
 
@@ -947,8 +959,8 @@ ble_ll_conn_hci_read_rem_features(const uint8_t *cmdbuf, uint8_t len)
 }
 
 static bool
-ble_ll_conn_params_in_range(struct ble_ll_conn_sm *connsm,
-                            const struct ble_hci_le_conn_update_cp *cmd)
+ble_ll_conn_params_in_range(struct ble_ll_conn_sm* connsm,
+                            const struct ble_hci_le_conn_update_cp* cmd)
 {
     if (!IN_RANGE(connsm->conn_itvl, le16toh(cmd->conn_itvl_min),
                   le16toh(cmd->conn_itvl_max))) {
@@ -967,9 +979,9 @@ ble_ll_conn_params_in_range(struct ble_ll_conn_sm *connsm,
 }
 
 static void
-ble_ll_conn_hci_update_complete_event(void *user_data)
+ble_ll_conn_hci_update_complete_event(void* user_data)
 {
-    struct ble_ll_conn_sm *connsm = user_data;
+    struct ble_ll_conn_sm* connsm = user_data;
 
     ble_ll_hci_ev_conn_update(connsm, BLE_ERR_SUCCESS);
 }
@@ -982,14 +994,14 @@ ble_ll_conn_hci_update_complete_event(void *user_data)
  * @return int
  */
 int
-ble_ll_conn_hci_update(const uint8_t *cmdbuf, uint8_t len)
+ble_ll_conn_hci_update(const uint8_t* cmdbuf, uint8_t len)
 {
-    const struct ble_hci_le_conn_update_cp *cmd = (const void *) cmdbuf;
+    const struct ble_hci_le_conn_update_cp* cmd = (const void*)cmdbuf;
     int rc;
     uint8_t ctrl_proc;
     uint16_t handle;
-    struct ble_ll_conn_sm *connsm;
-    struct hci_conn_update *hcu;
+    struct ble_ll_conn_sm* connsm;
+    struct hci_conn_update* hcu;
     uint16_t max_ce_len;
 
     /*
@@ -1021,9 +1033,11 @@ ble_ll_conn_hci_update(const uint8_t *cmdbuf, uint8_t len)
             return BLE_ERR_INV_HCI_CMD_PARMS;
         }
 
-        connsm->max_ce_len_ticks = ble_ll_tmr_u2t_up(max_ce_len * BLE_LL_CONN_CE_USECS);
+        connsm->max_ce_len_ticks =
+            ble_ll_tmr_u2t_up(max_ce_len * BLE_LL_CONN_CE_USECS);
 
-        ble_ll_hci_post_cmd_cb_set(ble_ll_conn_hci_update_complete_event, connsm);
+        ble_ll_hci_post_cmd_cb_set(ble_ll_conn_hci_update_complete_event,
+                                   connsm);
 
         return BLE_ERR_SUCCESS;
     }
@@ -1052,7 +1066,8 @@ ble_ll_conn_hci_update(const uint8_t *cmdbuf, uint8_t len)
         }
 #endif
         ctrl_proc = BLE_LL_CTRL_PROC_CONN_UPDATE;
-    } else {
+    }
+    else {
         ctrl_proc = BLE_LL_CTRL_PROC_CONN_PARAM_REQ;
     }
 
@@ -1076,7 +1091,7 @@ ble_ll_conn_hci_update(const uint8_t *cmdbuf, uint8_t len)
 #if MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL)
         case BLE_LL_CONN_ROLE_PERIPHERAL:
             return BLE_ERR_LMP_COLLISION;
-        break;
+            break;
 #endif
         default:
             BLE_LL_ASSERT(0);
@@ -1109,8 +1124,7 @@ ble_ll_conn_hci_update(const uint8_t *cmdbuf, uint8_t len)
     }
 
     /* Check that parameter values are in range */
-    rc = ble_ll_conn_hci_chk_conn_params(hcu->conn_itvl_min,
-                                         hcu->conn_itvl_max,
+    rc = ble_ll_conn_hci_chk_conn_params(hcu->conn_itvl_min, hcu->conn_itvl_max,
                                          hcu->conn_latency,
                                          hcu->supervision_timeout);
     if (!rc) {
@@ -1124,17 +1138,17 @@ ble_ll_conn_hci_update(const uint8_t *cmdbuf, uint8_t len)
 }
 
 int
-ble_ll_conn_hci_param_rr(const uint8_t *cmdbuf, uint8_t len,
-                         uint8_t *rspbuf, uint8_t *rsplen)
+ble_ll_conn_hci_param_rr(const uint8_t* cmdbuf, uint8_t len, uint8_t* rspbuf,
+                         uint8_t* rsplen)
 {
-    const struct ble_hci_le_rem_conn_param_rr_cp *cmd = (const void *) cmdbuf;
-    struct ble_hci_le_rem_conn_param_rr_rp *rsp = (void *) rspbuf;
+    const struct ble_hci_le_rem_conn_param_rr_cp* cmd = (const void*)cmdbuf;
+    struct ble_hci_le_rem_conn_param_rr_rp* rsp = (void*)rspbuf;
     int rc;
-    uint8_t *dptr;
+    uint8_t* dptr;
     uint8_t rsp_opcode;
     uint16_t handle;
-    struct os_mbuf *om;
-    struct ble_ll_conn_sm *connsm;
+    struct os_mbuf* om;
+    struct ble_ll_conn_sm* connsm;
 
     if (len != sizeof(*cmd)) {
         return BLE_ERR_INV_HCI_CMD_PARMS;
@@ -1172,7 +1186,8 @@ ble_ll_conn_hci_param_rr(const uint8_t *cmdbuf, uint8_t len,
                 len = g_ble_ll_ctrl_pkt_lengths[rsp_opcode] + 1;
                 ble_ll_conn_enqueue_pkt(connsm, om, BLE_LL_LLID_CTRL, len);
             }
-        } else {
+        }
+        else {
             /* XXX: check return code and deal */
             ble_ll_ctrl_reject_ind_send(connsm, connsm->host_reply_opcode,
                                         BLE_ERR_CONN_PARMS);
@@ -1193,12 +1208,12 @@ done:
 }
 
 int
-ble_ll_conn_hci_param_nrr(const uint8_t *cmdbuf, uint8_t len,
-                          uint8_t *rspbuf, uint8_t *rsplen)
+ble_ll_conn_hci_param_nrr(const uint8_t* cmdbuf, uint8_t len, uint8_t* rspbuf,
+                          uint8_t* rsplen)
 {
-    const struct ble_hci_le_rem_conn_params_nrr_cp *cmd = (const void *) cmdbuf;
-    struct ble_hci_le_rem_conn_params_nrr_rp *rsp = (void *) rspbuf;
-    struct ble_ll_conn_sm *connsm;
+    const struct ble_hci_le_rem_conn_params_nrr_cp* cmd = (const void*)cmdbuf;
+    struct ble_hci_le_rem_conn_params_nrr_rp* rsp = (void*)rspbuf;
+    struct ble_ll_conn_sm* connsm;
     uint16_t handle;
     int rc;
 
@@ -1247,7 +1262,7 @@ done:
  * safe to use g_ble_ll_conn_comp_ev
  */
 static void
-ble_ll_conn_hci_cancel_conn_complete_event(void *user_data)
+ble_ll_conn_hci_cancel_conn_complete_event(void* user_data)
 {
     BLE_LL_ASSERT(g_ble_ll_conn_comp_ev);
 
@@ -1268,7 +1283,7 @@ int
 ble_ll_conn_create_cancel(void)
 {
     int rc;
-    struct ble_ll_conn_sm *connsm;
+    struct ble_ll_conn_sm* connsm;
     os_sr_t sr;
 
     /*
@@ -1285,10 +1300,12 @@ ble_ll_conn_create_cancel(void)
         ble_ll_scan_sm_stop(1);
         ble_ll_conn_end(connsm, BLE_ERR_UNK_CONN_ID);
 
-        ble_ll_hci_post_cmd_cb_set(ble_ll_conn_hci_cancel_conn_complete_event, NULL);
+        ble_ll_hci_post_cmd_cb_set(ble_ll_conn_hci_cancel_conn_complete_event,
+                                   NULL);
 
         rc = BLE_ERR_SUCCESS;
-    } else {
+    }
+    else {
         /* If we are not attempting to create a connection*/
         rc = BLE_ERR_CMD_DISALLOWED;
     }
@@ -1307,11 +1324,11 @@ ble_ll_conn_create_cancel(void)
  * @return int
  */
 int
-ble_ll_conn_hci_disconnect_cmd(const struct ble_hci_lc_disconnect_cp *cmd)
+ble_ll_conn_hci_disconnect_cmd(const struct ble_hci_lc_disconnect_cp* cmd)
 {
     int rc;
     uint16_t handle;
-    struct ble_ll_conn_sm *connsm;
+    struct ble_ll_conn_sm* connsm;
 
     /* Check for valid parameters */
     handle = le16toh(cmd->conn_handle);
@@ -1332,7 +1349,8 @@ ble_ll_conn_hci_disconnect_cmd(const struct ble_hci_lc_disconnect_cp *cmd)
                 /* Do not allow command if we are in process of disconnecting */
                 if (connsm->disconnect_reason) {
                     rc = BLE_ERR_CMD_DISALLOWED;
-                } else {
+                }
+                else {
                     /* This control procedure better not be pending! */
                     BLE_LL_ASSERT(connsm->flags.terminate_started == 0);
 
@@ -1344,7 +1362,8 @@ ble_ll_conn_hci_disconnect_cmd(const struct ble_hci_lc_disconnect_cp *cmd)
 
                     rc = BLE_ERR_SUCCESS;
                 }
-            } else {
+            }
+            else {
                 rc = BLE_ERR_UNK_CONN_ID;
             }
             break;
@@ -1366,10 +1385,10 @@ ble_ll_conn_hci_disconnect_cmd(const struct ble_hci_lc_disconnect_cp *cmd)
  * @return int
  */
 int
-ble_ll_conn_hci_rd_rem_ver_cmd(const uint8_t *cmdbuf, uint8_t len)
+ble_ll_conn_hci_rd_rem_ver_cmd(const uint8_t* cmdbuf, uint8_t len)
 {
-    struct ble_ll_conn_sm *connsm;
-    const struct ble_hci_rd_rem_ver_info_cp *cmd = (const void *) cmdbuf;
+    struct ble_ll_conn_sm* connsm;
+    const struct ble_hci_rd_rem_ver_info_cp* cmd = (const void*)cmdbuf;
 
     if (len != sizeof(*cmd)) {
         return BLE_ERR_INV_HCI_CMD_PARMS;
@@ -1395,7 +1414,8 @@ ble_ll_conn_hci_rd_rem_ver_cmd(const uint8_t *cmdbuf, uint8_t len)
      */
     if (!connsm->flags.version_ind_txd) {
         ble_ll_ctrl_proc_start(connsm, BLE_LL_CTRL_PROC_VERSION_XCHG, NULL);
-    } else {
+    }
+    else {
         connsm->pending_ctrl_procs |= (1 << BLE_LL_CTRL_PROC_VERSION_XCHG);
     }
 
@@ -1412,12 +1432,13 @@ ble_ll_conn_hci_rd_rem_ver_cmd(const uint8_t *cmdbuf, uint8_t len)
  * @return int
  */
 int
-ble_ll_conn_hci_rd_rssi(const uint8_t *cmdbuf, uint8_t len, uint8_t *rspbuf, uint8_t *rsplen)
+ble_ll_conn_hci_rd_rssi(const uint8_t* cmdbuf, uint8_t len, uint8_t* rspbuf,
+                        uint8_t* rsplen)
 {
 
-    const struct ble_hci_rd_rssi_cp *cmd = (const void *) cmdbuf;
-    struct ble_hci_rd_rssi_rp *rsp = (void *) rspbuf;
-    struct ble_ll_conn_sm *connsm;
+    const struct ble_hci_rd_rssi_cp* cmd = (const void*)cmdbuf;
+    struct ble_hci_rd_rssi_rp* rsp = (void*)rspbuf;
+    struct ble_ll_conn_sm* connsm;
     int rc;
 
     if (len != sizeof(*cmd)) {
@@ -1430,7 +1451,8 @@ ble_ll_conn_hci_rd_rssi(const uint8_t *cmdbuf, uint8_t len, uint8_t *rspbuf, uin
     if (!connsm) {
         rsp->rssi = 127;
         rc = BLE_ERR_UNK_CONN_ID;
-    } else {
+    }
+    else {
         rsp->rssi = connsm->conn_rssi;
         rc = BLE_ERR_SUCCESS;
     }
@@ -1449,12 +1471,12 @@ ble_ll_conn_hci_rd_rssi(const uint8_t *cmdbuf, uint8_t len, uint8_t *rspbuf, uin
  * @return int
  */
 int
-ble_ll_conn_hci_rd_chan_map(const uint8_t *cmdbuf, uint8_t len,
-                            uint8_t *rspbuf, uint8_t *rsplen)
+ble_ll_conn_hci_rd_chan_map(const uint8_t* cmdbuf, uint8_t len, uint8_t* rspbuf,
+                            uint8_t* rsplen)
 {
-    const struct ble_hci_le_rd_chan_map_cp *cmd = (const void *) cmdbuf;
-    struct ble_hci_le_rd_chan_map_rp *rsp = (void *) rspbuf;
-    struct ble_ll_conn_sm *connsm;
+    const struct ble_hci_le_rd_chan_map_cp* cmd = (const void*)cmdbuf;
+    struct ble_hci_le_rd_chan_map_rp* rsp = (void*)rspbuf;
+    struct ble_ll_conn_sm* connsm;
     uint16_t handle;
     int rc;
 
@@ -1467,10 +1489,12 @@ ble_ll_conn_hci_rd_chan_map(const uint8_t *cmdbuf, uint8_t len,
     if (!connsm) {
         rc = BLE_ERR_UNK_CONN_ID;
         memset(rsp->chan_map, 0, sizeof(rsp->chan_map));
-    } else {
+    }
+    else {
         if (connsm->flags.chanmap_update_sched) {
             memcpy(rsp->chan_map, connsm->req_chanmap, BLE_LL_CHAN_MAP_LEN);
-        } else {
+        }
+        else {
             memcpy(rsp->chan_map, connsm->chan_map, BLE_LL_CHAN_MAP_LEN);
         }
         rc = BLE_ERR_SUCCESS;
@@ -1487,16 +1511,16 @@ ble_ll_conn_hci_rd_chan_map(const uint8_t *cmdbuf, uint8_t len,
 
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_DATA_LEN_EXT)
 int
-ble_ll_conn_hci_set_data_len(const uint8_t *cmdbuf, uint8_t len,
-                             uint8_t *rspbuf, uint8_t *rsplen)
+ble_ll_conn_hci_set_data_len(const uint8_t* cmdbuf, uint8_t len,
+                             uint8_t* rspbuf, uint8_t* rsplen)
 {
-    const struct ble_hci_le_set_data_len_cp *cmd = (const void *) cmdbuf;
-    struct ble_hci_le_set_data_len_rp *rsp = (void *) rspbuf;
+    const struct ble_hci_le_set_data_len_cp* cmd = (const void*)cmdbuf;
+    struct ble_hci_le_set_data_len_rp* rsp = (void*)rspbuf;
     int rc;
     uint16_t handle;
     uint16_t tx_octets;
     uint16_t tx_time;
-    struct ble_ll_conn_sm *connsm;
+    struct ble_ll_conn_sm* connsm;
 
     if (len != sizeof(*cmd)) {
         return BLE_ERR_INV_HCI_CMD_PARMS;
@@ -1537,10 +1561,10 @@ done:
  * @return int
  */
 int
-ble_ll_conn_hci_le_start_encrypt(const uint8_t *cmdbuf, uint8_t len)
+ble_ll_conn_hci_le_start_encrypt(const uint8_t* cmdbuf, uint8_t len)
 {
-    const struct ble_hci_le_start_encrypt_cp *cmd = (const void *) cmdbuf;
-    struct ble_ll_conn_sm *connsm;
+    const struct ble_hci_le_start_encrypt_cp* cmd = (const void*)cmdbuf;
+    struct ble_ll_conn_sm* connsm;
     int rc;
 
     if (len != sizeof(*cmd)) {
@@ -1551,17 +1575,20 @@ ble_ll_conn_hci_le_start_encrypt(const uint8_t *cmdbuf, uint8_t len)
     if (!connsm) {
         rc = BLE_ERR_UNK_CONN_ID;
 #if MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL)
-    } else if (connsm->conn_role == BLE_LL_CONN_ROLE_PERIPHERAL) {
+    }
+    else if (connsm->conn_role == BLE_LL_CONN_ROLE_PERIPHERAL) {
         rc = BLE_ERR_UNSPECIFIED;
 #endif
-    } else if (connsm->cur_ctrl_proc == BLE_LL_CTRL_PROC_ENCRYPT) {
+    }
+    else if (connsm->cur_ctrl_proc == BLE_LL_CTRL_PROC_ENCRYPT) {
         /*
          * The specification does not say what to do here but the host should
          * not be telling us to start encryption while we are in the process
          * of honoring a previous start encrypt.
          */
         rc = BLE_ERR_CMD_DISALLOWED;
-    } else {
+    }
+    else {
         /* Start the control procedure */
         connsm->enc_data.host_rand_num = le64toh(cmd->rand);
         connsm->enc_data.enc_div = le16toh(cmd->div);
@@ -1573,6 +1600,65 @@ ble_ll_conn_hci_le_start_encrypt(const uint8_t *cmdbuf, uint8_t len)
     return rc;
 }
 
+int
+ble_ll_conn_hci_le_start_rekey(const uint8_t* cmdbuf, uint8_t len)
+{
+    struct ble_ll_conn_sm* connsm;
+    struct ble_hci_le_f_encrypt* cmd = (struct ble_hci_le_f_encrypt*)cmdbuf;
+    int rc = 0;
+    connsm = ble_ll_conn_find_by_handle(le16toh(cmd->conn_handle));
+    if (!connsm) {
+        return BLE_ERR_UNK_CONN_ID;
+    }
+    // Encrypt the old session key with the DH Key to derive a fresh session key. Here just prepares the buffers
+    swap_buf(connsm->enc_data.enc_block.key, cmd->ltk, 16);
+#if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
+    if (connsm->conn_role == BLE_LL_CONN_ROLE_CENTRAL) {
+        // Central controls the process
+        rc = ble_ll_ctrl_rekey_req_send(connsm);
+    }
+#endif
+    return rc;
+}
+
+int
+ble_ll_conn_hci_le_start_encryption(const uint8_t* cmdbuf, uint8_t len)
+{
+    struct ble_hci_le_f_encrypt* cmd = (struct ble_hci_le_f_encrypt*)cmdbuf;
+    struct ble_ll_conn_sm* connsm;
+
+    if (len != sizeof(*cmd)) {
+        return BLE_ERR_INV_HCI_CMD_PARMS;
+    }
+    connsm = ble_ll_conn_find_by_handle(le16toh(cmd->conn_handle));
+    if (!connsm) {
+        return BLE_ERR_UNK_CONN_ID;
+    }
+
+    // printf("\nLE Start Encryption. LTK: ");
+    // for (int i = 0; i < 16; i++) {
+    //     printf("%02x", cmd->ltk[i]);
+    // }
+    // printf("\n");
+    memset(connsm->enc_data.iv, 0, 8);
+    swap_buf(connsm->enc_data.enc_block.cipher_text, cmd->ltk, 16);
+#if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
+    if (connsm->conn_role == BLE_LL_CONN_ROLE_CENTRAL) {
+        // We send this only if we are a central
+        return ble_ll_ctrl_f_enc_req_send(connsm);
+    }
+#endif
+
+#if MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL)
+    if (connsm->conn_role == BLE_LL_CONN_ROLE_PERIPHERAL) {
+        // We send this only if we are a peripheral
+        return BLE_ERR_SUCCESS;
+    }
+#endif
+
+    return BLE_ERR_UNSPECIFIED;
+}
+
 /**
  * Called to process the LE long term key reply.
  *
@@ -1585,12 +1671,12 @@ ble_ll_conn_hci_le_start_encrypt(const uint8_t *cmdbuf, uint8_t len)
  * @return int
  */
 int
-ble_ll_conn_hci_le_ltk_reply(const uint8_t *cmdbuf, uint8_t len,
-                             uint8_t *rspbuf, uint8_t *rsplen)
+ble_ll_conn_hci_le_ltk_reply(const uint8_t* cmdbuf, uint8_t len,
+                             uint8_t* rspbuf, uint8_t* rsplen)
 {
-    const struct ble_hci_le_lt_key_req_reply_cp *cmd = (const void *) cmdbuf;
-    struct ble_hci_le_lt_key_req_reply_rp *rsp = (void *) rspbuf;
-    struct ble_ll_conn_sm *connsm;
+    const struct ble_hci_le_lt_key_req_reply_cp* cmd = (const void*)cmdbuf;
+    struct ble_hci_le_lt_key_req_reply_rp* rsp = (void*)rspbuf;
+    struct ble_ll_conn_sm* connsm;
     uint16_t handle;
     int rc;
 
@@ -1644,12 +1730,12 @@ ltk_key_cmd_complete:
  * @return int
  */
 int
-ble_ll_conn_hci_le_ltk_neg_reply(const uint8_t *cmdbuf, uint8_t len,
-                                 uint8_t *rspbuf, uint8_t *rsplen)
+ble_ll_conn_hci_le_ltk_neg_reply(const uint8_t* cmdbuf, uint8_t len,
+                                 uint8_t* rspbuf, uint8_t* rsplen)
 {
-    const struct ble_hci_le_lt_key_req_neg_reply_cp *cmd = (const void *) cmdbuf;
-    struct ble_hci_le_lt_key_req_neg_reply_rp *rsp = (void *) rspbuf;
-    struct ble_ll_conn_sm *connsm;
+    const struct ble_hci_le_lt_key_req_neg_reply_cp* cmd = (const void*)cmdbuf;
+    struct ble_hci_le_lt_key_req_neg_reply_rp* rsp = (void*)rspbuf;
+    struct ble_ll_conn_sm* connsm;
     uint16_t handle;
     int rc;
 
@@ -1696,11 +1782,11 @@ ltk_key_cmd_complete:
 
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_SCA_UPDATE)
 int
-ble_ll_conn_req_peer_sca(const uint8_t *cmdbuf, uint8_t len,
-                         uint8_t *rspbuf, uint8_t *rsplen)
+ble_ll_conn_req_peer_sca(const uint8_t* cmdbuf, uint8_t len, uint8_t* rspbuf,
+                         uint8_t* rsplen)
 {
-    const struct ble_hci_le_request_peer_sca_cp *params = (const void *)cmdbuf;
-    struct ble_ll_conn_sm *connsm;
+    const struct ble_hci_le_request_peer_sca_cp* params = (const void*)cmdbuf;
+    struct ble_ll_conn_sm* connsm;
 
     connsm = ble_ll_conn_find_by_handle(le16toh(params->conn_handle));
     if (!connsm) {
@@ -1724,11 +1810,11 @@ ble_ll_conn_req_peer_sca(const uint8_t *cmdbuf, uint8_t len,
 
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_ENHANCED_CONN_UPDATE)
 int
-ble_ll_conn_hci_set_default_subrate(const uint8_t *cmdbuf, uint8_t len,
-                                    uint8_t *rspbuf, uint8_t *rsplen)
+ble_ll_conn_hci_set_default_subrate(const uint8_t* cmdbuf, uint8_t len,
+                                    uint8_t* rspbuf, uint8_t* rsplen)
 {
-    const struct ble_hci_le_set_default_subrate_cp *cp = (const void *)cmdbuf;
-    struct ble_ll_conn_global_params *gcp = &g_ble_ll_conn_params;
+    const struct ble_hci_le_set_default_subrate_cp* cp = (const void*)cmdbuf;
+    struct ble_ll_conn_global_params* gcp = &g_ble_ll_conn_params;
     uint16_t subrate_min;
     uint16_t subrate_max;
     uint16_t max_latency;
@@ -1770,12 +1856,12 @@ ble_ll_conn_hci_set_default_subrate(const uint8_t *cmdbuf, uint8_t len,
 }
 
 int
-ble_ll_conn_hci_subrate_req(const uint8_t *cmdbuf, uint8_t len,
-                            uint8_t *rspbuf, uint8_t *rsplen)
+ble_ll_conn_hci_subrate_req(const uint8_t* cmdbuf, uint8_t len, uint8_t* rspbuf,
+                            uint8_t* rsplen)
 {
-    const struct ble_hci_le_subrate_req_cp *cp = (const void *)cmdbuf;
+    const struct ble_hci_le_subrate_req_cp* cp = (const void*)cmdbuf;
     struct ble_ll_conn_subrate_req_params srp;
-    struct ble_ll_conn_sm *connsm;
+    struct ble_ll_conn_sm* connsm;
     uint16_t conn_handle;
     int rc;
 
@@ -1795,11 +1881,14 @@ ble_ll_conn_hci_subrate_req(const uint8_t *cmdbuf, uint8_t len,
     if (rc < 0) {
         if (rc == -EINVAL) {
             return BLE_ERR_INV_HCI_CMD_PARMS;
-        } else if (rc == -EBUSY) {
+        }
+        else if (rc == -EBUSY) {
             return BLE_ERR_CTLR_BUSY;
-        } else if (rc == -ENOTSUP) {
+        }
+        else if (rc == -ENOTSUP) {
             return BLE_ERR_UNSUPP_REM_FEATURE;
-        } else {
+        }
+        else {
             return BLE_ERR_UNSPECIFIED;
         }
     }
@@ -1828,16 +1917,15 @@ ble_ll_conn_hci_subrate_req(const uint8_t *cmdbuf, uint8_t len,
  * @return int
  */
 int
-ble_ll_conn_hci_rd_auth_pyld_tmo(const uint8_t *cmdbuf, uint8_t len,
-                                 uint8_t *rspbuf, uint8_t *rsplen)
+ble_ll_conn_hci_rd_auth_pyld_tmo(const uint8_t* cmdbuf, uint8_t len,
+                                 uint8_t* rspbuf, uint8_t* rsplen)
 {
-    const struct ble_hci_cb_rd_auth_pyld_tmo_cp *cmd = (const void *) cmdbuf;
-    struct ble_hci_cb_rd_auth_pyld_tmo_rp *rsp = (void *) rspbuf;
-    struct ble_ll_conn_sm *connsm;
+    const struct ble_hci_cb_rd_auth_pyld_tmo_cp* cmd = (const void*)cmdbuf;
+    struct ble_hci_cb_rd_auth_pyld_tmo_rp* rsp = (void*)rspbuf;
+    struct ble_ll_conn_sm* connsm;
     uint16_t handle;
     int rc;
 
-
     if (len != sizeof(*cmd)) {
         return BLE_ERR_INV_HCI_CMD_PARMS;
     }
@@ -1847,7 +1935,8 @@ ble_ll_conn_hci_rd_auth_pyld_tmo(const uint8_t *cmdbuf, uint8_t len,
     if (!connsm) {
         rc = BLE_ERR_UNK_CONN_ID;
         rsp->tmo = 0;
-    } else {
+    }
+    else {
         rc = BLE_ERR_SUCCESS;
         rsp->tmo = htole16(connsm->auth_pyld_tmo);
     }
@@ -1867,12 +1956,12 @@ ble_ll_conn_hci_rd_auth_pyld_tmo(const uint8_t *cmdbuf, uint8_t len,
  * @return int
  */
 int
-ble_ll_conn_hci_wr_auth_pyld_tmo(const uint8_t *cmdbuf, uint8_t len,
-                                 uint8_t *rspbuf, uint8_t *rsplen)
+ble_ll_conn_hci_wr_auth_pyld_tmo(const uint8_t* cmdbuf, uint8_t len,
+                                 uint8_t* rspbuf, uint8_t* rsplen)
 {
-    const struct ble_hci_cb_wr_auth_pyld_tmo_cp *cmd = (const void *) cmdbuf;
-    struct ble_hci_cb_wr_auth_pyld_tmo_rp *rsp = (void *) rspbuf;
-    struct ble_ll_conn_sm *connsm;
+    const struct ble_hci_cb_wr_auth_pyld_tmo_cp* cmd = (const void*)cmdbuf;
+    struct ble_hci_cb_wr_auth_pyld_tmo_rp* rsp = (void*)rspbuf;
+    struct ble_ll_conn_sm* connsm;
     uint32_t min_tmo;
     uint16_t handle;
     uint16_t tmo;
@@ -1889,7 +1978,8 @@ ble_ll_conn_hci_wr_auth_pyld_tmo(const uint8_t *cmdbuf, uint8_t len,
     connsm = ble_ll_conn_find_by_handle(handle);
     if (!connsm) {
         rc = BLE_ERR_UNK_CONN_ID;
-    } else {
+    }
+    else {
         /*
          * The timeout is in units of 10 msecs. We need to make sure that the
          * timeout is greater than or equal to connItvl * (1 + peripheralLatency)
@@ -1904,7 +1994,8 @@ ble_ll_conn_hci_wr_auth_pyld_tmo(const uint8_t *cmdbuf, uint8_t len,
 
         if (tmo < min_tmo) {
             rc = BLE_ERR_CMD_DISALLOWED;
-        } else {
+        }
+        else {
             connsm->auth_pyld_tmo = tmo;
             if (ble_npl_callout_is_active(&connsm->auth_pyld_timer)) {
                 ble_ll_conn_auth_pyld_timer_start(connsm);
@@ -1928,14 +2019,14 @@ ble_ll_conn_hci_wr_auth_pyld_tmo(const uint8_t *cmdbuf, uint8_t len,
  * @return int
  */
 int
-ble_ll_conn_hci_le_rd_phy(const uint8_t *cmdbuf, uint8_t len,
-                          uint8_t *rspbuf, uint8_t *rsplen)
+ble_ll_conn_hci_le_rd_phy(const uint8_t* cmdbuf, uint8_t len, uint8_t* rspbuf,
+                          uint8_t* rsplen)
 {
-    const struct ble_hci_le_rd_phy_cp *cmd = (const void *) cmdbuf;
-    struct ble_hci_le_rd_phy_rp *rsp = (void *) rspbuf;
+    const struct ble_hci_le_rd_phy_cp* cmd = (const void*)cmdbuf;
+    struct ble_hci_le_rd_phy_rp* rsp = (void*)rspbuf;
     int rc;
     uint16_t handle;
-    struct ble_ll_conn_sm *connsm;
+    struct ble_ll_conn_sm* connsm;
 
     if (len != sizeof(*cmd)) {
         return BLE_ERR_INV_HCI_CMD_PARMS;
@@ -1947,7 +2038,8 @@ ble_ll_conn_hci_le_rd_phy(const uint8_t *cmdbuf, uint8_t len,
         rsp->tx_phy = 0;
         rsp->rx_phy = 0;
         rc = BLE_ERR_UNK_CONN_ID;
-    } else {
+    }
+    else {
         rsp->tx_phy = connsm->phy_data.cur_tx_phy;
         rsp->rx_phy = connsm->phy_data.cur_rx_phy;
         rc = BLE_ERR_SUCCESS;
@@ -1967,15 +2059,15 @@ ble_ll_conn_hci_le_rd_phy(const uint8_t *cmdbuf, uint8_t len,
  * @return int
  */
 int
-ble_ll_conn_hci_le_set_phy(const uint8_t *cmdbuf, uint8_t len)
+ble_ll_conn_hci_le_set_phy(const uint8_t* cmdbuf, uint8_t len)
 {
-    const struct ble_hci_le_set_phy_cp *cmd = (const void *) cmdbuf;
+    const struct ble_hci_le_set_phy_cp* cmd = (const void*)cmdbuf;
     int rc;
     uint16_t phy_options;
     uint8_t tx_phys;
     uint8_t rx_phys;
     uint16_t handle;
-    struct ble_ll_conn_sm *connsm;
+    struct ble_ll_conn_sm* connsm;
 
     if (len != sizeof(*cmd)) {
         return BLE_ERR_INV_HCI_CMD_PARMS;
@@ -2023,7 +2115,8 @@ ble_ll_conn_hci_le_set_phy(const uint8_t *cmdbuf, uint8_t len)
             connsm->flags.phy_update_self_initiated = 0;
         }
         connsm->flags.phy_update_host_initiated = 1;
-    } else {
+    }
+    else {
         /*
          * We could be doing a peer-initiated PHY update procedure. If this
          * is the case the requested phy preferences will not both be 0. If
@@ -2033,11 +2126,13 @@ ble_ll_conn_hci_le_set_phy(const uint8_t *cmdbuf, uint8_t len)
         if (connsm->flags.phy_update_peer_initiated) {
             connsm->pending_ctrl_procs |= (1 << BLE_LL_CTRL_PROC_PHY_UPDATE);
             connsm->flags.phy_update_host_initiated = 1;
-        } else {
+        }
+        else {
             /* Check if we should start phy update procedure */
             if (!ble_ll_conn_phy_update_if_needed(connsm)) {
                 connsm->flags.phy_update_host_initiated = 1;
-            } else {
+            }
+            else {
                 /*
                  * Set flag to send a PHY update complete event. We set flag
                  * even if we do not do an update procedure since we have to
@@ -2055,12 +2150,13 @@ phy_cmd_param_err:
 
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_PERIODIC_ADV_SYNC_TRANSFER)
 int
-ble_ll_set_sync_transfer_params(const uint8_t *cmdbuf, uint8_t len,
-                                uint8_t *rspbuf, uint8_t *rsplen)
+ble_ll_set_sync_transfer_params(const uint8_t* cmdbuf, uint8_t len,
+                                uint8_t* rspbuf, uint8_t* rsplen)
 {
-    const struct ble_hci_le_periodic_adv_sync_transfer_params_cp *cmd = (const void *)cmdbuf;
-    struct ble_hci_le_periodic_adv_sync_transfer_params_rp *rsp = (void *) rspbuf;
-    struct ble_ll_conn_sm *connsm;
+    const struct ble_hci_le_periodic_adv_sync_transfer_params_cp* cmd =
+        (const void*)cmdbuf;
+    struct ble_hci_le_periodic_adv_sync_transfer_params_rp* rsp = (void*)rspbuf;
+    struct ble_ll_conn_sm* connsm;
     uint16_t sync_timeout;
     uint16_t skip;
     int rc;
@@ -2084,7 +2180,8 @@ ble_ll_set_sync_transfer_params(const uint8_t *cmdbuf, uint8_t len,
             rc = BLE_ERR_UNSUPPORTED;
             goto done;
         }
-    } else if (cmd->mode > 0x02) {
+    }
+    else if (cmd->mode > 0x02) {
         rc = BLE_ERR_INV_HCI_CMD_PARMS;
         goto done;
     }
@@ -2127,9 +2224,10 @@ done:
 }
 
 int
-ble_ll_set_default_sync_transfer_params(const uint8_t *cmdbuf, uint8_t len)
+ble_ll_set_default_sync_transfer_params(const uint8_t* cmdbuf, uint8_t len)
 {
-    const struct ble_hci_le_set_default_periodic_sync_transfer_params_cp *cmd = (const void *)cmdbuf;
+    const struct ble_hci_le_set_default_periodic_sync_transfer_params_cp* cmd =
+        (const void*)cmdbuf;
     uint16_t sync_timeout;
     uint16_t skip;
 
@@ -2149,7 +2247,8 @@ ble_ll_set_default_sync_transfer_params(const uint8_t *cmdbuf, uint8_t len)
              */
             return BLE_ERR_UNSUPPORTED;
         }
-    } else if (cmd->mode > 0x02) {
+    }
+    else if (cmd->mode > 0x02) {
         return BLE_ERR_INV_HCI_CMD_PARMS;
     }
 
diff --git a/nimble/controller/src/ble_ll_conn_priv.h b/nimble/controller/src/ble_ll_conn_priv.h
index 954a2766..e5d03621 100644
--- a/nimble/controller/src/ble_ll_conn_priv.h
+++ b/nimble/controller/src/ble_ll_conn_priv.h
@@ -31,36 +31,36 @@ extern "C" {
  * Definitions for min/max RX/TX time/bytes values allowed for connections.
  * Source: Core 5.0 specification, Vol 6, Part B, section 4.5.10
  */
-#define BLE_LL_CONN_SUPP_TIME_MIN           (328)   /* usecs */
-#define BLE_LL_CONN_SUPP_TIME_MAX           (17040) /* usecs */
-#define BLE_LL_CONN_SUPP_TIME_MIN_UNCODED   (328)   /* usecs */
-#define BLE_LL_CONN_SUPP_TIME_MAX_UNCODED   (2120)  /* usecs */
-#define BLE_LL_CONN_SUPP_TIME_MIN_CODED     (2704)  /* usecs */
-#define BLE_LL_CONN_SUPP_TIME_MAX_CODED     (17040) /* usecs */
-#define BLE_LL_CONN_SUPP_BYTES_MIN          (27)    /* bytes */
-#define BLE_LL_CONN_SUPP_BYTES_MAX          (251)   /* bytes */
+#define BLE_LL_CONN_SUPP_TIME_MIN (328)          /* usecs */
+#define BLE_LL_CONN_SUPP_TIME_MAX (17040)        /* usecs */
+#define BLE_LL_CONN_SUPP_TIME_MIN_UNCODED (328)  /* usecs */
+#define BLE_LL_CONN_SUPP_TIME_MAX_UNCODED (2120) /* usecs */
+#define BLE_LL_CONN_SUPP_TIME_MIN_CODED (2704)   /* usecs */
+#define BLE_LL_CONN_SUPP_TIME_MAX_CODED (17040)  /* usecs */
+#define BLE_LL_CONN_SUPP_BYTES_MIN (27)          /* bytes */
+#define BLE_LL_CONN_SUPP_BYTES_MAX (251)         /* bytes */
 
 /* Connection event timing */
-#define BLE_LL_CONN_INITIAL_OFFSET          (1250)
-#define BLE_LL_CONN_ITVL_USECS              (1250)
-#define BLE_LL_CONN_TX_WIN_USECS            (1250)
-#define BLE_LL_CONN_TX_OFF_USECS            (1250)
-#define BLE_LL_CONN_CE_USECS                (625)
-#define BLE_LL_CONN_TX_WIN_MIN              (1)         /* in tx win units */
-#define BLE_LL_CONN_PERIPH_LATENCY_MAX       (499)
+#define BLE_LL_CONN_INITIAL_OFFSET (1250)
+#define BLE_LL_CONN_ITVL_USECS (1250)
+#define BLE_LL_CONN_TX_WIN_USECS (1250)
+#define BLE_LL_CONN_TX_OFF_USECS (1250)
+#define BLE_LL_CONN_CE_USECS (625)
+#define BLE_LL_CONN_TX_WIN_MIN (1) /* in tx win units */
+#define BLE_LL_CONN_PERIPH_LATENCY_MAX (499)
 
 /* Connection handle range */
-#define BLE_LL_CONN_MAX_CONN_HANDLE         (0x0EFF)
+#define BLE_LL_CONN_MAX_CONN_HANDLE (0x0EFF)
 
 /* Offset (in bytes) of advertising address in connect request */
-#define BLE_LL_CONN_REQ_ADVA_OFF    (BLE_LL_PDU_HDR_LEN + BLE_DEV_ADDR_LEN)
+#define BLE_LL_CONN_REQ_ADVA_OFF (BLE_LL_PDU_HDR_LEN + BLE_DEV_ADDR_LEN)
 
 /* Default authenticated payload timeout (30 seconds; in 10 msecs increments) */
-#define BLE_LL_CONN_DEF_AUTH_PYLD_TMO       (3000)
-#define BLE_LL_CONN_AUTH_PYLD_OS_TMO(x)     ble_npl_time_ms_to_ticks32((x) * 10)
+#define BLE_LL_CONN_DEF_AUTH_PYLD_TMO (3000)
+#define BLE_LL_CONN_AUTH_PYLD_OS_TMO(x) ble_npl_time_ms_to_ticks32((x) * 10)
 
 #if MYNEWT_VAL(BLE_LL_CONN_STRICT_SCHED)
-#define BLE_LL_CONN_CSS_NO_SLOT             (UINT16_MAX)
+#define BLE_LL_CONN_CSS_NO_SLOT (UINT16_MAX)
 #endif
 
 /* Global Link Layer connection parameters */
@@ -93,9 +93,10 @@ struct ble_ll_conn_sync_transfer_params
 {
     uint32_t sync_timeout_us;
     uint16_t max_skip;
-    uint8_t  mode;
+    uint8_t mode;
 };
-extern struct ble_ll_conn_sync_transfer_params g_ble_ll_conn_sync_transfer_params;
+extern struct ble_ll_conn_sync_transfer_params
+    g_ble_ll_conn_sync_transfer_params;
 #endif
 
 /* Some data structures used by other LL routines */
@@ -109,7 +110,8 @@ SLIST_HEAD(ble_ll_conn_css_list, ble_ll_conn_sm);
 extern struct ble_ll_conn_css_list g_ble_ll_conn_css_list;
 #endif
 
-struct ble_ll_conn_create_scan {
+struct ble_ll_conn_create_scan
+{
     uint8_t filter_policy;
     uint8_t own_addr_type;
     uint8_t peer_addr_type;
@@ -117,13 +119,15 @@ struct ble_ll_conn_create_scan {
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_EXT_ADV)
     uint8_t init_phy_mask;
 #endif
-    struct {
+    struct
+    {
         uint16_t itvl;
         uint16_t window;
     } scan_params[2];
 };
 
-struct ble_ll_conn_create_params {
+struct ble_ll_conn_create_params
+{
     uint32_t conn_itvl;
     uint32_t conn_itvl_ticks;
     uint8_t conn_itvl_usecs;
@@ -133,15 +137,16 @@ struct ble_ll_conn_create_params {
     uint16_t max_ce_len;
 };
 
-struct ble_ll_conn_create_sm {
-    struct ble_ll_conn_sm *connsm;
+struct ble_ll_conn_create_sm
+{
+    struct ble_ll_conn_sm* connsm;
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_EXT_ADV)
     struct ble_ll_conn_create_params params[3];
 #endif
 };
 
 extern struct ble_ll_conn_create_sm g_ble_ll_conn_create_sm;
-extern struct ble_ll_conn_sm *g_ble_ll_conn_css_ref;
+extern struct ble_ll_conn_sm* g_ble_ll_conn_css_ref;
 
 /* Generic interface */
 struct ble_ll_len_req;
@@ -164,121 +169,186 @@ struct hci_create_conn
     uint16_t max_ce_len;
 };
 
-void ble_ll_conn_sm_new(struct ble_ll_conn_sm *connsm);
-void ble_ll_conn_end(struct ble_ll_conn_sm *connsm, uint8_t ble_err);
-void ble_ll_conn_enqueue_pkt(struct ble_ll_conn_sm *connsm, struct os_mbuf *om,
-                             uint8_t hdr_byte, uint16_t length);
-struct ble_ll_conn_sm *ble_ll_conn_sm_get(void);
-void ble_ll_conn_central_init(struct ble_ll_conn_sm *connsm,
-                              struct ble_ll_conn_create_scan *cc_scan,
-                              struct ble_ll_conn_create_params *cc_params);
-
-struct ble_ll_conn_sm *ble_ll_conn_find_by_handle(uint16_t handle);
-void ble_ll_conn_update_eff_data_len(struct ble_ll_conn_sm *connsm);
+void
+ble_ll_conn_sm_new(struct ble_ll_conn_sm* connsm);
+void
+ble_ll_conn_end(struct ble_ll_conn_sm* connsm, uint8_t ble_err);
+void
+ble_ll_conn_enqueue_pkt(struct ble_ll_conn_sm* connsm, struct os_mbuf* om,
+                        uint8_t hdr_byte, uint16_t length);
+struct ble_ll_conn_sm*
+ble_ll_conn_sm_get(void);
+void
+ble_ll_conn_central_init(struct ble_ll_conn_sm* connsm,
+                         struct ble_ll_conn_create_scan* cc_scan,
+                         struct ble_ll_conn_create_params* cc_params);
+
+struct ble_ll_conn_sm*
+ble_ll_conn_find_by_handle(uint16_t handle);
+void
+ble_ll_conn_update_eff_data_len(struct ble_ll_conn_sm* connsm);
 
 /* Advertising interface */
-int ble_ll_conn_periph_start(uint8_t *rxbuf, uint8_t pat,
-                             struct ble_mbuf_hdr *rxhdr, bool force_csa2);
+int
+ble_ll_conn_periph_start(uint8_t* rxbuf, uint8_t pat,
+                         struct ble_mbuf_hdr* rxhdr, bool force_csa2);
 
 /* Link Layer interface */
-void ble_ll_conn_module_init(void);
-void ble_ll_conn_module_reset(void);
-void ble_ll_conn_tx_pkt_in(struct os_mbuf *om, uint16_t handle, uint16_t len);
-int ble_ll_conn_rx_isr_start(struct ble_mbuf_hdr *rxhdr, uint32_t aa);
-int ble_ll_conn_rx_isr_end(uint8_t *rxbuf, struct ble_mbuf_hdr *rxhdr);
-void ble_ll_conn_rx_data_pdu(struct os_mbuf *rxpdu, struct ble_mbuf_hdr *hdr);
-void ble_ll_conn_wfr_timer_exp(void);
-int ble_ll_conn_is_lru(struct ble_ll_conn_sm *s1, struct ble_ll_conn_sm *s2);
-uint32_t ble_ll_conn_get_ce_end_time(void);
-void ble_ll_conn_event_halt(void);
+void
+ble_ll_conn_module_init(void);
+void
+ble_ll_conn_module_reset(void);
+void
+ble_ll_conn_tx_pkt_in(struct os_mbuf* om, uint16_t handle, uint16_t len);
+int
+ble_ll_conn_rx_isr_start(struct ble_mbuf_hdr* rxhdr, uint32_t aa);
+int
+ble_ll_conn_rx_isr_end(uint8_t* rxbuf, struct ble_mbuf_hdr* rxhdr);
+void
+ble_ll_conn_rx_data_pdu(struct os_mbuf* rxpdu, struct ble_mbuf_hdr* hdr);
+void
+ble_ll_conn_wfr_timer_exp(void);
+int
+ble_ll_conn_is_lru(struct ble_ll_conn_sm* s1, struct ble_ll_conn_sm* s2);
+uint32_t
+ble_ll_conn_get_ce_end_time(void);
+void
+ble_ll_conn_event_halt(void);
 /* HCI */
-void ble_ll_disconn_comp_event_send(struct ble_ll_conn_sm *connsm,
-                                    uint8_t reason);
-void ble_ll_auth_pyld_tmo_event_send(struct ble_ll_conn_sm *connsm);
-int ble_ll_conn_hci_disconnect_cmd(const struct ble_hci_lc_disconnect_cp *cmd);
-int ble_ll_conn_hci_rd_rem_ver_cmd(const uint8_t *cmdbuf, uint8_t len);
-int ble_ll_conn_hci_create(const uint8_t *cmdbuf, uint8_t len);
-int ble_ll_conn_hci_update(const uint8_t *cmdbuf, uint8_t len);
-int ble_ll_conn_hci_set_chan_class(const uint8_t *cmdbuf, uint8_t len);
-int ble_ll_conn_hci_param_rr(const uint8_t *cmdbuf, uint8_t len,
-                             uint8_t *rspbuf, uint8_t *rsplen);
-int ble_ll_conn_hci_param_nrr(const uint8_t *cmdbuf, uint8_t len,
-                             uint8_t *rspbuf, uint8_t *rsplen);
-int ble_ll_conn_create_cancel(void);
-void ble_ll_conn_num_comp_pkts_event_send(struct ble_ll_conn_sm *connsm);
-void ble_ll_conn_comp_event_send(struct ble_ll_conn_sm *connsm, uint8_t status,
-                                 uint8_t *evbuf, struct ble_ll_adv_sm *advsm);
-void ble_ll_conn_timeout(struct ble_ll_conn_sm *connsm, uint8_t ble_err);
-int ble_ll_conn_hci_chk_conn_params(uint16_t itvl_min, uint16_t itvl_max,
-                                    uint16_t latency, uint16_t spvn_tmo);
-int ble_ll_conn_hci_read_rem_features(const uint8_t *cmdbuf, uint8_t len);
-int ble_ll_conn_hci_rd_rssi(const uint8_t *cmdbuf, uint8_t len, uint8_t *rspbuf,
-                            uint8_t *rsplen);
-int ble_ll_conn_hci_rd_chan_map(const uint8_t *cmdbuf, uint8_t len,
-                                uint8_t *rspbuf, uint8_t *rsplen);
-int ble_ll_conn_hci_set_data_len(const uint8_t *cmdbuf, uint8_t len,
-                                 uint8_t *rspbuf, uint8_t *rsplen);
-int ble_ll_conn_hci_le_start_encrypt(const uint8_t *cmdbuf, uint8_t len);
-int ble_ll_conn_hci_le_ltk_reply(const uint8_t *cmdbuf, uint8_t len,
-                                 uint8_t *rspbuf, uint8_t *rsplen);
-int ble_ll_conn_hci_le_ltk_neg_reply(const uint8_t *cmdbuf, uint8_t len,
-                                     uint8_t *rspbuf, uint8_t *rsplen);
-int ble_ll_conn_hci_wr_auth_pyld_tmo(const uint8_t *cmdbuf, uint8_t len,
-                                     uint8_t *rspbuf, uint8_t *rsplen);
-int ble_ll_conn_hci_rd_auth_pyld_tmo(const uint8_t *cmdbuf, uint8_t len,
-                                     uint8_t *rspbuf, uint8_t *rsplen);
+void
+ble_ll_disconn_comp_event_send(struct ble_ll_conn_sm* connsm, uint8_t reason);
+void
+ble_ll_auth_pyld_tmo_event_send(struct ble_ll_conn_sm* connsm);
+int
+ble_ll_conn_hci_disconnect_cmd(const struct ble_hci_lc_disconnect_cp* cmd);
+int
+ble_ll_conn_hci_rd_rem_ver_cmd(const uint8_t* cmdbuf, uint8_t len);
+int
+ble_ll_conn_hci_create(const uint8_t* cmdbuf, uint8_t len);
+int
+ble_ll_conn_hci_update(const uint8_t* cmdbuf, uint8_t len);
+int
+ble_ll_conn_hci_set_chan_class(const uint8_t* cmdbuf, uint8_t len);
+int
+ble_ll_conn_hci_param_rr(const uint8_t* cmdbuf, uint8_t len, uint8_t* rspbuf,
+                         uint8_t* rsplen);
+int
+ble_ll_conn_hci_param_nrr(const uint8_t* cmdbuf, uint8_t len, uint8_t* rspbuf,
+                          uint8_t* rsplen);
+int
+ble_ll_conn_create_cancel(void);
+void
+ble_ll_conn_num_comp_pkts_event_send(struct ble_ll_conn_sm* connsm);
+void
+ble_ll_conn_comp_event_send(struct ble_ll_conn_sm* connsm, uint8_t status,
+                            uint8_t* evbuf, struct ble_ll_adv_sm* advsm);
+void
+ble_ll_conn_timeout(struct ble_ll_conn_sm* connsm, uint8_t ble_err);
+int
+ble_ll_conn_hci_chk_conn_params(uint16_t itvl_min, uint16_t itvl_max,
+                                uint16_t latency, uint16_t spvn_tmo);
+int
+ble_ll_conn_hci_read_rem_features(const uint8_t* cmdbuf, uint8_t len);
+int
+ble_ll_conn_hci_rd_rssi(const uint8_t* cmdbuf, uint8_t len, uint8_t* rspbuf,
+                        uint8_t* rsplen);
+int
+ble_ll_conn_hci_rd_chan_map(const uint8_t* cmdbuf, uint8_t len, uint8_t* rspbuf,
+                            uint8_t* rsplen);
+int
+ble_ll_conn_hci_set_data_len(const uint8_t* cmdbuf, uint8_t len,
+                             uint8_t* rspbuf, uint8_t* rsplen);
+int
+ble_ll_conn_hci_le_start_encrypt(const uint8_t* cmdbuf, uint8_t len);
+int
+ble_ll_conn_hci_le_start_encryption(const uint8_t* cmdbuf, uint8_t len);
+
+int
+ble_ll_conn_hci_le_start_rekey(const uint8_t* cmdbuf, uint8_t len);
+int
+ble_ll_conn_hci_le_ltk_reply(const uint8_t* cmdbuf, uint8_t len,
+                             uint8_t* rspbuf, uint8_t* rsplen);
+int
+ble_ll_conn_hci_le_ltk_neg_reply(const uint8_t* cmdbuf, uint8_t len,
+                                 uint8_t* rspbuf, uint8_t* rsplen);
+int
+ble_ll_conn_hci_wr_auth_pyld_tmo(const uint8_t* cmdbuf, uint8_t len,
+                                 uint8_t* rspbuf, uint8_t* rsplen);
+int
+ble_ll_conn_hci_rd_auth_pyld_tmo(const uint8_t* cmdbuf, uint8_t len,
+                                 uint8_t* rspbuf, uint8_t* rsplen);
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_SCA_UPDATE)
-int ble_ll_conn_req_peer_sca(const uint8_t *cmdbuf, uint8_t len,
-                             uint8_t *rspbuf, uint8_t *rsplen);
+int
+ble_ll_conn_req_peer_sca(const uint8_t* cmdbuf, uint8_t len, uint8_t* rspbuf,
+                         uint8_t* rsplen);
 #endif
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_ENHANCED_CONN_UPDATE)
-int ble_ll_conn_hci_set_default_subrate(const uint8_t *cmdbuf, uint8_t len,
-                                        uint8_t *rspbuf, uint8_t *rsplen);
-int ble_ll_conn_hci_subrate_req(const uint8_t *cmdbuf, uint8_t len,
-                                uint8_t *rspbuf, uint8_t *rsplen);
+int
+ble_ll_conn_hci_set_default_subrate(const uint8_t* cmdbuf, uint8_t len,
+                                    uint8_t* rspbuf, uint8_t* rsplen);
+int
+ble_ll_conn_hci_subrate_req(const uint8_t* cmdbuf, uint8_t len, uint8_t* rspbuf,
+                            uint8_t* rsplen);
 #endif
 
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LE_PING)
-void ble_ll_conn_auth_pyld_timer_start(struct ble_ll_conn_sm *connsm);
-void ble_ll_conn_auth_pyld_timer_cb(struct ble_npl_event *ev);
+void
+ble_ll_conn_auth_pyld_timer_start(struct ble_ll_conn_sm* connsm);
+void
+ble_ll_conn_auth_pyld_timer_cb(struct ble_npl_event* ev);
 #else
 #define ble_ll_conn_auth_pyld_timer_start(x)
 #endif
 
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_CTRL_TO_HOST_FLOW_CONTROL)
-void ble_ll_conn_cth_flow_set_buffers(uint16_t num_buffers);
-bool ble_ll_conn_cth_flow_enable(bool enabled);
-void ble_ll_conn_cth_flow_process_cmd(const uint8_t *cmdbuf);
+void
+ble_ll_conn_cth_flow_set_buffers(uint16_t num_buffers);
+bool
+ble_ll_conn_cth_flow_enable(bool enabled);
+void
+ble_ll_conn_cth_flow_process_cmd(const uint8_t* cmdbuf);
 #endif
 
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_DATA_LEN_EXT)
-int ble_ll_conn_set_data_len(struct ble_ll_conn_sm *connsm,
-                             uint16_t tx_octets, uint16_t tx_time,
-                             uint16_t rx_octets, uint16_t rx_time);
+int
+ble_ll_conn_set_data_len(struct ble_ll_conn_sm* connsm, uint16_t tx_octets,
+                         uint16_t tx_time, uint16_t rx_octets,
+                         uint16_t rx_time);
 #endif
 
-void ble_ll_conn_itvl_to_ticks(uint32_t itvl,
-                               uint32_t *itvl_ticks, uint8_t *itvl_usecs);
-
-int ble_ll_conn_hci_le_rd_phy(const uint8_t *cmdbuf, uint8_t len,
-                              uint8_t *rsp, uint8_t *rsplen);
-int ble_ll_conn_hci_le_set_phy(const uint8_t *cmdbuf, uint8_t len);
-int ble_ll_conn_phy_update_if_needed(struct ble_ll_conn_sm *connsm);
+void
+ble_ll_conn_itvl_to_ticks(uint32_t itvl, uint32_t* itvl_ticks,
+                          uint8_t* itvl_usecs);
+
+int
+ble_ll_conn_hci_le_rd_phy(const uint8_t* cmdbuf, uint8_t len, uint8_t* rsp,
+                          uint8_t* rsplen);
+int
+ble_ll_conn_hci_le_set_phy(const uint8_t* cmdbuf, uint8_t len);
+int
+ble_ll_conn_phy_update_if_needed(struct ble_ll_conn_sm* connsm);
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_EXT_ADV)
-int ble_ll_conn_hci_ext_create(const uint8_t *cmdbuf, uint8_t len);
+int
+ble_ll_conn_hci_ext_create(const uint8_t* cmdbuf, uint8_t len);
 #endif
 
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_PERIODIC_ADV_SYNC_TRANSFER)
-int ble_ll_set_sync_transfer_params(const uint8_t *cmdbuf, uint8_t len,
-                                    uint8_t *rspbuf, uint8_t *rsplen);
-int ble_ll_set_default_sync_transfer_params(const uint8_t *cmdbuf, uint8_t len);
+int
+ble_ll_set_sync_transfer_params(const uint8_t* cmdbuf, uint8_t len,
+                                uint8_t* rspbuf, uint8_t* rsplen);
+int
+ble_ll_set_default_sync_transfer_params(const uint8_t* cmdbuf, uint8_t len);
 #endif
 
 #if MYNEWT_VAL(BLE_LL_CONN_STRICT_SCHED)
-void ble_ll_conn_css_set_next_slot(uint16_t slot_idx);
-uint16_t ble_ll_conn_css_get_next_slot(void);
-int ble_ll_conn_css_is_slot_busy(uint16_t slot_idx);
-int ble_ll_conn_css_move(struct ble_ll_conn_sm *connsm, uint16_t slot_idx);
+void
+ble_ll_conn_css_set_next_slot(uint16_t slot_idx);
+uint16_t
+ble_ll_conn_css_get_next_slot(void);
+int
+ble_ll_conn_css_is_slot_busy(uint16_t slot_idx);
+int
+ble_ll_conn_css_move(struct ble_ll_conn_sm* connsm, uint16_t slot_idx);
 
 #endif
 
diff --git a/nimble/controller/src/ble_ll_ctrl.c b/nimble/controller/src/ble_ll_ctrl.c
index 6902ba49..43bb23ec 100644
--- a/nimble/controller/src/ble_ll_ctrl.c
+++ b/nimble/controller/src/ble_ll_ctrl.c
@@ -34,7 +34,7 @@
 #include "controller/ble_ll_tmr.h"
 #include "ble_ll_conn_priv.h"
 
-#if MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL) || MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
+#if MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL) || MYNEWT_VAL(BLE_LL_ROLE_CENTRAL) || 1
 
 /* To use spec sample data for testing */
 #undef BLE_LL_ENCRYPT_USE_TEST_DATA
@@ -84,8 +84,7 @@
  * control PDU, so total data channel payload length for the control pdu is
  * one greater.
  */
-const uint8_t g_ble_ll_ctrl_pkt_lengths[BLE_LL_CTRL_OPCODES] =
-{
+const uint8_t g_ble_ll_ctrl_pkt_lengths[BLE_LL_CTRL_OPCODES] = {
     BLE_LL_CTRL_CONN_UPD_REQ_LEN,
     BLE_LL_CTRL_CHAN_MAP_LEN,
     BLE_LL_CTRL_TERMINATE_IND_LEN,
@@ -128,6 +127,10 @@ const uint8_t g_ble_ll_ctrl_pkt_lengths[BLE_LL_CTRL_OPCODES] =
     BLE_LL_CTRL_SUBRATE_IND_LEN,
     BLE_LL_CTRL_CHAN_REPORTING_IND_LEN,
     BLE_LL_CTRL_CHAN_STATUS_IND_LEN,
+    BLE_LL_CTRL_ENC_F_REQ_LEN,
+    BLE_LL_CTRL_ENC_F_RSP_LEN,
+    BLE_LL_CTRL_REKEY_REQ_LEN,
+    BLE_LL_CTRL_REKEY_RSP_LEN,
 };
 
 /**
@@ -144,7 +147,7 @@ const uint8_t g_ble_ll_ctrl_pkt_lengths[BLE_LL_CTRL_OPCODES] =
  * @return uint8_t
  */
 uint8_t
-ble_ll_ctrl_proc_with_instant_initiated(struct ble_ll_conn_sm *connsm,
+ble_ll_ctrl_proc_with_instant_initiated(struct ble_ll_conn_sm* connsm,
                                         uint8_t req_ctrl_proc)
 {
     uint8_t err;
@@ -156,10 +159,12 @@ ble_ll_ctrl_proc_with_instant_initiated(struct ble_ll_conn_sm *connsm,
     case BLE_LL_CTRL_PROC_CHAN_MAP_UPD:
         if (req_ctrl_proc == connsm->cur_ctrl_proc) {
             err = BLE_ERR_LMP_COLLISION;
-        } else if ((connsm->cur_ctrl_proc == BLE_LL_CTRL_PROC_CONN_UPDATE) &&
-                   (req_ctrl_proc == BLE_LL_CTRL_PROC_CONN_PARAM_REQ)) {
+        }
+        else if ((connsm->cur_ctrl_proc == BLE_LL_CTRL_PROC_CONN_UPDATE) &&
+                 (req_ctrl_proc == BLE_LL_CTRL_PROC_CONN_PARAM_REQ)) {
             err = BLE_ERR_LMP_COLLISION;
-        } else {
+        }
+        else {
             err = BLE_ERR_DIFF_TRANS_COLL;
         }
         break;
@@ -178,7 +183,7 @@ ble_ll_ctrl_proc_with_instant_initiated(struct ble_ll_conn_sm *connsm,
  * @param ctrdata: Pointer to where CtrData starts in pdu
  */
 void
-ble_ll_ctrl_rej_ext_ind_make(uint8_t rej_opcode, uint8_t err, uint8_t *ctrdata)
+ble_ll_ctrl_rej_ext_ind_make(uint8_t rej_opcode, uint8_t err, uint8_t* ctrdata)
 {
     ctrdata[0] = rej_opcode;
     ctrdata[1] = err;
@@ -192,7 +197,7 @@ ble_ll_ctrl_rej_ext_ind_make(uint8_t rej_opcode, uint8_t err, uint8_t *ctrdata)
  * @param ble_err
  */
 void
-ble_ll_ctrl_phy_update_cancel(struct ble_ll_conn_sm *connsm, uint8_t ble_err)
+ble_ll_ctrl_phy_update_cancel(struct ble_ll_conn_sm* connsm, uint8_t ble_err)
 {
     /* cancel any pending phy update procedures */
     CLR_PENDING_CTRL_PROC(connsm, BLE_LL_CTRL_PROC_PHY_UPDATE);
@@ -209,7 +214,7 @@ ble_ll_ctrl_phy_update_cancel(struct ble_ll_conn_sm *connsm, uint8_t ble_err)
 #endif
 
 static int
-ble_ll_ctrl_len_proc(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
+ble_ll_ctrl_len_proc(struct ble_ll_conn_sm* connsm, uint8_t* dptr)
 {
     int rc;
     struct ble_ll_len_req ctrl_req;
@@ -225,7 +230,8 @@ ble_ll_ctrl_len_proc(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
         (ctrl_req.max_tx_bytes < BLE_LL_CONN_SUPP_BYTES_MIN) ||
         (ctrl_req.max_tx_time < BLE_LL_CONN_SUPP_TIME_MIN)) {
         rc = 1;
-    } else {
+    }
+    else {
         /* Update parameters */
         connsm->rem_max_rx_time = ctrl_req.max_rx_time;
         connsm->rem_max_tx_time = ctrl_req.max_tx_time;
@@ -249,7 +255,7 @@ ble_ll_ctrl_len_proc(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
  * @param connsm
  */
 static void
-ble_ll_ctrl_rx_ping_rsp(struct ble_ll_conn_sm *connsm)
+ble_ll_ctrl_rx_ping_rsp(struct ble_ll_conn_sm* connsm)
 {
     /* Stop the control procedure */
     ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_LE_PING);
@@ -266,15 +272,15 @@ ble_ll_ctrl_rx_ping_rsp(struct ble_ll_conn_sm *connsm)
  * @return int
  */
 static int
-ble_ll_ctrl_conn_param_pdu_proc(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
-                                uint8_t *rspbuf, uint8_t opcode)
+ble_ll_ctrl_conn_param_pdu_proc(struct ble_ll_conn_sm* connsm, uint8_t* dptr,
+                                uint8_t* rspbuf, uint8_t opcode)
 {
     int rc;
     int indicate;
     uint8_t rsp_opcode;
     uint8_t ble_err;
-    struct ble_ll_conn_params *req;
-    struct hci_conn_update *hcu;
+    struct ble_ll_conn_params* req;
+    struct hci_conn_update* hcu;
 
     /* Extract parameters and check if valid */
     req = &connsm->conn_cp;
@@ -283,7 +289,7 @@ ble_ll_ctrl_conn_param_pdu_proc(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
     req->latency = get_le16(dptr + 4);
     req->timeout = get_le16(dptr + 6);
     req->pref_periodicity = dptr[8];
-    req->ref_conn_event_cnt  = get_le16(dptr + 9);
+    req->ref_conn_event_cnt = get_le16(dptr + 9);
     req->offset0 = get_le16(dptr + 11);
     req->offset1 = get_le16(dptr + 13);
     req->offset2 = get_le16(dptr + 15);
@@ -293,10 +299,8 @@ ble_ll_ctrl_conn_param_pdu_proc(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
 
     /* Check if parameters are valid */
     ble_err = BLE_ERR_SUCCESS;
-    rc = ble_ll_conn_hci_chk_conn_params(req->interval_min,
-                                         req->interval_max,
-                                         req->latency,
-                                         req->timeout);
+    rc = ble_ll_conn_hci_chk_conn_params(req->interval_min, req->interval_max,
+                                         req->latency, req->timeout);
     if (rc) {
         ble_err = BLE_ERR_INV_LMP_LL_PARM;
         goto conn_param_pdu_exit;
@@ -356,7 +360,8 @@ conn_parm_req_do_indicate:
         /* If Host masked out Remote Connection Parameter Request Event, we need to
          * send Reject back to the remote device
          */
-        if (!ble_ll_hci_is_le_event_enabled(BLE_HCI_LE_SUBEV_REM_CONN_PARM_REQ)){
+        if (!ble_ll_hci_is_le_event_enabled(
+                BLE_HCI_LE_SUBEV_REM_CONN_PARM_REQ)) {
             ble_err = BLE_ERR_UNSUPP_REM_FEATURE;
             goto conn_param_pdu_exit;
         }
@@ -369,7 +374,8 @@ conn_parm_req_do_indicate:
         connsm->host_reply_opcode = opcode;
         connsm->flags.conn_update_host_w4reply = 1;
         rsp_opcode = 255;
-    } else {
+    }
+    else {
         /* Create reply to connection request */
         rsp_opcode = ble_ll_ctrl_conn_param_reply(connsm, rspbuf, req);
     }
@@ -384,8 +390,8 @@ conn_param_pdu_exit:
 }
 
 static void
-ble_ll_ctrl_conn_update_init_proc(struct ble_ll_conn_sm *connsm,
-                                  struct ble_ll_conn_params *cp)
+ble_ll_ctrl_conn_update_init_proc(struct ble_ll_conn_sm* connsm,
+                                  struct ble_ll_conn_params* cp)
 {
     /* This only stores conn params, if any. The caller will enqueue LL Control
      * PDU and we will calculate its contents when dequeued so we know that
@@ -401,18 +407,18 @@ ble_ll_ctrl_conn_update_init_proc(struct ble_ll_conn_sm *connsm,
 }
 
 static void
-ble_ll_ctrl_conn_update_make_ind_pdu(struct ble_ll_conn_sm *connsm,
-                                     uint8_t *ctrdata)
+ble_ll_ctrl_conn_update_make_ind_pdu(struct ble_ll_conn_sm* connsm,
+                                     uint8_t* ctrdata)
 {
-    struct ble_ll_conn_params *cp = NULL;
-    struct ble_ll_conn_params offset_cp = { };
+    struct ble_ll_conn_params* cp = NULL;
+    struct ble_ll_conn_params offset_cp = {};
     uint16_t instant;
     uint32_t dt;
     uint32_t num_old_ce;
     uint32_t new_itvl_usecs;
     uint32_t old_itvl_usecs;
-    struct hci_conn_update *hcu;
-    struct ble_ll_conn_upd_req *req;
+    struct hci_conn_update* hcu;
+    struct ble_ll_conn_upd_req* req;
 
     if (connsm->flags.conn_update_use_cp) {
         cp = &connsm->conn_cp;
@@ -426,8 +432,8 @@ ble_ll_ctrl_conn_update_make_ind_pdu(struct ble_ll_conn_sm *connsm,
      * minimum as per the spec of 6 connection events.
      */
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_ENHANCED_CONN_UPDATE)
-    instant = connsm->subrate_base_event + 6 * connsm->subrate_factor *
-                                           (connsm->periph_latency + 1);
+    instant = connsm->subrate_base_event +
+              6 * connsm->subrate_factor * (connsm->periph_latency + 1);
 #else
     instant = connsm->event_cntr + connsm->periph_latency + 6 + 1;
 #endif
@@ -464,7 +470,8 @@ ble_ll_ctrl_conn_update_make_ind_pdu(struct ble_ll_conn_sm *connsm,
                 dt = old_itvl_usecs * num_old_ce;
                 dt += (cp->offset0 * BLE_LL_CONN_ITVL_USECS);
                 dt = dt % new_itvl_usecs;
-            } else {
+            }
+            else {
                 num_old_ce = instant - cp->ref_conn_event_cnt;
                 dt = old_itvl_usecs * num_old_ce;
                 dt -= (cp->offset0 * BLE_LL_CONN_ITVL_USECS);
@@ -472,14 +479,16 @@ ble_ll_ctrl_conn_update_make_ind_pdu(struct ble_ll_conn_sm *connsm,
                 dt = new_itvl_usecs - dt;
             }
             req->winoffset = dt / BLE_LL_CONN_TX_WIN_USECS;
-        } else {
+        }
+        else {
             req->winoffset = 0;
         }
         req->interval = cp->interval_max;
         req->timeout = cp->timeout;
         req->latency = cp->latency;
         req->winsize = 1;
-    } else {
+    }
+    else {
         req->interval = hcu->conn_itvl_max;
         req->timeout = hcu->supervision_timeout;
         req->latency = hcu->conn_latency;
@@ -505,7 +514,8 @@ ble_ll_ctrl_conn_update_make_ind_pdu(struct ble_ll_conn_sm *connsm,
  * @param dptr
  */
 static int
-ble_ll_ctrl_proc_unk_rsp(struct ble_ll_conn_sm *connsm, uint8_t *dptr, uint8_t *rspdata)
+ble_ll_ctrl_proc_unk_rsp(struct ble_ll_conn_sm* connsm, uint8_t* dptr,
+                         uint8_t* rspdata)
 {
     uint8_t ctrl_proc;
     uint8_t opcode;
@@ -569,10 +579,11 @@ ble_ll_ctrl_proc_unk_rsp(struct ble_ll_conn_sm *connsm, uint8_t *dptr, uint8_t *
         ble_ll_ctrl_proc_stop(connsm, ctrl_proc);
         if (ctrl_proc == BLE_LL_CTRL_PROC_CONN_PARAM_REQ) {
             ble_ll_hci_ev_conn_update(connsm, BLE_ERR_UNSUPP_REM_FEATURE);
-        } else if (ctrl_proc == BLE_LL_CTRL_PROC_FEATURE_XCHG) {
+        }
+        else if (ctrl_proc == BLE_LL_CTRL_PROC_FEATURE_XCHG) {
             if (connsm->flags.features_host_req) {
                 ble_ll_hci_ev_rd_rem_used_feat(connsm,
-                                                   BLE_ERR_UNSUPP_REM_FEATURE);
+                                               BLE_ERR_UNSUPP_REM_FEATURE);
             }
             connsm->flags.features_host_req = 0;
         }
@@ -591,19 +602,20 @@ ble_ll_ctrl_proc_unk_rsp(struct ble_ll_conn_sm *connsm, uint8_t *dptr, uint8_t *
  * @param arg Pointer to connection state machine.
  */
 static void
-ble_ll_ctrl_proc_rsp_timer_cb(struct ble_npl_event *ev)
+ble_ll_ctrl_proc_rsp_timer_cb(struct ble_npl_event* ev)
 {
     /* Control procedure has timed out. Kill the connection */
-    ble_ll_conn_timeout((struct ble_ll_conn_sm *)ble_npl_event_get_arg(ev),
+    ble_ll_conn_timeout((struct ble_ll_conn_sm*)ble_npl_event_get_arg(ev),
                         BLE_ERR_LMP_LL_RSP_TMO);
 }
 
 static void
-ble_ll_ctrl_start_rsp_timer(struct ble_ll_conn_sm *connsm)
+ble_ll_ctrl_start_rsp_timer(struct ble_ll_conn_sm* connsm)
 {
     /* Re-start timer. Control procedure timeout is 40 seconds */
-    ble_npl_callout_reset(&connsm->ctrl_proc_rsp_timer,
-                     ble_npl_time_ms_to_ticks32(BLE_LL_CTRL_PROC_TIMEOUT_MS));
+    ble_npl_callout_reset(
+        &connsm->ctrl_proc_rsp_timer,
+        ble_npl_time_ms_to_ticks32(BLE_LL_CTRL_PROC_TIMEOUT_MS));
 }
 
 /**
@@ -639,13 +651,16 @@ ble_ll_ctrl_phy_from_phy_mask(uint8_t phy_mask)
     if (phy_mask & BLE_PHY_MASK_1M) {
         phy = BLE_PHY_1M;
         phy_mask &= ~BLE_PHY_MASK_1M;
-    } else if (phy_mask & BLE_PHY_MASK_2M) {
+    }
+    else if (phy_mask & BLE_PHY_MASK_2M) {
         phy = BLE_PHY_2M;
         phy_mask &= ~BLE_PHY_MASK_2M;
-    } else if (phy_mask & BLE_PHY_MASK_CODED) {
+    }
+    else if (phy_mask & BLE_PHY_MASK_CODED) {
         phy = BLE_PHY_CODED;
         phy_mask &= ~BLE_PHY_MASK_CODED;
-    } else {
+    }
+    else {
         phy = 0;
     }
 
@@ -667,9 +682,11 @@ ble_ll_ctrl_phy_tx_transition_get(uint8_t phy_mask)
      */
     if (phy_mask & BLE_PHY_MASK_CODED) {
         return BLE_PHY_CODED;
-    } else if (phy_mask & BLE_PHY_MASK_1M) {
+    }
+    else if (phy_mask & BLE_PHY_MASK_1M) {
         return BLE_PHY_1M;
-    } else if (phy_mask & BLE_PHY_MASK_2M) {
+    }
+    else if (phy_mask & BLE_PHY_MASK_2M) {
         return BLE_PHY_2M;
     }
 
@@ -677,7 +694,7 @@ ble_ll_ctrl_phy_tx_transition_get(uint8_t phy_mask)
 }
 
 void
-ble_ll_ctrl_phy_update_proc_complete(struct ble_ll_conn_sm *connsm)
+ble_ll_ctrl_phy_update_proc_complete(struct ble_ll_conn_sm* connsm)
 {
     int chk_proc_stop;
     int chk_host_phy;
@@ -689,9 +706,11 @@ ble_ll_ctrl_phy_update_proc_complete(struct ble_ll_conn_sm *connsm)
 
     if (connsm->flags.phy_update_peer_initiated) {
         connsm->flags.phy_update_peer_initiated = 0;
-    } else if (connsm->flags.phy_update_self_initiated) {
+    }
+    else if (connsm->flags.phy_update_self_initiated) {
         connsm->flags.phy_update_self_initiated = 0;
-    } else {
+    }
+    else {
         /* Must be a host-initiated update */
         connsm->flags.phy_update_host_initiated = 0;
         chk_host_phy = 0;
@@ -705,7 +724,8 @@ ble_ll_ctrl_phy_update_proc_complete(struct ble_ll_conn_sm *connsm)
         if (connsm->flags.phy_update_host_initiated) {
             if (ble_ll_conn_phy_update_if_needed(connsm)) {
                 connsm->flags.phy_update_host_initiated = 0;
-            } else {
+            }
+            else {
                 chk_proc_stop = 0;
             }
         }
@@ -738,9 +758,11 @@ ble_ll_ctrl_find_new_phy(uint8_t phy_mask_prefs)
     if (new_phy) {
         if (new_phy & BLE_PHY_MASK_2M) {
             new_phy = BLE_PHY_2M;
-        } else if (new_phy & BLE_PHY_MASK_1M) {
+        }
+        else if (new_phy & BLE_PHY_MASK_1M) {
             new_phy = BLE_PHY_1M;
-        } else {
+        }
+        else {
             new_phy = BLE_PHY_CODED;
         }
     }
@@ -758,8 +780,8 @@ ble_ll_ctrl_find_new_phy(uint8_t phy_mask_prefs)
  */
 
 static void
-ble_ll_ctrl_phy_update_ind_make(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
-                                uint8_t *ctrdata, int periph_req)
+ble_ll_ctrl_phy_update_ind_make(struct ble_ll_conn_sm* connsm, uint8_t* dptr,
+                                uint8_t* ctrdata, int periph_req)
 {
     uint8_t m_to_s;
     uint8_t s_to_m;
@@ -783,7 +805,8 @@ ble_ll_ctrl_phy_update_ind_make(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
     if (periph_req) {
         m_to_s = connsm->phy_data.pref_mask_tx & rx_phys;
         s_to_m = connsm->phy_data.pref_mask_rx & tx_phys;
-    } else {
+    }
+    else {
         m_to_s = connsm->phy_data.pref_mask_tx_req & rx_phys;
         s_to_m = connsm->phy_data.pref_mask_rx_req & tx_phys;
     }
@@ -803,7 +826,8 @@ ble_ll_ctrl_phy_update_ind_make(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
         if ((s_to_m == 0) || (m_to_s == 0)) {
             s_to_m = 0;
             m_to_s = 0;
-        } else {
+        }
+        else {
             BLE_LL_ASSERT(s_to_m == m_to_s);
         }
     }
@@ -830,15 +854,18 @@ ble_ll_ctrl_phy_update_ind_make(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
     if ((m_to_s == 0) && (s_to_m == 0)) {
         if (connsm->flags.phy_update_peer_initiated) {
             connsm->flags.phy_update_peer_initiated = 0;
-        } else if (connsm->flags.phy_update_self_initiated) {
+        }
+        else if (connsm->flags.phy_update_self_initiated) {
             connsm->flags.phy_update_self_initiated = 0;
             ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_PHY_UPDATE);
-        } else {
+        }
+        else {
             ble_ll_hci_ev_phy_update(connsm, BLE_ERR_SUCCESS);
             connsm->flags.phy_update_host_initiated = 0;
             ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_PHY_UPDATE);
         }
-    } else {
+    }
+    else {
         /* Set new phys to use when instant occurs */
         connsm->phy_data.new_tx_phy = m_to_s;
         connsm->phy_data.new_rx_phy = s_to_m;
@@ -860,7 +887,8 @@ ble_ll_ctrl_phy_update_ind_make(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
 
 #if MYNEWT_VAL(BLE_LL_PHY)
 static bool
-ble_ll_ctrl_phy_update_ind_instant(struct ble_ll_conn_sm *connsm, uint8_t *ctrdata)
+ble_ll_ctrl_phy_update_ind_instant(struct ble_ll_conn_sm* connsm,
+                                   uint8_t* ctrdata)
 {
     uint16_t instant;
     uint8_t m_to_s;
@@ -872,7 +900,8 @@ ble_ll_ctrl_phy_update_ind_instant(struct ble_ll_conn_sm *connsm, uint8_t *ctrda
 
     if ((m_to_s == 0) && (s_to_m == 0)) {
         instant = 0;
-    } else {
+    }
+    else {
         /* Determine instant we will use. 6 more is minimum */
         instant = connsm->event_cntr + connsm->periph_latency + 6 + 1;
         connsm->phy_instant = instant;
@@ -892,7 +921,7 @@ ble_ll_ctrl_phy_update_ind_instant(struct ble_ll_conn_sm *connsm, uint8_t *ctrda
  * @param ctrdata: Pointer to where CtrData starts in pdu
  */
 static void
-ble_ll_ctrl_phy_req_rsp_make(struct ble_ll_conn_sm *connsm, uint8_t *ctrdata)
+ble_ll_ctrl_phy_req_rsp_make(struct ble_ll_conn_sm* connsm, uint8_t* ctrdata)
 {
     ctrdata[0] = connsm->phy_data.pref_mask_tx;
     ctrdata[1] = connsm->phy_data.pref_mask_rx;
@@ -906,15 +935,15 @@ ble_ll_ctrl_phy_req_rsp_make(struct ble_ll_conn_sm *connsm, uint8_t *ctrdata)
  * @param ctrdata: Pointer to where CtrData starts in pdu
  */
 static void
-ble_ll_ctrl_sca_req_rsp_make(struct ble_ll_conn_sm *connsm, uint8_t *ctrdata)
+ble_ll_ctrl_sca_req_rsp_make(struct ble_ll_conn_sm* connsm, uint8_t* ctrdata)
 {
     ctrdata[0] = BLE_LL_SCA_ENUM;
 }
 #endif
 
 static uint8_t
-ble_ll_ctrl_rx_phy_req(struct ble_ll_conn_sm *connsm, uint8_t *req,
-                       uint8_t *rsp)
+ble_ll_ctrl_rx_phy_req(struct ble_ll_conn_sm* connsm, uint8_t* req,
+                       uint8_t* rsp)
 {
     uint8_t rsp_opcode;
     uint8_t err;
@@ -935,7 +964,8 @@ ble_ll_ctrl_rx_phy_req(struct ble_ll_conn_sm *connsm, uint8_t *req,
         if (err) {
             ble_ll_ctrl_rej_ext_ind_make(BLE_LL_CTRL_PHY_REQ, err, rsp);
             rsp_opcode = BLE_LL_CTRL_REJECT_IND_EXT;
-        } else {
+        }
+        else {
             /*
              * NOTE: do not change order of these two lines as the call to
              * make the LL_PHY_UPDATE_IND pdu might clear the flag.
@@ -970,7 +1000,8 @@ ble_ll_ctrl_rx_phy_req(struct ble_ll_conn_sm *connsm, uint8_t *req,
         ble_ll_ctrl_phy_req_rsp_make(connsm, rsp);
         rsp_opcode = BLE_LL_CTRL_PHY_RSP;
 
-        connsm->phy_tx_transition = ble_ll_ctrl_phy_tx_transition_get(req[1] | rsp[0]);
+        connsm->phy_tx_transition =
+            ble_ll_ctrl_phy_tx_transition_get(req[1] | rsp[0]);
 
         /* Start response timer */
         connsm->cur_ctrl_proc = BLE_LL_CTRL_PROC_PHY_UPDATE;
@@ -995,8 +1026,8 @@ ble_ll_ctrl_rx_phy_req(struct ble_ll_conn_sm *connsm, uint8_t *req,
  * @return uint8_t
  */
 static uint8_t
-ble_ll_ctrl_rx_phy_rsp(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
-                       uint8_t *rsp)
+ble_ll_ctrl_rx_phy_rsp(struct ble_ll_conn_sm* connsm, uint8_t* dptr,
+                       uint8_t* rsp)
 {
     uint8_t rsp_opcode;
 
@@ -1045,7 +1076,7 @@ ble_ll_ctrl_rx_phy_rsp(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
  * @return uint8_t
  */
 static uint8_t
-ble_ll_ctrl_rx_phy_update_ind(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
+ble_ll_ctrl_rx_phy_update_ind(struct ble_ll_conn_sm* connsm, uint8_t* dptr)
 {
     int no_change;
     uint8_t new_m_to_s_mask;
@@ -1082,7 +1113,8 @@ ble_ll_ctrl_rx_phy_update_ind(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
     if ((new_m_to_s_mask == 0) && (new_s_to_m_mask == 0)) {
         /* No change in phy */
         no_change = 1;
-    } else {
+    }
+    else {
         no_change = 0;
         /*
          * NOTE: from the peripherals perspective, the m to s phy is the one
@@ -1108,7 +1140,8 @@ ble_ll_ctrl_rx_phy_update_ind(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
         delta = (instant - connsm->event_cntr) & 0xFFFF;
         if (delta >= 32767) {
             ble_ll_conn_timeout(connsm, BLE_ERR_INSTANT_PASSED);
-        } else {
+        }
+        else {
             connsm->phy_data.new_tx_phy = new_tx_phy;
             connsm->phy_data.new_rx_phy = new_rx_phy;
             connsm->phy_instant = instant;
@@ -1133,7 +1166,7 @@ ble_ll_ctrl_rx_phy_update_ind(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
  * @return uint8_t
  */
 static uint8_t
-ble_ll_ctrl_rx_periodic_sync_ind(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
+ble_ll_ctrl_rx_periodic_sync_ind(struct ble_ll_conn_sm* connsm, uint8_t* dptr)
 {
     ble_ll_sync_periodic_ind(connsm, dptr, connsm->sync_transfer_mode,
                              connsm->sync_transfer_skip,
@@ -1153,8 +1186,8 @@ ble_ll_ctrl_rx_periodic_sync_ind(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
  * @return uint8_t
  */
 static uint8_t
-ble_ll_ctrl_rx_sca_req(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
-                       uint8_t *rsp)
+ble_ll_ctrl_rx_sca_req(struct ble_ll_conn_sm* connsm, uint8_t* dptr,
+                       uint8_t* rsp)
 {
     if (connsm->conn_role == BLE_LL_CONN_ROLE_PERIPHERAL) {
         connsm->central_sca = dptr[0];
@@ -1174,7 +1207,7 @@ ble_ll_ctrl_rx_sca_req(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
  * @return uint8_t
  */
 static uint8_t
-ble_ll_ctrl_rx_sca_rsp(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
+ble_ll_ctrl_rx_sca_rsp(struct ble_ll_conn_sm* connsm, uint8_t* dptr)
 {
     if (connsm->cur_ctrl_proc != BLE_LL_CTRL_PROC_SCA_UPDATE) {
         return BLE_LL_CTRL_UNKNOWN_RSP;
@@ -1194,8 +1227,8 @@ ble_ll_ctrl_rx_sca_rsp(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
 
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_ENHANCED_CONN_UPDATE)
 static void
-ble_ll_ctrl_subrate_req_make(struct ble_ll_conn_sm *connsm, uint8_t *pyld,
-                             struct ble_ll_conn_subrate_req_params *srp)
+ble_ll_ctrl_subrate_req_make(struct ble_ll_conn_sm* connsm, uint8_t* pyld,
+                             struct ble_ll_conn_subrate_req_params* srp)
 {
     put_le16(pyld + 0, srp->subrate_min);
     put_le16(pyld + 2, srp->subrate_max);
@@ -1205,8 +1238,8 @@ ble_ll_ctrl_subrate_req_make(struct ble_ll_conn_sm *connsm, uint8_t *pyld,
 }
 
 static void
-ble_ll_ctrl_subrate_ind_make(struct ble_ll_conn_sm *connsm, uint8_t *pyld,
-                             struct ble_ll_conn_subrate_params *sp)
+ble_ll_ctrl_subrate_ind_make(struct ble_ll_conn_sm* connsm, uint8_t* pyld,
+                             struct ble_ll_conn_subrate_params* sp)
 {
     put_le16(pyld + 0, sp->subrate_factor);
     put_le16(pyld + 2, sp->subrate_base_event);
@@ -1216,11 +1249,11 @@ ble_ll_ctrl_subrate_ind_make(struct ble_ll_conn_sm *connsm, uint8_t *pyld,
 }
 
 static uint8_t
-ble_ll_ctrl_rx_subrate_req(struct ble_ll_conn_sm *connsm, uint8_t *req,
-                           uint8_t *rsp)
+ble_ll_ctrl_rx_subrate_req(struct ble_ll_conn_sm* connsm, uint8_t* req,
+                           uint8_t* rsp)
 {
     struct ble_ll_conn_subrate_req_params params;
-    struct ble_ll_conn_subrate_req_params *srp = &params;
+    struct ble_ll_conn_subrate_req_params* srp = &params;
     uint8_t err;
     int rc;
 
@@ -1246,11 +1279,14 @@ ble_ll_ctrl_rx_subrate_req(struct ble_ll_conn_sm *connsm, uint8_t *req,
     if (rc < 0) {
         if (rc == -EINVAL) {
             err = BLE_ERR_INV_LMP_LL_PARM;
-        } else if (rc == -ENOTSUP) {
+        }
+        else if (rc == -ENOTSUP) {
             err = BLE_ERR_UNSUPP_REM_FEATURE;
-        } else if (rc == -EBUSY) {
+        }
+        else if (rc == -EBUSY) {
             err = BLE_ERR_DIFF_TRANS_COLL;
-        } else {
+        }
+        else {
             err = BLE_ERR_UNSPECIFIED;
         }
 
@@ -1263,11 +1299,11 @@ ble_ll_ctrl_rx_subrate_req(struct ble_ll_conn_sm *connsm, uint8_t *req,
 }
 
 static uint8_t
-ble_ll_ctrl_rx_subrate_ind(struct ble_ll_conn_sm *connsm, uint8_t *req,
-                           uint8_t *rsp)
+ble_ll_ctrl_rx_subrate_ind(struct ble_ll_conn_sm* connsm, uint8_t* req,
+                           uint8_t* rsp)
 {
     struct ble_ll_conn_subrate_params params;
-    struct ble_ll_conn_subrate_params *sp = &params;
+    struct ble_ll_conn_subrate_params* sp = &params;
     uint32_t t1, t2;
 
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
@@ -1323,7 +1359,7 @@ ble_ll_ctrl_rx_subrate_ind(struct ble_ll_conn_sm *connsm, uint8_t *req,
  * @param dptr: Pointer to where control pdu payload starts
  */
 static void
-ble_ll_ctrl_datalen_upd_make(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
+ble_ll_ctrl_datalen_upd_make(struct ble_ll_conn_sm* connsm, uint8_t* dptr)
 {
     put_le16(dptr + 1, connsm->max_rx_octets);
     put_le16(dptr + 3, connsm->max_rx_time);
@@ -1333,7 +1369,7 @@ ble_ll_ctrl_datalen_upd_make(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
 
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LE_ENCRYPTION)
 void
-ble_ll_calc_session_key(struct ble_ll_conn_sm *connsm)
+ble_ll_calc_session_key(struct ble_ll_conn_sm* connsm)
 {
 #ifdef BLE_LL_ENCRYPT_DEBUG
     int cnt;
@@ -1363,7 +1399,7 @@ ble_ll_calc_session_key(struct ble_ll_conn_sm *connsm)
         console_printf("%02x", connsm->enc_data.enc_block.cipher_text[cnt]);
     }
     console_printf("\nIV:");
-    for (cnt = 0; cnt < 8; ++ cnt) {
+    for (cnt = 0; cnt < 8; ++cnt) {
         console_printf("%02x", connsm->enc_data.iv[cnt]);
     }
     console_printf("\n");
@@ -1405,6 +1441,10 @@ ble_ll_ctrl_enc_allowed_pdu(uint8_t llid, uint8_t len, uint8_t opcode)
         case BLE_LL_CTRL_PAUSE_ENC_REQ:
         case BLE_LL_CTRL_PAUSE_ENC_RSP:
         case BLE_LL_CTRL_TERMINATE_IND:
+        case BLE_LL_CTRL_ENC_F_REQ:
+        case BLE_LL_CTRL_ENC_F_RSP:
+        case BLE_LL_CTRL_REKEY_REQ:
+        case BLE_LL_CTRL_REKEY_RSP:
             allowed = 1;
             break;
         }
@@ -1421,7 +1461,7 @@ ble_ll_ctrl_enc_allowed_pdu(uint8_t llid, uint8_t len, uint8_t opcode)
 }
 
 int
-ble_ll_ctrl_enc_allowed_pdu_rx(struct os_mbuf *rxpdu)
+ble_ll_ctrl_enc_allowed_pdu_rx(struct os_mbuf* rxpdu)
 {
     uint8_t llid;
     uint8_t len;
@@ -1431,7 +1471,8 @@ ble_ll_ctrl_enc_allowed_pdu_rx(struct os_mbuf *rxpdu)
     len = rxpdu->om_data[1];
     if (llid == BLE_LL_LLID_CTRL) {
         opcode = rxpdu->om_data[2];
-    } else {
+    }
+    else {
         opcode = 0;
     }
 
@@ -1439,10 +1480,10 @@ ble_ll_ctrl_enc_allowed_pdu_rx(struct os_mbuf *rxpdu)
 }
 
 int
-ble_ll_ctrl_enc_allowed_pdu_tx(struct os_mbuf_pkthdr *pkthdr)
+ble_ll_ctrl_enc_allowed_pdu_tx(struct os_mbuf_pkthdr* pkthdr)
 {
-    struct os_mbuf *m;
-    struct ble_mbuf_hdr *ble_hdr;
+    struct os_mbuf* m;
+    struct ble_mbuf_hdr* ble_hdr;
     uint8_t llid;
     uint8_t len;
     uint8_t opcode;
@@ -1454,7 +1495,8 @@ ble_ll_ctrl_enc_allowed_pdu_tx(struct os_mbuf_pkthdr *pkthdr)
     len = ble_hdr->txinfo.pyld_len;
     if (llid == BLE_LL_LLID_CTRL) {
         opcode = m->om_data[0];
-    } else {
+    }
+    else {
         opcode = 0;
     }
 
@@ -1462,12 +1504,12 @@ ble_ll_ctrl_enc_allowed_pdu_tx(struct os_mbuf_pkthdr *pkthdr)
 }
 
 int
-ble_ll_ctrl_is_start_enc_rsp(struct os_mbuf *txpdu)
+ble_ll_ctrl_is_start_enc_rsp(struct os_mbuf* txpdu)
 {
     int is_start_enc_rsp;
     uint8_t opcode;
     uint8_t llid;
-    struct ble_mbuf_hdr *ble_hdr;
+    struct ble_mbuf_hdr* ble_hdr;
 
     is_start_enc_rsp = 0;
     ble_hdr = BLE_MBUF_HDR_PTR(txpdu);
@@ -1492,10 +1534,10 @@ ble_ll_ctrl_is_start_enc_rsp(struct os_mbuf *txpdu)
  * @return int
  */
 int
-ble_ll_ctrl_start_enc_send(struct ble_ll_conn_sm *connsm)
+ble_ll_ctrl_start_enc_send(struct ble_ll_conn_sm* connsm)
 {
     int rc;
-    struct os_mbuf *om;
+    struct os_mbuf* om;
 
     om = os_msys_get_pkthdr(BLE_LL_CTRL_MAX_PDU_LEN,
                             sizeof(struct ble_mbuf_hdr));
@@ -1512,12 +1554,130 @@ ble_ll_ctrl_start_enc_send(struct ble_ll_conn_sm *connsm)
         }
 
         rc = 0;
-    } else {
+    }
+    else {
+        rc = -1;
+    }
+    return rc;
+}
+
+int
+ble_ll_ctrl_rekey_req_send(struct ble_ll_conn_sm* connsm)
+{
+    int rc;
+    struct os_mbuf* om;
+
+    om = os_msys_get_pkthdr(BLE_LL_CTRL_MAX_PDU_LEN,
+                            sizeof(struct ble_mbuf_hdr));
+
+    if (om) {
+        om->om_data[0] = BLE_LL_CTRL_REKEY_REQ;
+        ble_ll_conn_enqueue_pkt(connsm, om, BLE_LL_LLID_CTRL, 1);
+        rc = 0;
+    }
+    else {
+        rc = -1;
+    }
+
+    return rc;
+}
+
+void
+ble_ll_ctrl_rx_rekey_rsp(struct ble_ll_conn_sm* connsm)
+{
+    // int cnt;
+    ble_ll_hci_ev_encrypt_chg(connsm, BLE_ERR_SUCCESS);
+    // Do nothing for now
+}
+
+int
+ble_ll_ctrl_rx_rekey_req(struct ble_ll_conn_sm* connsm)
+{
+    int rc;
+    // uint8_t rand[16] = {0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
+    //                     0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10};
+
+    if (connsm->flags.encrypted) {
+        // Put the key in right place
+        // swap_buf(connsm->enc_data.enc_block.key, rand, 16);
+        // memcpy(connsm->enc_data.enc_block.plain_text,
+        //        connsm->enc_data.enc_block.cipher_text, 16);
+        memcpy(connsm->enc_data.enc_block.cipher_text,
+               connsm->enc_data.enc_block.key, 16);
+        // update
+        ble_phy_encrypt_enable(connsm->enc_data.enc_block.cipher_text);
+        memset(connsm->enc_data.iv, 0, 8);
+        ble_phy_encrypt_iv_set(connsm->enc_data.iv);
+        ble_phy_encrypt_counter_set(connsm->enc_data.rx_pkt_cntr,
+                                    !CONN_IS_CENTRAL(connsm));
+        ble_phy_encrypt_counter_set(connsm->enc_data.tx_pkt_cntr,
+                                    CONN_IS_CENTRAL(connsm));
+
+        // ble_ll_calc_session_key(connsm);
+        rc = BLE_LL_CTRL_REKEY_RSP;
+    }
+    else {
+        rc = BLE_LL_CTRL_UNKNOWN_RSP;
+    }
+    return rc;
+}
+
+int
+ble_ll_ctrl_f_enc_req_send(struct ble_ll_conn_sm* connsm)
+{
+    int rc;
+    struct os_mbuf* om;
+
+    om = os_msys_get_pkthdr(BLE_LL_CTRL_MAX_PDU_LEN,
+                            sizeof(struct ble_mbuf_hdr));
+    if (om) {
+        om->om_data[0] = BLE_LL_CTRL_ENC_F_REQ;
+        ble_ll_conn_enqueue_pkt(connsm, om, BLE_LL_LLID_CTRL, 1);
+        rc = 0;
+    }
+    else {
         rc = -1;
     }
     return rc;
 }
 
+int
+ble_ll_ctrl_rx_f_enc_req(struct ble_ll_conn_sm* connsm)
+{
+
+    connsm->enc_data.rx_pkt_cntr = 0;
+    connsm->enc_data.tx_pkt_cntr = 0;
+    // connsm->enc_data.tx_encrypted = 0;
+
+    if (!connsm->flags.encrypted) {
+        connsm->flags.encrypted = 1;
+        connsm->enc_data.tx_encrypted = 1;
+        connsm->enc_data.enc_state = CONN_ENC_S_ENCRYPTED;
+    }
+    // memset(connsm->enc_data.iv, 0, 8);
+    ble_phy_encrypt_enable(connsm->enc_data.enc_block.cipher_text);
+    ble_phy_encrypt_iv_set(connsm->enc_data.iv);
+    // Peripheral
+    ble_phy_encrypt_counter_set(connsm->enc_data.rx_pkt_cntr,
+                                !CONN_IS_CENTRAL(connsm));
+    ble_phy_encrypt_counter_set(connsm->enc_data.tx_pkt_cntr,
+                                CONN_IS_CENTRAL(connsm));
+
+    ble_ll_hci_ev_encrypt_chg(connsm, BLE_ERR_SUCCESS);
+
+    return BLE_LL_CTRL_ENC_F_RSP;
+}
+
+void
+ble_ll_ctrl_rx_f_enc_rsp(struct ble_ll_conn_sm* connsm)
+{
+    connsm->enc_data.tx_encrypted = 1;
+    connsm->enc_data.enc_state = CONN_ENC_S_ENCRYPTED;
+    ble_phy_encrypt_counter_set(connsm->enc_data.tx_pkt_cntr,
+                                CONN_IS_CENTRAL(connsm));
+    ble_ll_hci_ev_encrypt_chg(connsm, BLE_ERR_SUCCESS);
+}
+
 /**
  * Create a link layer control "encrypt request" PDU.
  *
@@ -1537,7 +1697,7 @@ ble_ll_ctrl_start_enc_send(struct ble_ll_conn_sm *connsm)
  * @param dptr: Pointer to where control pdu payload starts
  */
 static void
-ble_ll_ctrl_enc_req_make(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
+ble_ll_ctrl_enc_req_make(struct ble_ll_conn_sm* connsm, uint8_t* dptr)
 {
     put_le64(dptr, connsm->enc_data.host_rand_num);
     put_le16(dptr + 8, connsm->enc_data.enc_div);
@@ -1574,7 +1734,7 @@ ble_ll_ctrl_enc_req_make(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
  * @param dptr
  */
 static void
-ble_ll_ctrl_rx_enc_rsp(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
+ble_ll_ctrl_rx_enc_rsp(struct ble_ll_conn_sm* connsm, uint8_t* dptr)
 {
     /* Calculate session key now that we have received the ENC_RSP */
     if (connsm->cur_ctrl_proc == BLE_LL_CTRL_PROC_ENCRYPT) {
@@ -1612,8 +1772,8 @@ ble_ll_ctrl_rx_enc_rsp(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
  * @param rspbuf
  */
 static uint8_t
-ble_ll_ctrl_rx_enc_req(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
-                       uint8_t *rspdata)
+ble_ll_ctrl_rx_enc_req(struct ble_ll_conn_sm* connsm, uint8_t* dptr,
+                       uint8_t* rspdata)
 {
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
     if (connsm->conn_role == BLE_LL_CONN_ROLE_CENTRAL) {
@@ -1656,7 +1816,7 @@ ble_ll_ctrl_rx_enc_req(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
 }
 
 static uint8_t
-ble_ll_ctrl_rx_start_enc_req(struct ble_ll_conn_sm *connsm)
+ble_ll_ctrl_rx_start_enc_req(struct ble_ll_conn_sm* connsm)
 {
     int rc;
 
@@ -1687,7 +1847,7 @@ ble_ll_ctrl_rx_start_enc_req(struct ble_ll_conn_sm *connsm)
 }
 
 static uint8_t
-ble_ll_ctrl_rx_pause_enc_req(struct ble_ll_conn_sm *connsm)
+ble_ll_ctrl_rx_pause_enc_req(struct ble_ll_conn_sm* connsm)
 {
     int rc;
 
@@ -1700,7 +1860,8 @@ ble_ll_ctrl_rx_pause_enc_req(struct ble_ll_conn_sm *connsm)
     if (CONN_IS_PERIPHERAL(connsm) &&
         (connsm->enc_data.enc_state == CONN_ENC_S_ENCRYPTED)) {
         rc = BLE_LL_CTRL_PAUSE_ENC_RSP;
-    } else {
+    }
+    else {
         rc = BLE_LL_CTRL_UNKNOWN_RSP;
     }
 
@@ -1716,7 +1877,7 @@ ble_ll_ctrl_rx_pause_enc_req(struct ble_ll_conn_sm *connsm)
  * @return uint8_t
  */
 static uint8_t
-ble_ll_ctrl_rx_pause_enc_rsp(struct ble_ll_conn_sm *connsm)
+ble_ll_ctrl_rx_pause_enc_rsp(struct ble_ll_conn_sm* connsm)
 {
     int rc = 0;
 
@@ -1729,14 +1890,15 @@ ble_ll_ctrl_rx_pause_enc_rsp(struct ble_ll_conn_sm *connsm)
 #if MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL)
     case BLE_LL_CONN_ROLE_PERIPHERAL:
         if (connsm->enc_data.enc_state == CONN_ENC_S_PAUSE_ENC_RSP_WAIT) {
-                /* Master sends back unencrypted LL_PAUSE_ENC_RSP.
+            /* Master sends back unencrypted LL_PAUSE_ENC_RSP.
                  * From this moment encryption is paused.
                  */
-                rc = BLE_ERR_MAX;
-                connsm->enc_data.enc_state = CONN_ENC_S_PAUSED;
-            } else {
-                rc = BLE_LL_CTRL_UNKNOWN_RSP;
-            }
+            rc = BLE_ERR_MAX;
+            connsm->enc_data.enc_state = CONN_ENC_S_PAUSED;
+        }
+        else {
+            rc = BLE_LL_CTRL_UNKNOWN_RSP;
+        }
         break;
 #endif
     default:
@@ -1757,7 +1919,7 @@ ble_ll_ctrl_rx_pause_enc_rsp(struct ble_ll_conn_sm *connsm)
  * @return uint8_t
  */
 static uint8_t
-ble_ll_ctrl_rx_start_enc_rsp(struct ble_ll_conn_sm *connsm)
+ble_ll_ctrl_rx_start_enc_rsp(struct ble_ll_conn_sm* connsm)
 {
     int rc = 0;
 
@@ -1815,11 +1977,11 @@ ble_ll_ctrl_rx_start_enc_rsp(struct ble_ll_conn_sm *connsm)
  *             of the data.
  */
 static void
-ble_ll_ctrl_conn_param_pdu_make(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
-                                struct ble_ll_conn_params *req)
+ble_ll_ctrl_conn_param_pdu_make(struct ble_ll_conn_sm* connsm, uint8_t* dptr,
+                                struct ble_ll_conn_params* req)
 {
     uint16_t offset;
-    struct hci_conn_update *hcu;
+    struct hci_conn_update* hcu;
 
     /* If we were passed in a request, we use the parameters from the request */
     if (req) {
@@ -1827,7 +1989,8 @@ ble_ll_ctrl_conn_param_pdu_make(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
         put_le16(dptr + 2, req->interval_max);
         put_le16(dptr + 4, req->latency);
         put_le16(dptr + 6, req->timeout);
-    } else {
+    }
+    else {
         hcu = &connsm->conn_param_req;
         /* The host should have provided the parameters! */
         BLE_LL_ASSERT(hcu->handle != 0);
@@ -1859,7 +2022,7 @@ ble_ll_ctrl_conn_param_pdu_make(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
 }
 
 static void
-ble_ll_ctrl_version_ind_make(struct ble_ll_conn_sm *connsm, uint8_t *pyld)
+ble_ll_ctrl_version_ind_make(struct ble_ll_conn_sm* connsm, uint8_t* pyld)
 {
     /* Set flag to denote we have sent/received this */
     connsm->flags.version_ind_txd = 1;
@@ -1877,7 +2040,7 @@ ble_ll_ctrl_version_ind_make(struct ble_ll_conn_sm *connsm, uint8_t *pyld)
  * @param pyld      Pointer to payload of LL control PDU
  */
 static void
-ble_ll_ctrl_chanmap_req_make(struct ble_ll_conn_sm *connsm, uint8_t *pyld)
+ble_ll_ctrl_chanmap_req_make(struct ble_ll_conn_sm* connsm, uint8_t* pyld)
 {
     /* Copy channel map that host desires into request */
     memcpy(pyld, g_ble_ll_data.chan_map, BLE_LL_CHAN_MAP_LEN);
@@ -1887,10 +2050,11 @@ ble_ll_ctrl_chanmap_req_make(struct ble_ll_conn_sm *connsm, uint8_t *pyld)
 }
 
 static void
-ble_ll_ctrl_chanmap_req_instant(struct ble_ll_conn_sm *connsm, uint8_t *pyld)
+ble_ll_ctrl_chanmap_req_instant(struct ble_ll_conn_sm* connsm, uint8_t* pyld)
 {
     /* Place instant into request */
-    connsm->chanmap_instant = connsm->event_cntr + connsm->periph_latency + 6 + 1;
+    connsm->chanmap_instant =
+        connsm->event_cntr + connsm->periph_latency + 6 + 1;
     put_le16(pyld + BLE_LL_CHAN_MAP_LEN, connsm->chanmap_instant);
 }
 
@@ -1905,8 +2069,8 @@ ble_ll_ctrl_chanmap_req_instant(struct ble_ll_conn_sm *connsm, uint8_t *pyld)
  * @return uint8_t
  */
 uint8_t
-ble_ll_ctrl_conn_param_reply(struct ble_ll_conn_sm *connsm, uint8_t *rsp,
-                             struct ble_ll_conn_params *req)
+ble_ll_ctrl_conn_param_reply(struct ble_ll_conn_sm* connsm, uint8_t* rsp,
+                             struct ble_ll_conn_params* req)
 {
     uint8_t rsp_opcode = 0;
 
@@ -1941,8 +2105,8 @@ ble_ll_ctrl_conn_param_reply(struct ble_ll_conn_sm *connsm, uint8_t *rsp,
  * @param opcode
  */
 static int
-ble_ll_ctrl_rx_reject_ind(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
-                          uint8_t opcode, uint8_t *rspdata)
+ble_ll_ctrl_rx_reject_ind(struct ble_ll_conn_sm* connsm, uint8_t* dptr,
+                          uint8_t opcode, uint8_t* rspdata)
 {
     uint8_t ble_error;
     uint8_t rsp_opcode = BLE_ERR_MAX;
@@ -1950,7 +2114,8 @@ ble_ll_ctrl_rx_reject_ind(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
     /* Get error out of received PDU */
     if (opcode == BLE_LL_CTRL_REJECT_IND) {
         ble_error = dptr[0];
-    } else {
+    }
+    else {
         ble_error = dptr[1];
     }
 
@@ -1963,20 +2128,20 @@ ble_ll_ctrl_rx_reject_ind(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
     case BLE_LL_CTRL_PROC_CONN_PARAM_REQ:
         if (opcode == BLE_LL_CTRL_REJECT_IND_EXT) {
             switch (connsm->conn_role) {
-        #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
+#if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
             case BLE_LL_CONN_ROLE_CENTRAL:
                 /* As a central we should send connection update indication in this point */
                 rsp_opcode = BLE_LL_CTRL_CONN_UPDATE_IND;
                 ble_ll_ctrl_conn_update_init_proc(connsm, NULL);
                 connsm->reject_reason = BLE_ERR_SUCCESS;
                 break;
-        #endif
-        #if MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL)
+#endif
+#if MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL)
             case BLE_LL_CONN_ROLE_PERIPHERAL:
                 ble_ll_ctrl_proc_stop(connsm, BLE_LL_CTRL_PROC_CONN_PARAM_REQ);
                 ble_ll_hci_ev_conn_update(connsm, ble_error);
                 break;
-        #endif
+#endif
             default:
                 BLE_LL_ASSERT(0);
                 break;
@@ -2032,11 +2197,11 @@ ble_ll_ctrl_rx_reject_ind(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
  * @return int
  */
 static int
-ble_ll_ctrl_rx_conn_update(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
+ble_ll_ctrl_rx_conn_update(struct ble_ll_conn_sm* connsm, uint8_t* dptr)
 {
     uint8_t rsp_opcode;
     uint16_t conn_events;
-    struct ble_ll_conn_upd_req *reqdata;
+    struct ble_ll_conn_upd_req* reqdata;
 
     /* Only a peripheral should receive this */
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
@@ -2062,7 +2227,8 @@ ble_ll_ctrl_rx_conn_update(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
     conn_events = (reqdata->instant - connsm->event_cntr) & 0xFFFF;
     if (conn_events >= 32767) {
         ble_ll_conn_timeout(connsm, BLE_ERR_INSTANT_PASSED);
-    } else {
+    }
+    else {
         connsm->flags.conn_update_sched = 1;
 
         /*
@@ -2085,7 +2251,7 @@ ble_ll_ctrl_rx_conn_update(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
 }
 
 void
-ble_ll_ctrl_initiate_dle(struct ble_ll_conn_sm *connsm, bool initial)
+ble_ll_ctrl_initiate_dle(struct ble_ll_conn_sm* connsm, bool initial)
 {
     if (!(connsm->conn_features & BLE_LL_FEAT_DATA_LEN_EXT)) {
         return;
@@ -2109,7 +2275,7 @@ ble_ll_ctrl_initiate_dle(struct ble_ll_conn_sm *connsm, bool initial)
 }
 
 static void
-ble_ll_ctrl_update_features(struct ble_ll_conn_sm *connsm, uint8_t *feat)
+ble_ll_ctrl_update_features(struct ble_ll_conn_sm* connsm, uint8_t* feat)
 {
     connsm->conn_features = feat[0];
     memcpy(connsm->remote_features, feat + 1, 7);
@@ -2126,15 +2292,18 @@ ble_ll_ctrl_update_features(struct ble_ll_conn_sm *connsm, uint8_t *feat)
          */
         if (ble_ll_conn_rem_feature_check(connsm, BLE_LL_FEAT_LE_CODED_PHY)) {
             if (connsm->host_req_max_tx_time) {
-                connsm->max_tx_time = MAX(connsm->max_tx_time,
-                                          connsm->host_req_max_tx_time);
-            } else {
-                connsm->max_tx_time = g_ble_ll_conn_params.conn_init_max_tx_time_coded;
+                connsm->max_tx_time =
+                    MAX(connsm->max_tx_time, connsm->host_req_max_tx_time);
+            }
+            else {
+                connsm->max_tx_time =
+                    g_ble_ll_conn_params.conn_init_max_tx_time_coded;
             }
             if (connsm->host_req_max_rx_time) {
-                connsm->max_rx_time = MAX(connsm->max_rx_time,
-                                          connsm->host_req_max_rx_time);
-            } else {
+                connsm->max_rx_time =
+                    MAX(connsm->max_rx_time, connsm->host_req_max_rx_time);
+            }
+            else {
                 connsm->max_rx_time = BLE_LL_CONN_SUPP_TIME_MAX_CODED;
             }
         }
@@ -2162,8 +2331,8 @@ ble_ll_ctrl_update_features(struct ble_ll_conn_sm *connsm, uint8_t *feat)
  * @return int
  */
 static int
-ble_ll_ctrl_rx_feature_req(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
-                           uint8_t *rspbuf, uint8_t opcode)
+ble_ll_ctrl_rx_feature_req(struct ble_ll_conn_sm* connsm, uint8_t* dptr,
+                           uint8_t* rspbuf, uint8_t opcode)
 {
     uint8_t rsp_opcode;
     uint64_t our_feat;
@@ -2176,7 +2345,8 @@ ble_ll_ctrl_rx_feature_req(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
         if (!CONN_IS_CENTRAL(connsm)) {
             return BLE_LL_CTRL_UNKNOWN_RSP;
         }
-    } else {
+    }
+    else {
         /* XXX: not sure this is correct but do it anyway */
         if (!CONN_IS_PERIPHERAL(connsm)) {
             return BLE_LL_CTRL_UNKNOWN_RSP;
@@ -2214,7 +2384,7 @@ ble_ll_ctrl_rx_feature_req(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
  *
  */
 static void
-ble_ll_ctrl_rx_feature_rsp(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
+ble_ll_ctrl_rx_feature_rsp(struct ble_ll_conn_sm* connsm, uint8_t* dptr)
 {
     ble_ll_ctrl_update_features(connsm, dptr);
 
@@ -2242,8 +2412,8 @@ ble_ll_ctrl_rx_feature_rsp(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
  * @return int
  */
 static int
-ble_ll_ctrl_rx_conn_param_req(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
-                              uint8_t *rspbuf)
+ble_ll_ctrl_rx_conn_param_req(struct ble_ll_conn_sm* connsm, uint8_t* dptr,
+                              uint8_t* rspbuf)
 {
     uint8_t rsp_opcode;
 
@@ -2331,8 +2501,8 @@ ble_ll_ctrl_rx_conn_param_req(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
 }
 
 static int
-ble_ll_ctrl_rx_conn_param_rsp(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
-                              uint8_t *rspbuf)
+ble_ll_ctrl_rx_conn_param_rsp(struct ble_ll_conn_sm* connsm, uint8_t* dptr,
+                              uint8_t* rspbuf)
 {
     uint8_t rsp_opcode;
 
@@ -2376,8 +2546,8 @@ ble_ll_ctrl_rx_conn_param_rsp(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
  * @return int
  */
 static int
-ble_ll_ctrl_rx_version_ind(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
-                           uint8_t *rspbuf)
+ble_ll_ctrl_rx_version_ind(struct ble_ll_conn_sm* connsm, uint8_t* dptr,
+                           uint8_t* rspbuf)
 {
     uint8_t rsp_opcode;
 
@@ -2410,7 +2580,7 @@ ble_ll_ctrl_rx_version_ind(struct ble_ll_conn_sm *connsm, uint8_t *dptr,
  * @param dptr
  */
 static int
-ble_ll_ctrl_rx_chanmap_req(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
+ble_ll_ctrl_rx_chanmap_req(struct ble_ll_conn_sm* connsm, uint8_t* dptr)
 {
     uint16_t instant;
     uint16_t conn_events;
@@ -2426,7 +2596,8 @@ ble_ll_ctrl_rx_chanmap_req(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
     conn_events = (instant - connsm->event_cntr) & 0xFFFF;
     if (conn_events >= 32767) {
         ble_ll_conn_timeout(connsm, BLE_ERR_INSTANT_PASSED);
-    } else {
+    }
+    else {
         connsm->chanmap_instant = instant;
         memcpy(connsm->req_chanmap, dptr, BLE_LL_CHAN_MAP_LEN);
         connsm->flags.chanmap_update_sched = 1;
@@ -2447,17 +2618,18 @@ ble_ll_ctrl_rx_chanmap_req(struct ble_ll_conn_sm *connsm, uint8_t *dptr)
  * @param connsm
  * @param ctrl_proc
  */
-static struct os_mbuf *
-ble_ll_ctrl_proc_init(struct ble_ll_conn_sm *connsm, int ctrl_proc, void *data)
+static struct os_mbuf*
+ble_ll_ctrl_proc_init(struct ble_ll_conn_sm* connsm, int ctrl_proc, void* data)
 {
     uint8_t len;
     uint8_t opcode = 0;
-    uint8_t *dptr;
-    uint8_t *ctrdata;
-    struct os_mbuf *om;
+    uint8_t* dptr;
+    uint8_t* ctrdata;
+    struct os_mbuf* om;
 
     /* Get an mbuf for the control pdu */
-    om = os_msys_get_pkthdr(BLE_LL_CTRL_MAX_PDU_LEN, sizeof(struct ble_mbuf_hdr));
+    om = os_msys_get_pkthdr(BLE_LL_CTRL_MAX_PDU_LEN,
+                            sizeof(struct ble_mbuf_hdr));
 
     if (om) {
         /* The control data starts after the opcode (1 byte) */
@@ -2516,7 +2688,8 @@ ble_ll_ctrl_proc_init(struct ble_ll_conn_sm *connsm, int ctrl_proc, void *data)
             /* If we are already encrypted we do pause procedure */
             if (connsm->enc_data.enc_state == CONN_ENC_S_ENCRYPTED) {
                 opcode = BLE_LL_CTRL_PAUSE_ENC_REQ;
-            } else {
+            }
+            else {
                 opcode = BLE_LL_CTRL_ENC_REQ;
                 ble_ll_ctrl_enc_req_make(connsm, ctrdata);
             }
@@ -2596,7 +2769,7 @@ ble_ll_ctrl_is_terminate_ind(uint8_t hdr, uint8_t opcode)
  * @param ctrl_proc
  */
 void
-ble_ll_ctrl_proc_stop(struct ble_ll_conn_sm *connsm, int ctrl_proc)
+ble_ll_ctrl_proc_stop(struct ble_ll_conn_sm* connsm, int ctrl_proc)
 {
     if (connsm->cur_ctrl_proc == ctrl_proc) {
         ble_npl_callout_stop(&connsm->ctrl_proc_rsp_timer);
@@ -2616,11 +2789,11 @@ ble_ll_ctrl_proc_stop(struct ble_ll_conn_sm *connsm, int ctrl_proc)
  * @param connsm
  */
 void
-ble_ll_ctrl_terminate_start(struct ble_ll_conn_sm *connsm)
+ble_ll_ctrl_terminate_start(struct ble_ll_conn_sm* connsm)
 {
     int ctrl_proc;
     uint32_t usecs;
-    struct os_mbuf *om;
+    struct os_mbuf* om;
 
     BLE_LL_ASSERT(connsm->disconnect_reason != 0);
 
@@ -2645,10 +2818,9 @@ ble_ll_ctrl_terminate_start(struct ble_ll_conn_sm *connsm)
  * @param connsm Pointer to connection state machine.
  */
 void
-ble_ll_ctrl_proc_start(struct ble_ll_conn_sm *connsm, int ctrl_proc,
-                       void *data)
+ble_ll_ctrl_proc_start(struct ble_ll_conn_sm* connsm, int ctrl_proc, void* data)
 {
-    struct os_mbuf *om;
+    struct os_mbuf* om;
 
     BLE_LL_ASSERT(ctrl_proc != BLE_LL_CTRL_PROC_TERMINATE);
 
@@ -2680,10 +2852,10 @@ ble_ll_ctrl_proc_start(struct ble_ll_conn_sm *connsm, int ctrl_proc,
  * @param connsm Pointer to connection state machine.
  */
 void
-ble_ll_ctrl_chk_proc_start(struct ble_ll_conn_sm *connsm)
+ble_ll_ctrl_chk_proc_start(struct ble_ll_conn_sm* connsm)
 {
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LE_ENCRYPTION)
-    struct os_mbuf *om;
+    struct os_mbuf* om;
 #endif
     int i;
 
@@ -2740,7 +2912,8 @@ ble_ll_ctrl_chk_proc_start(struct ble_ll_conn_sm *connsm)
                     (connsm->flags.version_ind_rxd)) {
                     ble_ll_hci_ev_rd_rem_ver(connsm, BLE_ERR_SUCCESS);
                     CLR_PENDING_CTRL_PROC(connsm, i);
-                } else {
+                }
+                else {
                     ble_ll_ctrl_proc_start(connsm, i, NULL);
                     break;
                 }
@@ -2763,15 +2936,15 @@ ble_ll_ctrl_chk_proc_start(struct ble_ll_conn_sm *connsm)
  * @param connsm
  */
 int
-ble_ll_ctrl_rx_pdu(struct ble_ll_conn_sm *connsm, struct os_mbuf *om)
+ble_ll_ctrl_rx_pdu(struct ble_ll_conn_sm* connsm, struct os_mbuf* om)
 {
     uint64_t features;
     uint64_t feature;
     uint8_t len;
     uint8_t opcode;
-    uint8_t *dptr;
-    uint8_t *rspbuf;
-    uint8_t *rspdata;
+    uint8_t* dptr;
+    uint8_t* rspbuf;
+    uint8_t* rspdata;
     int rc = 0;
     uint8_t rsp_opcode = 0;
 
@@ -2791,8 +2964,7 @@ ble_ll_ctrl_rx_pdu(struct ble_ll_conn_sm *connsm, struct os_mbuf *om)
 
 #if MYNEWT_VAL(BLE_LL_HCI_LLCP_TRACE)
     ble_ll_hci_ev_send_vs_llcp_trace(0x03, connsm->conn_handle,
-                                     connsm->event_cntr,
-                                     &dptr[2], len);
+                                     connsm->event_cntr, &dptr[2], len);
 #endif
 
     /*
@@ -2872,12 +3044,13 @@ ble_ll_ctrl_rx_pdu(struct ble_ll_conn_sm *connsm, struct os_mbuf *om)
                     rsp_opcode = BLE_LL_CTRL_REJECT_IND_EXT;
                     rspbuf[1] = opcode;
                     rspbuf[2] = BLE_ERR_UNSUPP_REM_FEATURE;
-
-                } else {
+                }
+                else {
                     rsp_opcode = BLE_LL_CTRL_REJECT_IND;
                     rspbuf[1] = BLE_ERR_UNSUPP_REM_FEATURE;
                 }
-            } else {
+            }
+            else {
                 /* Construct unknown rsp pdu */
                 rsp_opcode = BLE_LL_CTRL_UNKNOWN_RSP;
             }
@@ -2897,7 +3070,7 @@ ble_ll_ctrl_rx_pdu(struct ble_ll_conn_sm *connsm, struct os_mbuf *om)
     case BLE_LL_CTRL_LENGTH_REQ:
         /* Extract parameters and check if valid */
         if (ble_ll_ctrl_len_proc(connsm, dptr)) {
-            rc  = -1;
+            rc = -1;
             rsp_opcode = BLE_LL_CTRL_UNKNOWN_RSP;
             goto ll_ctrl_send_rsp;
         }
@@ -2968,6 +3141,20 @@ ble_ll_ctrl_rx_pdu(struct ble_ll_conn_sm *connsm, struct os_mbuf *om)
         rsp_opcode = ble_ll_ctrl_rx_pause_enc_rsp(connsm);
         break;
 #endif
+    case BLE_LL_CTRL_REKEY_REQ:
+        rsp_opcode = ble_ll_ctrl_rx_rekey_req(connsm);
+        break;
+    case BLE_LL_CTRL_REKEY_RSP:
+        ble_ll_ctrl_rx_rekey_rsp(connsm);
+        break;
+    case BLE_LL_CTRL_ENC_F_REQ:
+        rsp_opcode = ble_ll_ctrl_rx_f_enc_req(connsm);
+        break;
+    case BLE_LL_CTRL_ENC_F_RSP:
+        /* If decryption or anything fails we never reach this*/
+        // ble_ll_hci_ev_encrypt_chg(connsm, BLE_ERR_SUCCESS);
+        ble_ll_ctrl_rx_f_enc_rsp(connsm);
+        break;
     case BLE_LL_CTRL_PING_REQ:
         rsp_opcode = BLE_LL_CTRL_PING_RSP;
         break;
@@ -3028,7 +3215,8 @@ ble_ll_ctrl_rx_pdu(struct ble_ll_conn_sm *connsm, struct os_mbuf *om)
 ll_ctrl_send_rsp:
     if (rsp_opcode == BLE_ERR_MAX) {
         os_mbuf_free_chain(om);
-    } else {
+    }
+    else {
         /*
          * Write the response opcode into the buffer. If this is an unknown
          * response, put opcode of unknown pdu into buffer.
@@ -3061,14 +3249,14 @@ ll_ctrl_send_rsp:
  * @return int
  */
 int
-ble_ll_ctrl_reject_ind_send(struct ble_ll_conn_sm *connsm, uint8_t rej_opcode,
+ble_ll_ctrl_reject_ind_send(struct ble_ll_conn_sm* connsm, uint8_t rej_opcode,
                             uint8_t err)
 {
     int rc;
     uint8_t len;
     uint8_t opcode;
-    uint8_t *rspbuf;
-    struct os_mbuf *om;
+    uint8_t* rspbuf;
+    struct os_mbuf* om;
 
     om = os_msys_get_pkthdr(BLE_LL_CTRL_MAX_PDU_LEN,
                             sizeof(struct ble_mbuf_hdr));
@@ -3084,24 +3272,26 @@ ble_ll_ctrl_reject_ind_send(struct ble_ll_conn_sm *connsm, uint8_t rej_opcode,
         if (opcode == BLE_LL_CTRL_REJECT_IND) {
             rspbuf[1] = err;
             len = BLE_LL_CTRL_REJ_IND_LEN + 1;
-        } else {
+        }
+        else {
             rspbuf[1] = rej_opcode;
             rspbuf[2] = err;
             len = BLE_LL_CTRL_REJECT_IND_EXT_LEN + 1;
         }
         ble_ll_conn_enqueue_pkt(connsm, om, BLE_LL_LLID_CTRL, len);
         rc = 0;
-    } else {
+    }
+    else {
         rc = 1;
     }
     return rc;
 }
 
 int
-ble_ll_ctrl_tx_start(struct ble_ll_conn_sm *connsm, struct os_mbuf *txpdu)
+ble_ll_ctrl_tx_start(struct ble_ll_conn_sm* connsm, struct os_mbuf* txpdu)
 {
     uint8_t opcode;
-    uint8_t *ctrdata;
+    uint8_t* ctrdata;
 
     opcode = txpdu->om_data[0];
     ctrdata = &txpdu->om_data[1];
@@ -3143,15 +3333,15 @@ ble_ll_ctrl_tx_start(struct ble_ll_conn_sm *connsm, struct os_mbuf *txpdu)
  * @return int
  */
 int
-ble_ll_ctrl_tx_done(struct os_mbuf *txpdu, struct ble_ll_conn_sm *connsm)
+ble_ll_ctrl_tx_done(struct os_mbuf* txpdu, struct ble_ll_conn_sm* connsm)
 {
     int rc;
     uint8_t opcode;
 
 #if MYNEWT_VAL(BLE_LL_HCI_LLCP_TRACE)
     ble_ll_hci_ev_send_vs_llcp_trace(0x04, connsm->conn_handle,
-                                     connsm->event_cntr,
-                                     txpdu->om_data, txpdu->om_len);
+                                     connsm->event_cntr, txpdu->om_data,
+                                     txpdu->om_len);
 #endif
 
     rc = 0;
@@ -3168,7 +3358,7 @@ ble_ll_ctrl_tx_done(struct os_mbuf *txpdu, struct ble_ll_conn_sm *connsm)
              * peer wanted to start procedure which we already started.
              * Let's wait for response and do not close procedure. */
             if (txpdu->om_data[1] == BLE_LL_CTRL_CONN_PARM_REQ &&
-                            txpdu->om_data[2] != BLE_ERR_LMP_COLLISION) {
+                txpdu->om_data[2] != BLE_ERR_LMP_COLLISION) {
                 connsm->reject_reason = txpdu->om_data[2];
                 connsm->flags.conn_update_host_w4event = 1;
             }
@@ -3206,7 +3396,8 @@ ble_ll_ctrl_tx_done(struct os_mbuf *txpdu, struct ble_ll_conn_sm *connsm)
     case BLE_LL_CTRL_PAUSE_ENC_RSP:
         if (connsm->conn_role == BLE_LL_CONN_ROLE_PERIPHERAL) {
             connsm->enc_data.enc_state = CONN_ENC_S_PAUSE_ENC_RSP_WAIT;
-        } else {
+        }
+        else {
             connsm->flags.pending_encrypt_restart = 1;
         }
         break;
@@ -3216,15 +3407,14 @@ ble_ll_ctrl_tx_done(struct os_mbuf *txpdu, struct ble_ll_conn_sm *connsm)
 #if MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL)
     case BLE_LL_CTRL_PHY_REQ:
         if (connsm->conn_role == BLE_LL_CONN_ROLE_PERIPHERAL) {
-            connsm->phy_tx_transition =
-                    ble_ll_ctrl_phy_tx_transition_get(
-                            connsm->phy_data.pref_mask_tx_req);
+            connsm->phy_tx_transition = ble_ll_ctrl_phy_tx_transition_get(
+                connsm->phy_data.pref_mask_tx_req);
         }
         break;
 #endif
     case BLE_LL_CTRL_PHY_UPDATE_IND:
         connsm->phy_tx_transition =
-                    ble_ll_ctrl_phy_tx_transition_get(txpdu->om_data[2]);
+            ble_ll_ctrl_phy_tx_transition_get(txpdu->om_data[2]);
         break;
 #endif
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_ENHANCED_CONN_UPDATE)
@@ -3244,7 +3434,7 @@ ble_ll_ctrl_tx_done(struct os_mbuf *txpdu, struct ble_ll_conn_sm *connsm)
 }
 
 void
-ble_ll_ctrl_init_conn_sm(struct ble_ll_conn_sm *connsm)
+ble_ll_ctrl_init_conn_sm(struct ble_ll_conn_sm* connsm)
 {
     ble_npl_callout_init(&connsm->ctrl_proc_rsp_timer, &g_ble_ll_data.ll_evq,
                          ble_ll_ctrl_proc_rsp_timer_cb, connsm);
diff --git a/nimble/controller/src/ble_ll_hci.c b/nimble/controller/src/ble_ll_hci.c
index 7e2d707b..c786391b 100644
--- a/nimble/controller/src/ble_ll_hci.c
+++ b/nimble/controller/src/ble_ll_hci.c
@@ -46,7 +46,8 @@
 #include "ble_ll_dtm_priv.h"
 #endif
 
-static void ble_ll_hci_cmd_proc(struct ble_npl_event *ev);
+static void
+ble_ll_hci_cmd_proc(struct ble_npl_event* ev);
 
 /* OS event to enqueue command */
 static struct ble_npl_event g_ble_ll_hci_cmd_ev;
@@ -60,7 +61,7 @@ static int16_t rx_path_pwr_compensation;
 static int16_t tx_path_pwr_compensation;
 
 static ble_ll_hci_post_cmd_complete_cb hci_cmd_post_cb = NULL;
-static void *hci_cmd_post_cb_user_data = NULL;
+static void* hci_cmd_post_cb_user_data = NULL;
 
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_EXT_ADV)
 static enum {
@@ -69,7 +70,8 @@ static enum {
     ADV_MODE_EXT,
 } hci_adv_mode;
 
-bool ble_ll_hci_adv_mode_ext(void)
+bool
+ble_ll_hci_adv_mode_ext(void)
 {
     return hci_adv_mode == ADV_MODE_EXT;
 }
@@ -103,7 +105,7 @@ ble_ll_hci_get_num_cmd_pkts(void)
  * @return int 0: success; -1 otherwise.
  */
 int
-ble_ll_hci_event_send(struct ble_hci_ev *hci_ev)
+ble_ll_hci_event_send(struct ble_hci_ev* hci_ev)
 {
     int rc;
 
@@ -129,8 +131,8 @@ ble_ll_hci_event_send(struct ble_hci_ev *hci_ev)
 void
 ble_ll_hci_send_noop(void)
 {
-    struct ble_hci_ev_command_complete_nop *ev;
-    struct ble_hci_ev *hci_ev;
+    struct ble_hci_ev_command_complete_nop* ev;
+    struct ble_hci_ev* hci_ev;
 
     hci_ev = ble_transport_alloc_evt(0);
     if (hci_ev) {
@@ -138,7 +140,7 @@ ble_ll_hci_send_noop(void)
         hci_ev->opcode = BLE_HCI_EVCODE_COMMAND_COMPLETE;
 
         hci_ev->length = sizeof(*ev);
-        ev = (void *)hci_ev->data;
+        ev = (void*)hci_ev->data;
 
         ev->num_packets = ble_ll_hci_get_num_cmd_pkts();
         ev->opcode = BLE_HCI_OPCODE_NOP;
@@ -158,11 +160,11 @@ ble_ll_hci_send_noop(void)
  * @return int
  */
 static int
-ble_ll_hci_le_encrypt(const uint8_t *cmdbuf, uint8_t len, uint8_t *rspbuf,
-                      uint8_t *rsplen)
+ble_ll_hci_le_encrypt(const uint8_t* cmdbuf, uint8_t len, uint8_t* rspbuf,
+                      uint8_t* rsplen)
 {
-    const struct ble_hci_le_encrypt_cp *cmd = (const void *) cmdbuf;
-    struct ble_hci_le_encrypt_rp *rsp = (void *)rspbuf;
+    const struct ble_hci_le_encrypt_cp* cmd = (const void*)cmdbuf;
+    struct ble_hci_le_encrypt_rp* rsp = (void*)rspbuf;
     struct ble_encryption_block ecb;
     int rc;
 
@@ -174,7 +176,8 @@ ble_ll_hci_le_encrypt(const uint8_t *cmdbuf, uint8_t len, uint8_t *rspbuf,
         swap_buf(rsp->data, ecb.cipher_text, BLE_ENC_BLOCK_SIZE);
         *rsplen = sizeof(*rsp);
         rc = BLE_ERR_SUCCESS;
-    } else {
+    }
+    else {
         rc = BLE_ERR_CTLR_BUSY;
     }
 
@@ -192,11 +195,11 @@ ble_ll_hci_le_encrypt(const uint8_t *cmdbuf, uint8_t len, uint8_t *rspbuf,
  * @return int
  */
 static int
-ble_ll_hci_le_rand(uint8_t *rspbuf, uint8_t *rsplen)
+ble_ll_hci_le_rand(uint8_t* rspbuf, uint8_t* rsplen)
 {
-    struct ble_hci_le_rand_rp *rsp = (void *) rspbuf;
+    struct ble_hci_le_rand_rp* rsp = (void*)rspbuf;
 
-    ble_ll_rand_data_get((uint8_t *)&rsp->random_number,
+    ble_ll_rand_data_get((uint8_t*)&rsp->random_number,
                          sizeof(rsp->random_number));
 
     *rsplen = sizeof(*rsp);
@@ -212,9 +215,9 @@ ble_ll_hci_le_rand(uint8_t *rspbuf, uint8_t *rsplen)
  * @return int
  */
 static int
-ble_ll_hci_rd_local_version(uint8_t *rspbuf, uint8_t *rsplen)
+ble_ll_hci_rd_local_version(uint8_t* rspbuf, uint8_t* rsplen)
 {
-    struct ble_hci_ip_rd_local_ver_rp *rsp = (void *) rspbuf;
+    struct ble_hci_ip_rd_local_ver_rp* rsp = (void*)rspbuf;
 
     rsp->hci_ver = BLE_HCI_VER_BCS;
     rsp->hci_rev = 0;
@@ -235,9 +238,9 @@ ble_ll_hci_rd_local_version(uint8_t *rspbuf, uint8_t *rsplen)
  * @return int
  */
 static int
-ble_ll_hci_rd_local_supp_feat(uint8_t *rspbuf, uint8_t *rsplen)
+ble_ll_hci_rd_local_supp_feat(uint8_t* rspbuf, uint8_t* rsplen)
 {
-    struct ble_hci_ip_rd_loc_supp_feat_rp *rsp = (void *) rspbuf;
+    struct ble_hci_ip_rd_loc_supp_feat_rp* rsp = (void*)rspbuf;
 
     /*
      * The only two bits we set here currently are (5th byte):
@@ -259,9 +262,9 @@ ble_ll_hci_rd_local_supp_feat(uint8_t *rspbuf, uint8_t *rsplen)
  * @return int
  */
 static int
-ble_ll_hci_rd_local_supp_cmd(uint8_t *rspbuf, uint8_t *rsplen)
+ble_ll_hci_rd_local_supp_cmd(uint8_t* rspbuf, uint8_t* rsplen)
 {
-    struct ble_hci_ip_rd_loc_supp_cmd_rp *rsp = (void *) rspbuf;
+    struct ble_hci_ip_rd_loc_supp_cmd_rp* rsp = (void*)rspbuf;
 
     ble_ll_hci_supp_cmd_get(rsp->commands);
 
@@ -279,9 +282,9 @@ ble_ll_hci_rd_local_supp_cmd(uint8_t *rspbuf, uint8_t *rsplen)
  * @return int
  */
 static int
-ble_ll_hci_rd_bd_addr(uint8_t *rspbuf, uint8_t *rsplen)
+ble_ll_hci_rd_bd_addr(uint8_t* rspbuf, uint8_t* rsplen)
 {
-    struct ble_hci_ip_rd_bd_addr_rp *rsp = (void *) rspbuf;
+    struct ble_hci_ip_rd_bd_addr_rp* rsp = (void*)rspbuf;
 
     memcpy(rsp->addr, g_dev_addr, BLE_DEV_ADDR_LEN);
 
@@ -301,9 +304,9 @@ ble_ll_hci_rd_bd_addr(uint8_t *rspbuf, uint8_t *rsplen)
  * @return int BLE_ERR_SUCCESS. Does not return any errors.
  */
 static int
-ble_ll_hci_set_le_event_mask(const uint8_t *cmdbuf, uint8_t len)
+ble_ll_hci_set_le_event_mask(const uint8_t* cmdbuf, uint8_t len)
 {
-    const struct ble_hci_le_set_event_mask_cp *cmd = (const void *) cmdbuf;
+    const struct ble_hci_le_set_event_mask_cp* cmd = (const void*)cmdbuf;
 
     if (len != sizeof(*cmd)) {
         return BLE_ERR_INV_HCI_CMD_PARMS;
@@ -324,9 +327,9 @@ ble_ll_hci_set_le_event_mask(const uint8_t *cmdbuf, uint8_t len)
  * @return int BLE error code
  */
 static int
-ble_ll_hci_le_read_bufsize(uint8_t *rspbuf, uint8_t *rsplen)
+ble_ll_hci_le_read_bufsize(uint8_t* rspbuf, uint8_t* rsplen)
 {
-    struct ble_hci_le_rd_buf_size_rp *rp = (void *) rspbuf;
+    struct ble_hci_le_rd_buf_size_rp* rp = (void*)rspbuf;
 
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL) || MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL)
     rp->data_len = htole16(g_ble_ll_data.ll_acl_pkt_size);
@@ -352,10 +355,9 @@ ble_ll_hci_le_read_bufsize(uint8_t *rspbuf, uint8_t *rsplen)
  * @return int BLE error code
  */
 static int
-ble_ll_hci_le_read_bufsize_v2(uint8_t *rspbuf, uint8_t *rsplen)
+ble_ll_hci_le_read_bufsize_v2(uint8_t* rspbuf, uint8_t* rsplen)
 {
-    struct ble_hci_le_rd_buf_size_v2_rp *rp = (void *) rspbuf;
-
+    struct ble_hci_le_rd_buf_size_v2_rp* rp = (void*)rspbuf;
 
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL) || MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL)
     rp->data_len = htole16(g_ble_ll_data.ll_acl_pkt_size);
@@ -381,11 +383,11 @@ ble_ll_hci_le_read_bufsize_v2(uint8_t *rspbuf, uint8_t *rsplen)
  */
 int
 ble_ll_hci_chk_phy_masks(uint8_t all_phys, uint8_t tx_phys, uint8_t rx_phys,
-                         uint8_t *txphy, uint8_t *rxphy)
+                         uint8_t* txphy, uint8_t* rxphy)
 {
     /* Check for RFU */
     if ((tx_phys & ~BLE_HCI_LE_PHY_PREF_MASK_ALL) ||
-                    (rx_phys & ~BLE_HCI_LE_PHY_PREF_MASK_ALL)) {
+        (rx_phys & ~BLE_HCI_LE_PHY_PREF_MASK_ALL)) {
         return BLE_ERR_UNSUPPORTED;
     }
 
@@ -396,14 +398,14 @@ ble_ll_hci_chk_phy_masks(uint8_t all_phys, uint8_t tx_phys, uint8_t rx_phys,
 
     /* If phy not supported, return error */
 #if !MYNEWT_VAL(BLE_LL_CFG_FEAT_LE_2M_PHY)
-    if((tx_phys & BLE_HCI_LE_PHY_2M_PREF_MASK) ||
-                    (rx_phys & BLE_HCI_LE_PHY_2M_PREF_MASK)) {
+    if ((tx_phys & BLE_HCI_LE_PHY_2M_PREF_MASK) ||
+        (rx_phys & BLE_HCI_LE_PHY_2M_PREF_MASK)) {
         return BLE_ERR_UNSUPPORTED;
     }
 #endif
 #if !MYNEWT_VAL(BLE_LL_CFG_FEAT_LE_CODED_PHY)
     if ((tx_phys & BLE_HCI_LE_PHY_CODED_PREF_MASK) ||
-                    (rx_phys & BLE_HCI_LE_PHY_CODED_PREF_MASK)) {
+        (rx_phys & BLE_HCI_LE_PHY_CODED_PREF_MASK)) {
         return BLE_ERR_UNSUPPORTED;
     }
 #endif
@@ -430,9 +432,9 @@ ble_ll_hci_chk_phy_masks(uint8_t all_phys, uint8_t tx_phys, uint8_t rx_phys,
  */
 #if MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL) || MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
 static int
-ble_ll_hci_le_set_def_phy(const uint8_t *cmdbuf, uint8_t len)
+ble_ll_hci_le_set_def_phy(const uint8_t* cmdbuf, uint8_t len)
 {
-    const struct ble_hci_le_set_default_phy_cp *cmd = (const void *) cmdbuf;
+    const struct ble_hci_le_set_default_phy_cp* cmd = (const void*)cmdbuf;
     int rc;
 
     if (len != sizeof(*cmd)) {
@@ -473,9 +475,9 @@ ble_ll_hci_check_dle(uint16_t max_octets, uint16_t max_time)
  * @return int BLE error code
  */
 static int
-ble_ll_hci_le_wr_sugg_data_len(const uint8_t *cmdbuf, uint8_t len)
+ble_ll_hci_le_wr_sugg_data_len(const uint8_t* cmdbuf, uint8_t len)
 {
-    const struct ble_hci_le_wr_sugg_def_data_len_cp *cmd = (const void *)cmdbuf;
+    const struct ble_hci_le_wr_sugg_def_data_len_cp* cmd = (const void*)cmdbuf;
     uint16_t tx_octets;
     uint16_t tx_time;
 
@@ -528,9 +530,9 @@ ble_ll_hci_le_wr_sugg_data_len(const uint8_t *cmdbuf, uint8_t len)
  * @return int BLE error code
  */
 static int
-ble_ll_hci_le_rd_sugg_data_len(uint8_t *rspbuf, uint8_t *rsplen)
+ble_ll_hci_le_rd_sugg_data_len(uint8_t* rspbuf, uint8_t* rsplen)
 {
-    struct ble_hci_le_rd_sugg_def_data_len_rp *rsp = (void *) rspbuf;
+    struct ble_hci_le_rd_sugg_def_data_len_rp* rsp = (void*)rspbuf;
 
     /* Place the data packet length and number of packets in the buffer */
     rsp->max_tx_octets = htole16(g_ble_ll_conn_params.sugg_tx_octets);
@@ -550,9 +552,9 @@ ble_ll_hci_le_rd_sugg_data_len(uint8_t *rspbuf, uint8_t *rsplen)
  * @return int BLE error code
  */
 static int
-ble_ll_hci_le_rd_max_data_len(uint8_t *rspbuf, uint8_t *rsplen)
+ble_ll_hci_le_rd_max_data_len(uint8_t* rspbuf, uint8_t* rsplen)
 {
-    struct ble_hci_le_rd_max_data_len_rp *rsp = (void *)rspbuf;
+    struct ble_hci_le_rd_max_data_len_rp* rsp = (void*)rspbuf;
 
     /* Place the data packet length and number of packets in the buffer */
     rsp->max_tx_octests = htole16(g_ble_ll_conn_params.supp_max_tx_octets);
@@ -575,9 +577,9 @@ ble_ll_hci_le_rd_max_data_len(uint8_t *rspbuf, uint8_t *rsplen)
  * @return int BLE error code
  */
 static int
-ble_ll_hci_le_read_local_features(uint8_t *rspbuf, uint8_t *rsplen)
+ble_ll_hci_le_read_local_features(uint8_t* rspbuf, uint8_t* rsplen)
 {
-    struct ble_hci_le_rd_loc_supp_feat_rp *rsp = (void *) rspbuf;
+    struct ble_hci_le_rd_loc_supp_feat_rp* rsp = (void*)rspbuf;
 
     rsp->features = htole64(ble_ll_read_supp_features());
 
@@ -595,9 +597,9 @@ ble_ll_hci_le_read_local_features(uint8_t *rspbuf, uint8_t *rsplen)
  * @return int BLE error code
  */
 static int
-ble_ll_hci_le_read_supp_states(uint8_t *rspbuf, uint8_t *rsplen)
+ble_ll_hci_le_read_supp_states(uint8_t* rspbuf, uint8_t* rsplen)
 {
-    struct ble_hci_le_rd_supp_states_rp *rsp = (void *) rspbuf;
+    struct ble_hci_le_rd_supp_states_rp* rsp = (void*)rspbuf;
 
     /* Add list of supported states. */
     rsp->states = htole64(ble_ll_read_supp_states());
@@ -606,7 +608,6 @@ ble_ll_hci_le_read_supp_states(uint8_t *rspbuf, uint8_t *rsplen)
     return BLE_ERR_SUCCESS;
 }
 
-
 /**
  * Checks to see if a LE event has been disabled by the host.
  *
@@ -699,9 +700,9 @@ ble_ll_hci_le_cmd_send_cmd_status(uint16_t ocf)
 * @return int BLE error code
 */
 static int
-ble_ll_adv_rd_max_adv_data_len(uint8_t *rspbuf, uint8_t *rsplen)
+ble_ll_adv_rd_max_adv_data_len(uint8_t* rspbuf, uint8_t* rsplen)
 {
-    struct ble_hci_le_rd_max_adv_data_len_rp *rsp = (void *) rspbuf;
+    struct ble_hci_le_rd_max_adv_data_len_rp* rsp = (void*)rspbuf;
 
     rsp->max_adv_data_len = htole16(BLE_ADV_DATA_MAX_LEN);
 
@@ -718,9 +719,9 @@ ble_ll_adv_rd_max_adv_data_len(uint8_t *rspbuf, uint8_t *rsplen)
  * @return int BLE error code
  */
 static int
-ble_ll_adv_rd_sup_adv_sets(uint8_t *rspbuf, uint8_t *rsplen)
+ble_ll_adv_rd_sup_adv_sets(uint8_t* rspbuf, uint8_t* rsplen)
 {
-    struct ble_hci_le_rd_num_of_adv_sets_rp *rsp = (void *)rspbuf;
+    struct ble_hci_le_rd_num_of_adv_sets_rp* rsp = (void*)rspbuf;
 
     rsp->num_sets = BLE_ADV_INSTANCES;
 
@@ -740,7 +741,7 @@ ble_ll_is_valid_adv_mode(uint8_t ocf)
      * Disallowed (0x0C).
     */
 
-    switch(ocf) {
+    switch (ocf) {
     case BLE_HCI_OCF_LE_CREATE_CONN:
     case BLE_HCI_OCF_LE_SET_ADV_PARAMS:
     case BLE_HCI_OCF_LE_SET_ADV_ENABLE:
@@ -800,9 +801,9 @@ ble_ll_is_valid_adv_mode(uint8_t ocf)
 #endif
 
 static int
-ble_ll_read_tx_power(uint8_t *rspbuf, uint8_t *rsplen)
+ble_ll_read_tx_power(uint8_t* rspbuf, uint8_t* rsplen)
 {
-    struct ble_hci_le_rd_transmit_power_rp *rsp = (void *) rspbuf;
+    struct ble_hci_le_rd_transmit_power_rp* rsp = (void*)rspbuf;
 
     rsp->min_tx_power = ble_ll_tx_power_round(-127);
     rsp->max_tx_power = ble_ll_tx_power_round(126);
@@ -812,9 +813,9 @@ ble_ll_read_tx_power(uint8_t *rspbuf, uint8_t *rsplen)
 }
 
 static int
-ble_ll_read_rf_path_compensation(uint8_t *rspbuf, uint8_t *rsplen)
+ble_ll_read_rf_path_compensation(uint8_t* rspbuf, uint8_t* rsplen)
 {
-    struct ble_hci_le_rd_rf_path_compensation_rp *rsp = (void *) rspbuf;
+    struct ble_hci_le_rd_rf_path_compensation_rp* rsp = (void*)rspbuf;
 
     rsp->rx_path_compensation = htole16(rx_path_pwr_compensation);
     rsp->tx_path_compensation = htole16(tx_path_pwr_compensation);
@@ -824,9 +825,10 @@ ble_ll_read_rf_path_compensation(uint8_t *rspbuf, uint8_t *rsplen)
 }
 
 static int
-ble_ll_write_rf_path_compensation(const uint8_t *cmdbuf, uint8_t len)
+ble_ll_write_rf_path_compensation(const uint8_t* cmdbuf, uint8_t len)
 {
-    const struct ble_hci_le_wr_rf_path_compensation_cp *cmd = (const void *)cmdbuf;
+    const struct ble_hci_le_wr_rf_path_compensation_cp* cmd =
+        (const void*)cmdbuf;
     int16_t rx;
     int16_t tx;
 
@@ -851,9 +853,9 @@ ble_ll_write_rf_path_compensation(const uint8_t *cmdbuf, uint8_t len)
 }
 
 static int
-ble_ll_hci_le_set_host_chan_class(const uint8_t *cmdbuf, uint8_t len)
+ble_ll_hci_le_set_host_chan_class(const uint8_t* cmdbuf, uint8_t len)
 {
-    const struct ble_hci_le_set_host_chan_class_cp *cmd = (const void *)cmdbuf;
+    const struct ble_hci_le_set_host_chan_class_cp* cmd = (const void*)cmdbuf;
     uint8_t chan_map_used;
 
     if (len != sizeof(*cmd)) {
@@ -898,8 +900,8 @@ ble_ll_hci_le_set_host_chan_class(const uint8_t *cmdbuf, uint8_t len)
  *              256 gets added to the return value.
  */
 static int
-ble_ll_hci_le_cmd_proc(const uint8_t *cmdbuf, uint8_t len, uint16_t ocf,
-                       uint8_t *rspbuf, uint8_t *rsplen)
+ble_ll_hci_le_cmd_proc(const uint8_t* cmdbuf, uint8_t len, uint16_t ocf,
+                       uint8_t* rspbuf, uint8_t* rsplen)
 {
     int rc;
 
@@ -1041,7 +1043,7 @@ ble_ll_hci_le_cmd_proc(const uint8_t *cmdbuf, uint8_t len, uint16_t ocf,
         break;
 #endif
 #endif
-    case BLE_HCI_OCF_LE_RD_SUPP_STATES :
+    case BLE_HCI_OCF_LE_RD_SUPP_STATES:
         if (len == 0) {
             rc = ble_ll_hci_le_read_supp_states(rspbuf, rsplen);
         }
@@ -1153,7 +1155,7 @@ ble_ll_hci_le_cmd_proc(const uint8_t *cmdbuf, uint8_t len, uint16_t ocf,
         rc = ble_ll_adv_ext_set_scan_rsp(cmdbuf, len);
         break;
     case BLE_HCI_OCF_LE_SET_EXT_ADV_ENABLE:
-        rc =  ble_ll_adv_ext_set_enable(cmdbuf, len);
+        rc = ble_ll_adv_ext_set_enable(cmdbuf, len);
         break;
     case BLE_HCI_OCF_LE_RD_MAX_ADV_DATA_LEN:
         if (len == 0) {
@@ -1166,11 +1168,11 @@ ble_ll_hci_le_cmd_proc(const uint8_t *cmdbuf, uint8_t len, uint16_t ocf,
         }
         break;
     case BLE_HCI_OCF_LE_REMOVE_ADV_SET:
-        rc =  ble_ll_adv_remove(cmdbuf, len);
+        rc = ble_ll_adv_remove(cmdbuf, len);
         break;
     case BLE_HCI_OCF_LE_CLEAR_ADV_SETS:
         if (len == 0) {
-            rc =  ble_ll_adv_clear_all();
+            rc = ble_ll_adv_clear_all();
         }
         break;
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_PERIODIC_ADV)
@@ -1305,8 +1307,7 @@ ble_ll_hci_le_cmd_proc(const uint8_t *cmdbuf, uint8_t len, uint16_t ocf,
 #endif
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_SCA_UPDATE)
     case BLE_HCI_OCF_LE_REQ_PEER_SCA:
-        rc = ble_ll_conn_req_peer_sca(cmdbuf, len,
-                                      rspbuf, rsplen);
+        rc = ble_ll_conn_req_peer_sca(cmdbuf, len, rspbuf, rsplen);
         break;
 #endif
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_LL_ENHANCED_CONN_UPDATE)
@@ -1370,6 +1371,12 @@ ble_ll_hci_le_cmd_proc(const uint8_t *cmdbuf, uint8_t len, uint16_t ocf,
         rc = ble_ll_cs_hci_test_end();
         break;
 #endif
+    case BLE_HCI_OCF_LE_F_ENCRYPT:
+        rc = ble_ll_conn_hci_le_start_encryption(cmdbuf, len);
+        break;
+    case BLE_HCI_OCF_LE_REKEY:
+        rc = ble_ll_conn_hci_le_start_rekey(cmdbuf, len);
+        break;
     default:
         rc = BLE_ERR_UNKNOWN_HCI_CMD;
         break;
@@ -1389,13 +1396,13 @@ ble_ll_hci_le_cmd_proc(const uint8_t *cmdbuf, uint8_t len, uint16_t ocf,
 
 #if MYNEWT_VAL(BLE_LL_ROLE_CENTRAL) || MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL)
 static int
-ble_ll_hci_disconnect(const uint8_t *cmdbuf, uint8_t len)
+ble_ll_hci_disconnect(const uint8_t* cmdbuf, uint8_t len)
 {
-    const struct ble_hci_lc_disconnect_cp *cmd;
+    const struct ble_hci_lc_disconnect_cp* cmd;
 
-    cmd = (const void *) cmdbuf;
+    cmd = (const void*)cmdbuf;
 
-    if (len != sizeof (*cmd)) {
+    if (len != sizeof(*cmd)) {
         return BLE_ERR_INV_HCI_CMD_PARMS;
     }
 
@@ -1417,7 +1424,7 @@ ble_ll_hci_disconnect(const uint8_t *cmdbuf, uint8_t len)
  *              256 gets added to the return value.
  */
 static int
-ble_ll_hci_link_ctrl_cmd_proc(const uint8_t *cmdbuf, uint8_t len, uint16_t ocf)
+ble_ll_hci_link_ctrl_cmd_proc(const uint8_t* cmdbuf, uint8_t len, uint16_t ocf)
 {
     int rc;
 
@@ -1443,11 +1450,11 @@ ble_ll_hci_link_ctrl_cmd_proc(const uint8_t *cmdbuf, uint8_t len, uint16_t ocf)
 }
 
 static int
-ble_ll_hci_cb_set_event_mask(const uint8_t *cmdbuf, uint8_t len)
+ble_ll_hci_cb_set_event_mask(const uint8_t* cmdbuf, uint8_t len)
 {
-    const struct ble_hci_cb_set_event_mask_cp *cmd = (const void *) cmdbuf;
+    const struct ble_hci_cb_set_event_mask_cp* cmd = (const void*)cmdbuf;
 
-    if (len != sizeof (*cmd)) {
+    if (len != sizeof(*cmd)) {
         return BLE_ERR_INV_HCI_CMD_PARMS;
     }
 
@@ -1458,11 +1465,11 @@ ble_ll_hci_cb_set_event_mask(const uint8_t *cmdbuf, uint8_t len)
 
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_CTRL_TO_HOST_FLOW_CONTROL)
 static int
-ble_ll_hci_cb_set_ctrlr_to_host_fc(const uint8_t *cmdbuf, uint8_t len)
+ble_ll_hci_cb_set_ctrlr_to_host_fc(const uint8_t* cmdbuf, uint8_t len)
 {
-    const struct ble_hci_cb_ctlr_to_host_fc_cp *cmd = (const void *) cmdbuf;
+    const struct ble_hci_cb_ctlr_to_host_fc_cp* cmd = (const void*)cmdbuf;
 
-    if (len != sizeof (*cmd)) {
+    if (len != sizeof(*cmd)) {
         return BLE_ERR_INV_HCI_CMD_PARMS;
     }
 
@@ -1479,13 +1486,13 @@ ble_ll_hci_cb_set_ctrlr_to_host_fc(const uint8_t *cmdbuf, uint8_t len)
 }
 
 static int
-ble_ll_hci_cb_host_buf_size(const uint8_t *cmdbuf, uint8_t len)
+ble_ll_hci_cb_host_buf_size(const uint8_t* cmdbuf, uint8_t len)
 {
-    const struct ble_hci_cb_host_buf_size_cp *cmd = (const void *) cmdbuf;
+    const struct ble_hci_cb_host_buf_size_cp* cmd = (const void*)cmdbuf;
     uint16_t acl_num;
     uint16_t acl_data_len;
 
-    if (len != sizeof (*cmd)) {
+    if (len != sizeof(*cmd)) {
         return BLE_ERR_INV_HCI_CMD_PARMS;
     }
 
@@ -1507,11 +1514,11 @@ ble_ll_hci_cb_host_buf_size(const uint8_t *cmdbuf, uint8_t len)
 #endif
 
 static int
-ble_ll_hci_cb_set_event_mask2(const uint8_t *cmdbuf, uint8_t len)
+ble_ll_hci_cb_set_event_mask2(const uint8_t* cmdbuf, uint8_t len)
 {
-    const struct ble_hci_cb_set_event_mask2_cp *cmd = (const void *) cmdbuf;
+    const struct ble_hci_cb_set_event_mask2_cp* cmd = (const void*)cmdbuf;
 
-    if (len != sizeof (*cmd)) {
+    if (len != sizeof(*cmd)) {
         return BLE_ERR_INV_HCI_CMD_PARMS;
     }
 
@@ -1521,8 +1528,8 @@ ble_ll_hci_cb_set_event_mask2(const uint8_t *cmdbuf, uint8_t len)
 }
 
 static int
-ble_ll_hci_ctlr_bb_cmd_proc(const uint8_t *cmdbuf, uint8_t len, uint16_t ocf,
-                            uint8_t *rspbuf, uint8_t *rsplen)
+ble_ll_hci_ctlr_bb_cmd_proc(const uint8_t* cmdbuf, uint8_t len, uint16_t ocf,
+                            uint8_t* rspbuf, uint8_t* rsplen)
 {
     int rc;
 
@@ -1557,8 +1564,8 @@ ble_ll_hci_ctlr_bb_cmd_proc(const uint8_t *cmdbuf, uint8_t len, uint16_t ocf,
     case BLE_HCI_OCF_CB_SET_EVENT_MASK2:
         rc = ble_ll_hci_cb_set_event_mask2(cmdbuf, len);
         break;
-#if (MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL) || MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)) \
-        && MYNEWT_VAL(BLE_LL_CFG_FEAT_LE_PING)
+#if (MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL) || MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)) && \
+    MYNEWT_VAL(BLE_LL_CFG_FEAT_LE_PING)
     case BLE_HCI_OCF_CB_RD_AUTH_PYLD_TMO:
         rc = ble_ll_conn_hci_rd_auth_pyld_tmo(cmdbuf, len, rspbuf, rsplen);
         break;
@@ -1575,8 +1582,8 @@ ble_ll_hci_ctlr_bb_cmd_proc(const uint8_t *cmdbuf, uint8_t len, uint16_t ocf,
 }
 
 static int
-ble_ll_hci_info_params_cmd_proc(const uint8_t *cmdbuf, uint8_t len,
-                                uint16_t ocf, uint8_t *rspbuf, uint8_t *rsplen)
+ble_ll_hci_info_params_cmd_proc(const uint8_t* cmdbuf, uint8_t len,
+                                uint16_t ocf, uint8_t* rspbuf, uint8_t* rsplen)
 {
     int rc;
 
@@ -1613,9 +1620,9 @@ ble_ll_hci_info_params_cmd_proc(const uint8_t *cmdbuf, uint8_t len,
 }
 
 static int
-ble_ll_hci_status_params_cmd_proc(const uint8_t *cmdbuf, uint8_t len,
-                                  uint16_t ocf, uint8_t *rspbuf,
-                                  uint8_t *rsplen)
+ble_ll_hci_status_params_cmd_proc(const uint8_t* cmdbuf, uint8_t len,
+                                  uint16_t ocf, uint8_t* rspbuf,
+                                  uint8_t* rsplen)
 {
     int rc;
 
@@ -1635,9 +1642,9 @@ ble_ll_hci_status_params_cmd_proc(const uint8_t *cmdbuf, uint8_t len,
 
 #if MYNEWT_VAL(BLE_LL_HBD_FAKE_DUAL_MODE)
 static void
-ble_ll_hci_cmd_fake_dual_mode_inquiry_complete(struct ble_npl_event *ev)
+ble_ll_hci_cmd_fake_dual_mode_inquiry_complete(struct ble_npl_event* ev)
 {
-    struct ble_hci_ev *hci_ev;
+    struct ble_hci_ev* hci_ev;
 
     hci_ev = ble_transport_alloc_evt(1);
     if (!hci_ev) {
@@ -1666,14 +1673,15 @@ ble_ll_hci_cmd_fake_dual_mode_inquiry(uint32_t length)
     if (length) {
         ble_npl_callout_reset(&inquiry_timer,
                               ble_npl_time_ms_to_ticks32(length * 1280));
-    } else {
+    }
+    else {
         ble_npl_callout_stop(&inquiry_timer);
     }
 }
 
 static int
-ble_ll_hci_cmd_fake_dual_mode(uint16_t opcode,  uint8_t *cmdbuf, uint8_t len,
-                              uint8_t *rspbuf, uint8_t *rsplen)
+ble_ll_hci_cmd_fake_dual_mode(uint16_t opcode, uint8_t* cmdbuf, uint8_t len,
+                              uint8_t* rspbuf, uint8_t* rsplen)
 {
     int rc;
 
@@ -1688,23 +1696,31 @@ ble_ll_hci_cmd_fake_dual_mode(uint16_t opcode,  uint8_t *cmdbuf, uint8_t len,
         break;
     case BLE_HCI_OP(BLE_HCI_OGF_CTLR_BASEBAND, 0x05): /* Set Event Filter */
     case BLE_HCI_OP(BLE_HCI_OGF_CTLR_BASEBAND, 0x13): /* Write Local Name */
-    case BLE_HCI_OP(BLE_HCI_OGF_CTLR_BASEBAND, 0x16): /* Write Connection Accept Timeout */
+    case BLE_HCI_OP(BLE_HCI_OGF_CTLR_BASEBAND,
+                    0x16): /* Write Connection Accept Timeout */
     case BLE_HCI_OP(BLE_HCI_OGF_CTLR_BASEBAND, 0x18): /* Write Page Timeout */
     case BLE_HCI_OP(BLE_HCI_OGF_CTLR_BASEBAND, 0x1a): /* Write Scan Enable */
-    case BLE_HCI_OP(BLE_HCI_OGF_CTLR_BASEBAND, 0x1c): /* Write Page Scan Activity */
-    case BLE_HCI_OP(BLE_HCI_OGF_CTLR_BASEBAND, 0x1e): /* Write Inquiry Scan Activity */
-    case BLE_HCI_OP(BLE_HCI_OGF_CTLR_BASEBAND, 0x20): /* Write Authentication Enable */
-    case BLE_HCI_OP(BLE_HCI_OGF_CTLR_BASEBAND, 0x24): /* Write Class Of Device */
+    case BLE_HCI_OP(BLE_HCI_OGF_CTLR_BASEBAND,
+                    0x1c): /* Write Page Scan Activity */
+    case BLE_HCI_OP(BLE_HCI_OGF_CTLR_BASEBAND,
+                    0x1e): /* Write Inquiry Scan Activity */
+    case BLE_HCI_OP(BLE_HCI_OGF_CTLR_BASEBAND,
+                    0x20): /* Write Authentication Enable */
+    case BLE_HCI_OP(BLE_HCI_OGF_CTLR_BASEBAND,
+                    0x24): /* Write Class Of Device */
     case BLE_HCI_OP(BLE_HCI_OGF_CTLR_BASEBAND, 0x33): /* Host Buffer Size */
     case BLE_HCI_OP(BLE_HCI_OGF_CTLR_BASEBAND, 0x45): /* Write Inquiry Mode */
-    case BLE_HCI_OP(BLE_HCI_OGF_CTLR_BASEBAND, 0x52): /* Write Extended Inquiry Response */
-    case BLE_HCI_OP(BLE_HCI_OGF_CTLR_BASEBAND, 0x56): /* Write Simple Pairing Mode */
-    case BLE_HCI_OP(BLE_HCI_OGF_CTLR_BASEBAND, 0x6d): /* Write LE Host Support */
+    case BLE_HCI_OP(BLE_HCI_OGF_CTLR_BASEBAND,
+                    0x52): /* Write Extended Inquiry Response */
+    case BLE_HCI_OP(BLE_HCI_OGF_CTLR_BASEBAND,
+                    0x56): /* Write Simple Pairing Mode */
+    case BLE_HCI_OP(BLE_HCI_OGF_CTLR_BASEBAND,
+                    0x6d): /* Write LE Host Support */
         rc = 0;
         break;
     case BLE_HCI_OP(BLE_HCI_OGF_CTLR_BASEBAND, 0x14): /* Read Local Name */
         memset(rspbuf, 0, 248);
-        strcpy((char *)rspbuf, "NimBLE");
+        strcpy((char*)rspbuf, "NimBLE");
         *rsplen = 248;
         rc = 0;
         break;
@@ -1718,7 +1734,8 @@ ble_ll_hci_cmd_fake_dual_mode(uint16_t opcode,  uint8_t *cmdbuf, uint8_t len,
         *rsplen = 2;
         rc = 0;
         break;
-    case BLE_HCI_OP(BLE_HCI_OGF_CTLR_BASEBAND, 0x38): /* Read Number Of Supported IAC */
+    case BLE_HCI_OP(BLE_HCI_OGF_CTLR_BASEBAND,
+                    0x38): /* Read Number Of Supported IAC */
         rspbuf[0] = 1;
         *rsplen = 1;
         rc = 0;
@@ -1729,7 +1746,8 @@ ble_ll_hci_cmd_fake_dual_mode(uint16_t opcode,  uint8_t *cmdbuf, uint8_t len,
         *rsplen = 4;
         rc = 0;
         break;
-    case BLE_HCI_OP(BLE_HCI_OGF_CTLR_BASEBAND, 0x58): /* Read Inquiry Response Transmit Power Level */
+    case BLE_HCI_OP(BLE_HCI_OGF_CTLR_BASEBAND,
+                    0x58): /* Read Inquiry Response Transmit Power Level */
         rspbuf[0] = 0x04;
         *rsplen = 1;
         rc = 0;
@@ -1739,7 +1757,8 @@ ble_ll_hci_cmd_fake_dual_mode(uint16_t opcode,  uint8_t *cmdbuf, uint8_t len,
         *rsplen = 8;
         rc = 0;
         break;
-    case BLE_HCI_OP(BLE_HCI_OGF_INFO_PARAMS, 0x04): /* Read Local Extended Features */
+    case BLE_HCI_OP(BLE_HCI_OGF_INFO_PARAMS,
+                    0x04): /* Read Local Extended Features */
         rspbuf[0] = 0;
         rspbuf[1] = 0;
         put_le64(&rspbuf[2], 0x877bffdbfe0ffebf);
@@ -1767,9 +1786,8 @@ ble_ll_hci_cmd_fake_dual_mode(uint16_t opcode,  uint8_t *cmdbuf, uint8_t len,
 }
 #endif
 
-
 void
-ble_ll_hci_post_cmd_cb_set(ble_ll_hci_post_cmd_complete_cb cb, void *user_data)
+ble_ll_hci_post_cmd_cb_set(ble_ll_hci_post_cmd_complete_cb cb, void* user_data)
 {
     BLE_LL_ASSERT(hci_cmd_post_cb == NULL);
     hci_cmd_post_cb = cb;
@@ -1782,18 +1800,18 @@ ble_ll_hci_post_cmd_cb_set(ble_ll_hci_post_cmd_complete_cb cb, void *user_data)
  * @param ev Pointer to os event containing a pointer to command buffer
  */
 static void
-ble_ll_hci_cmd_proc(struct ble_npl_event *ev)
+ble_ll_hci_cmd_proc(struct ble_npl_event* ev)
 {
     int rc;
     uint8_t ogf;
     uint8_t rsplen;
-    struct ble_hci_cmd *cmd;
+    struct ble_hci_cmd* cmd;
     uint16_t opcode;
     uint16_t ocf;
-    struct ble_hci_ev *hci_ev;
-    struct ble_hci_ev_command_status *cmd_status;
-    struct ble_hci_ev_command_complete *cmd_complete;
-    uint8_t *rspbuf;
+    struct ble_hci_ev* hci_ev;
+    struct ble_hci_ev_command_status* cmd_status;
+    struct ble_hci_ev_command_complete* cmd_complete;
+    uint8_t* rspbuf;
 
     BLE_LL_DEBUG_GPIO(HCI_CMD, 1);
 
@@ -1812,7 +1830,7 @@ ble_ll_hci_cmd_proc(struct ble_npl_event *ev)
      * before crafting a response.
      * Also reuse cmd buffer for complete event
      */
-    hci_ev = (struct ble_hci_ev *) cmd;
+    hci_ev = (struct ble_hci_ev*)cmd;
     rspbuf = hci_ev->data + sizeof(*cmd_complete);
 
     /* Assume response length is zero */
@@ -1835,8 +1853,8 @@ ble_ll_hci_cmd_proc(struct ble_npl_event *ev)
 #endif
 
 #if MYNEWT_VAL(BLE_LL_HBD_FAKE_DUAL_MODE)
-    rc = ble_ll_hci_cmd_fake_dual_mode(opcode, cmd->data, cmd->length,
-                                       rspbuf, &rsplen);
+    rc = ble_ll_hci_cmd_fake_dual_mode(opcode, cmd->data, cmd->length, rspbuf,
+                                       &rsplen);
     if (rc >= 0) {
         goto send_cc_cs;
     }
@@ -1847,20 +1865,25 @@ ble_ll_hci_cmd_proc(struct ble_npl_event *ev)
         rc = ble_ll_hci_link_ctrl_cmd_proc(cmd->data, cmd->length, ocf);
         break;
     case BLE_HCI_OGF_CTLR_BASEBAND:
-        rc = ble_ll_hci_ctlr_bb_cmd_proc(cmd->data, cmd->length, ocf, rspbuf, &rsplen);
+        rc = ble_ll_hci_ctlr_bb_cmd_proc(cmd->data, cmd->length, ocf, rspbuf,
+                                         &rsplen);
         break;
     case BLE_HCI_OGF_INFO_PARAMS:
-        rc = ble_ll_hci_info_params_cmd_proc(cmd->data, cmd->length, ocf, rspbuf, &rsplen);
+        rc = ble_ll_hci_info_params_cmd_proc(cmd->data, cmd->length, ocf,
+                                             rspbuf, &rsplen);
         break;
     case BLE_HCI_OGF_STATUS_PARAMS:
-        rc = ble_ll_hci_status_params_cmd_proc(cmd->data, cmd->length, ocf, rspbuf, &rsplen);
+        rc = ble_ll_hci_status_params_cmd_proc(cmd->data, cmd->length, ocf,
+                                               rspbuf, &rsplen);
         break;
     case BLE_HCI_OGF_LE:
-        rc = ble_ll_hci_le_cmd_proc(cmd->data, cmd->length, ocf, rspbuf, &rsplen);
+        rc = ble_ll_hci_le_cmd_proc(cmd->data, cmd->length, ocf, rspbuf,
+                                    &rsplen);
         break;
 #if MYNEWT_VAL(BLE_LL_HCI_VS)
     case BLE_HCI_OGF_VENDOR:
-        rc = ble_ll_hci_vs_cmd_proc(cmd->data, cmd->length, ocf, rspbuf, &rsplen);
+        rc = ble_ll_hci_vs_cmd_proc(cmd->data, cmd->length, ocf, rspbuf,
+                                    &rsplen);
         break;
 #endif
     default:
@@ -1886,18 +1909,19 @@ send_cc_cs:
         hci_ev->opcode = BLE_HCI_EVCODE_COMMAND_COMPLETE;
         hci_ev->length = sizeof(*cmd_complete) + rsplen;
 
-        cmd_complete = (void *) hci_ev->data;
+        cmd_complete = (void*)hci_ev->data;
         cmd_complete->num_packets = ble_ll_hci_get_num_cmd_pkts();
         cmd_complete->opcode = htole16(opcode);
-        cmd_complete->status = (uint8_t) rc;
-    } else {
+        cmd_complete->status = (uint8_t)rc;
+    }
+    else {
         /* Create a command status event */
         rc -= (BLE_ERR_MAX + 1);
 
         hci_ev->opcode = BLE_HCI_EVCODE_COMMAND_STATUS;
         hci_ev->length = sizeof(*cmd_status);
 
-        cmd_status = (void *) hci_ev->data;
+        cmd_status = (void*)hci_ev->data;
         cmd_status->status = (uint8_t)rc;
         cmd_status->num_packets = ble_ll_hci_get_num_cmd_pkts();
         cmd_status->opcode = htole16(opcode);
@@ -1906,7 +1930,8 @@ send_cc_cs:
     /* Count commands and those in error */
     if (rc) {
         STATS_INC(ble_ll_stats, hci_cmd_errs);
-    } else {
+    }
+    else {
         STATS_INC(ble_ll_stats, hci_cmds);
     }
 
@@ -1925,16 +1950,16 @@ send_cc_cs:
 }
 
 int
-ble_ll_hci_cmd_rx(uint8_t *cmdbuf)
+ble_ll_hci_cmd_rx(uint8_t* cmdbuf)
 {
-    struct ble_npl_event *ev;
+    struct ble_npl_event* ev;
 #if MYNEWT_VAL(BLE_LL_CFG_FEAT_CTRL_TO_HOST_FLOW_CONTROL)
-    const struct ble_hci_cmd *cmd;
+    const struct ble_hci_cmd* cmd;
     uint16_t opcode;
     uint16_t ocf;
     uint16_t ogf;
 
-    cmd = (const void *)cmdbuf;
+    cmd = (const void*)cmdbuf;
     opcode = le16toh(cmd->opcode);
     ogf = BLE_HCI_OGF(opcode);
     ocf = BLE_HCI_OCF(opcode);
@@ -1967,7 +1992,7 @@ ble_ll_hci_cmd_rx(uint8_t *cmdbuf)
 }
 
 int
-ble_ll_hci_acl_rx(struct os_mbuf *om)
+ble_ll_hci_acl_rx(struct os_mbuf* om)
 {
 #if MYNEWT_VAL(BLE_LL_ROLE_PERIPHERAL) || MYNEWT_VAL(BLE_LL_ROLE_CENTRAL)
     ble_ll_acl_data_in(om);
@@ -1979,7 +2004,7 @@ ble_ll_hci_acl_rx(struct os_mbuf *om)
 }
 
 int
-ble_ll_hci_iso_rx(struct os_mbuf *om)
+ble_ll_hci_iso_rx(struct os_mbuf* om)
 {
 #if MYNEWT_VAL(BLE_LL_ISO)
     ble_ll_isoal_data_in(om);
@@ -2010,7 +2035,6 @@ ble_ll_hci_init(void)
     /* Set defaults for controller/baseband events: Vol 2 Part E 7.3.1 */
     g_ble_ll_hci_event_mask = 0x1fffffffffff;
 
-
     /* Set page 2 to 0 */
     g_ble_ll_hci_event_mask2 = 0;
 
diff --git a/nimble/host/include/host/ble_hs_log.h b/nimble/host/include/host/ble_hs_log.h
index 1514a2ba..560d1332 100644
--- a/nimble/host/include/host/ble_hs_log.h
+++ b/nimble/host/include/host/ble_hs_log.h
@@ -96,6 +96,8 @@ void ble_hs_log_mbuf(const struct os_mbuf *om);
  */
 void ble_hs_log_flat_buf(const void *data, int len);
 
+void ble_hs_log_buf_dflt(const void *data, int len);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/nimble/host/include/host/ble_store.h b/nimble/host/include/host/ble_store.h
index 83b1c4f1..decd91bd 100644
--- a/nimble/host/include/host/ble_store.h
+++ b/nimble/host/include/host/ble_store.h
@@ -40,13 +40,13 @@ extern "C" {
  * @{
  */
 /** Object type: Our security material. */
-#define BLE_STORE_OBJ_TYPE_OUR_SEC      1
+#define BLE_STORE_OBJ_TYPE_OUR_SEC 1
 
 /** Object type: Peer security material. */
-#define BLE_STORE_OBJ_TYPE_PEER_SEC     2
+#define BLE_STORE_OBJ_TYPE_PEER_SEC 2
 
 /** Object type: Client Characteristic Configuration Descriptor. */
-#define BLE_STORE_OBJ_TYPE_CCCD         3
+#define BLE_STORE_OBJ_TYPE_CCCD 3
 
 /** @} */
 
@@ -56,10 +56,10 @@ extern "C" {
  * @{
  */
 /** Failed to persist record; insufficient storage capacity. */
-#define BLE_STORE_EVENT_OVERFLOW        1
+#define BLE_STORE_EVENT_OVERFLOW 1
 
 /** About to execute a procedure that may fail due to overflow. */
-#define BLE_STORE_EVENT_FULL            2
+#define BLE_STORE_EVENT_FULL 2
 
 /** @} */
 
@@ -69,7 +69,8 @@ extern "C" {
  *     o BLE_STORE_OBJ_TYPE_OUR_SEC
  *     o BLE_STORE_OBJ_TYPE_PEER_SEC
  */
-struct ble_store_key_sec {
+struct ble_store_key_sec
+{
     /**
      * Key by peer identity address;
      * peer_addr=BLE_ADDR_NONE means don't key off peer.
@@ -86,7 +87,8 @@ struct ble_store_key_sec {
  *     o BLE_STORE_OBJ_TYPE_OUR_SEC
  *     o BLE_STORE_OBJ_TYPE_PEER_SEC
  */
-struct ble_store_value_sec {
+struct ble_store_value_sec
+{
     /** Peer address for which the security material is stored. */
     ble_addr_t peer_addr;
 
@@ -99,22 +101,29 @@ struct ble_store_value_sec {
     /** Long Term Key. */
     uint8_t ltk[16];
     /** Flag indicating whether Long Term Key is present. */
-    uint8_t ltk_present:1;
+    uint8_t ltk_present : 1;
+
+#if MYNEWT_VAL(ENABLE_SM_25519)
+    uint8_t pubkey[32];
+#else
+    uint8_t pubkey[64];
+#endif
+    uint8_t pubkey_present : 1;
 
     /** Identity Resolving Key. */
     uint8_t irk[16];
     /** Flag indicating whether Identity Resolving Key is present. */
-    uint8_t irk_present:1;
+    uint8_t irk_present : 1;
 
     /** Connection Signature Resolving Key. */
     uint8_t csrk[16];
     /** Flag indicating if Connection Signature Resolving Key is present. */
-    uint8_t csrk_present:1;
+    uint8_t csrk_present : 1;
 
     /** Flag indicating whether the connection is authenticated. */
-    unsigned authenticated:1;
+    unsigned authenticated : 1;
     /** Flag indicating Secure Connections support. */
-    uint8_t sc:1;
+    uint8_t sc : 1;
 };
 
 /**
@@ -122,7 +131,8 @@ struct ble_store_value_sec {
  * descriptors (CCCDs).  This struct corresponds to the BLE_STORE_OBJ_TYPE_CCCD
  * store object type.
  */
-struct ble_store_key_cccd {
+struct ble_store_key_cccd
+{
     /**
      * Key by peer identity address;
      * peer_addr=BLE_ADDR_NONE means don't key off peer.
@@ -143,7 +153,8 @@ struct ble_store_key_cccd {
  * Represents a stored client characteristic configuration descriptor (CCCD).
  * This struct corresponds to the BLE_STORE_OBJ_TYPE_CCCD store object type.
  */
-struct ble_store_value_cccd {
+struct ble_store_value_cccd
+{
     /** The peer address associated with the stored CCCD. */
     ble_addr_t peer_addr;
     /** The handle of the characteristic value. */
@@ -151,7 +162,7 @@ struct ble_store_value_cccd {
     /** Flags associated with the CCCD. */
     uint16_t flags;
     /** Flag indicating whether the value has changed. */
-    unsigned value_changed:1;
+    unsigned value_changed : 1;
 };
 
 /**
@@ -177,7 +188,8 @@ union ble_store_value {
 };
 
 /** Represents an event associated with the BLE Store. */
-struct ble_store_status_event {
+struct ble_store_status_event
+{
     /**
      * The type of event being reported; one of the BLE_STORE_EVENT_TYPE_[...]
      * codes.
@@ -194,12 +206,13 @@ struct ble_store_status_event {
          * the following event types:
          *     o BLE_STORE_EVENT_OVERFLOW
          */
-        struct {
+        struct
+        {
             /** The type of object that failed to be written. */
             int obj_type;
 
             /** The object that failed to be written. */
-            const union ble_store_value *value;
+            const union ble_store_value* value;
         } overflow;
 
         /**
@@ -207,7 +220,8 @@ struct ble_store_status_event {
          * storage exhaustion.  Valid for the following event types:
          *     o BLE_STORE_EVENT_FULL
          */
-        struct {
+        struct
+        {
             /** The type of object that may fail to be written. */
             int obj_type;
 
@@ -218,14 +232,15 @@ struct ble_store_status_event {
 };
 
 /** Generate LTK, EDIT and Rand. */
-#define BLE_STORE_GEN_KEY_LTK       0x01
+#define BLE_STORE_GEN_KEY_LTK 0x01
 /** Generate IRK. */
-#define BLE_STORE_GEN_KEY_IRK       0x02
+#define BLE_STORE_GEN_KEY_IRK 0x02
 /** Generate CSRK. */
-#define BLE_STORE_GEN_KEY_CSRK      0x03
+#define BLE_STORE_GEN_KEY_CSRK 0x03
 
 /** Represents a storage for generated key. */
-struct ble_store_gen_key {
+struct ble_store_gen_key
+{
     union {
         /** Long Term Key (LTK) for peripheral role. */
         uint8_t ltk_periph[16];
@@ -255,9 +270,9 @@ struct ble_store_gen_key {
  * @return                      0 if keys were generated successfully
  *                              Other nonzero on error.
  */
-typedef int ble_store_gen_key_fn(uint8_t key,
-                                 struct ble_store_gen_key *gen_key,
-                                 uint16_t conn_handle);
+typedef int
+ble_store_gen_key_fn(uint8_t key, struct ble_store_gen_key* gen_key,
+                     uint16_t conn_handle);
 
 /**
  * Searches the store for an object matching the specified criteria.  If a
@@ -276,8 +291,9 @@ typedef int ble_store_gen_key_fn(uint8_t key,
  *                              BLE_HS_ENOENT if no matching object was found;
  *                              Other nonzero on error.
  */
-typedef int ble_store_read_fn(int obj_type, const union ble_store_key *key,
-                              union ble_store_value *dst);
+typedef int
+ble_store_read_fn(int obj_type, const union ble_store_key* key,
+                  union ble_store_value* dst);
 
 /**
  * Writes the specified object to the store.  If an object with the same
@@ -292,7 +308,8 @@ typedef int ble_store_read_fn(int obj_type, const union ble_store_key *key,
  * @return                      0 if the object was successfully written;
  *                              Other nonzero on error.
  */
-typedef int ble_store_write_fn(int obj_type, const union ble_store_value *val);
+typedef int
+ble_store_write_fn(int obj_type, const union ble_store_value* val);
 
 /**
  * Searches the store for the first object matching the specified criteria.  If
@@ -307,7 +324,8 @@ typedef int ble_store_write_fn(int obj_type, const union ble_store_value *val);
  *                              BLE_HS_ENOENT if no matching object was found;
  *                              Other nonzero on error.
  */
-typedef int ble_store_delete_fn(int obj_type, const union ble_store_key *key);
+typedef int
+ble_store_delete_fn(int obj_type, const union ble_store_key* key);
 
 /**
  * Indicates an inability to perform a store operation.  This callback should
@@ -323,8 +341,8 @@ typedef int ble_store_delete_fn(int obj_type, const union ble_store_key *key);
  *                              nonzero if the store operation should be
  *                                  aborted.
  */
-typedef int ble_store_status_fn(struct ble_store_status_event *event,
-                                void *arg);
+typedef int
+ble_store_status_fn(struct ble_store_status_event* event, void* arg);
 
 /**
  * Reads data from a storage.
@@ -336,8 +354,9 @@ typedef int ble_store_status_fn(struct ble_store_status_event *event,
  * @return                      0 if the read operation is successful;
  *                              Non-zero on error.
  */
-int ble_store_read(int obj_type, const union ble_store_key *key,
-                   union ble_store_value *val);
+int
+ble_store_read(int obj_type, const union ble_store_key* key,
+               union ble_store_value* val);
 
 /**
  * Writes data to a storage.
@@ -348,7 +367,8 @@ int ble_store_read(int obj_type, const union ble_store_key *key,
  * @return                      0 if the write operation is successful;
  *                              Non-zero on error.
  */
-int ble_store_write(int obj_type, const union ble_store_value *val);
+int
+ble_store_write(int obj_type, const union ble_store_value* val);
 
 /**
  * Deletes data from a storage.
@@ -359,7 +379,8 @@ int ble_store_write(int obj_type, const union ble_store_value *val);
  * @return                      0 if the deletion operation is successful;
  *                              Non-zero on error.
  */
-int ble_store_delete(int obj_type, const union ble_store_key *key);
+int
+ble_store_delete(int obj_type, const union ble_store_key* key);
 
 /**
  * @brief Handles a storage overflow event.
@@ -376,7 +397,8 @@ int ble_store_delete(int obj_type, const union ble_store_key *key);
  * @return                      0 if the event is successfully handled;
  *                              Non-zero on error.
  */
-int ble_store_overflow_event(int obj_type, const union ble_store_value *value);
+int
+ble_store_overflow_event(int obj_type, const union ble_store_value* value);
 
 /**
  * @brief Handles a storage full event.
@@ -393,7 +415,8 @@ int ble_store_overflow_event(int obj_type, const union ble_store_value *value);
  * @return                      0 if the event is successfully handled;
  *                              Non-zero on error.
  */
-int ble_store_full_event(int obj_type, uint16_t conn_handle);
+int
+ble_store_full_event(int obj_type, uint16_t conn_handle);
 
 /**
  * @brief Reads our security material from a storage.
@@ -411,8 +434,9 @@ int ble_store_full_event(int obj_type, uint16_t conn_handle);
  *                                  from a storage;
  *                              Non-zero on error.
  */
-int ble_store_read_our_sec(const struct ble_store_key_sec *key_sec,
-                           struct ble_store_value_sec *value_sec);
+int
+ble_store_read_our_sec(const struct ble_store_key_sec* key_sec,
+                       struct ble_store_value_sec* value_sec);
 
 /**
  * @brief Writes our security material to a storage.
@@ -428,7 +452,8 @@ int ble_store_read_our_sec(const struct ble_store_key_sec *key_sec,
  *                                  written to a storage;
  *                              Non-zero on error.
  */
-int ble_store_write_our_sec(const struct ble_store_value_sec *value_sec);
+int
+ble_store_write_our_sec(const struct ble_store_value_sec* value_sec);
 
 /**
  * @brief Deletes our security material from a storage.
@@ -444,7 +469,8 @@ int ble_store_write_our_sec(const struct ble_store_value_sec *value_sec);
  *                                  deleted from a storage;
  *                              Non-zero on error.
  */
-int ble_store_delete_our_sec(const struct ble_store_key_sec *key_sec);
+int
+ble_store_delete_our_sec(const struct ble_store_key_sec* key_sec);
 
 /**
  * @brief Reads peer security material from a storage.
@@ -464,8 +490,9 @@ int ble_store_delete_our_sec(const struct ble_store_key_sec *key_sec);
  *                                  retrieved;
  *                              Non-zero on error.
  */
-int ble_store_read_peer_sec(const struct ble_store_key_sec *key_sec,
-                            struct ble_store_value_sec *value_sec);
+int
+ble_store_read_peer_sec(const struct ble_store_key_sec* key_sec,
+                        struct ble_store_value_sec* value_sec);
 
 /**
  * @brief Writes peer security material to a storage.
@@ -485,7 +512,8 @@ int ble_store_read_peer_sec(const struct ble_store_key_sec *key_sec,
  *                                  cache if present;
  *                              Non-zero on error.
  */
-int ble_store_write_peer_sec(const struct ble_store_value_sec *value_sec);
+int
+ble_store_write_peer_sec(const struct ble_store_value_sec* value_sec);
 
 /**
  * @brief Deletes peer security material from a storage.
@@ -501,8 +529,8 @@ int ble_store_write_peer_sec(const struct ble_store_value_sec *value_sec);
  *                                  successfully deleted from a storage;
  *                              Non-zero on error.
  */
-int ble_store_delete_peer_sec(const struct ble_store_key_sec *key_sec);
-
+int
+ble_store_delete_peer_sec(const struct ble_store_key_sec* key_sec);
 
 /**
  * @brief Reads a Client Characteristic Configuration Descriptor (CCCD) from
@@ -521,8 +549,9 @@ int ble_store_delete_peer_sec(const struct ble_store_key_sec *key_sec);
  *                                  in the `out_value` structure;
  *                              Non-zero on error.
  */
-int ble_store_read_cccd(const struct ble_store_key_cccd *key,
-                        struct ble_store_value_cccd *out_value);
+int
+ble_store_read_cccd(const struct ble_store_key_cccd* key,
+                    struct ble_store_value_cccd* out_value);
 
 /**
  * @brief Writes a Client Characteristic Configuration Descriptor (CCCD) to
@@ -538,7 +567,8 @@ int ble_store_read_cccd(const struct ble_store_key_cccd *key,
  *                                  a storage;
  *                              Non-zero on error.
  */
-int ble_store_write_cccd(const struct ble_store_value_cccd *value);
+int
+ble_store_write_cccd(const struct ble_store_value_cccd* value);
 
 /**
  * @brief Deletes a Client Characteristic Configuration Descriptor (CCCD) from
@@ -554,8 +584,8 @@ int ble_store_write_cccd(const struct ble_store_value_cccd *value);
  *                                  a storage;
  *                              Non-zero on error.
  */
-int ble_store_delete_cccd(const struct ble_store_key_cccd *key);
-
+int
+ble_store_delete_cccd(const struct ble_store_key_cccd* key);
 
 /**
  * @brief Generates a storage key for a security material entry from its value.
@@ -569,8 +599,9 @@ int ble_store_delete_cccd(const struct ble_store_key_cccd *key);
  *                                  containing the security material value from
  *                                  which the key will be generated.
  */
-void ble_store_key_from_value_sec(struct ble_store_key_sec *out_key,
-                                  const struct ble_store_value_sec *value);
+void
+ble_store_key_from_value_sec(struct ble_store_key_sec* out_key,
+                             const struct ble_store_value_sec* value);
 
 /**
  * @brief Generates a storage key for a CCCD entry from its value.
@@ -584,9 +615,9 @@ void ble_store_key_from_value_sec(struct ble_store_key_sec *out_key,
  *                                  containing the CCCD value from which the key
  *                                  will be generated.
  */
-void ble_store_key_from_value_cccd(struct ble_store_key_cccd *out_key,
-                                   const struct ble_store_value_cccd *value);
-
+void
+ble_store_key_from_value_cccd(struct ble_store_key_cccd* out_key,
+                              const struct ble_store_value_cccd* value);
 
 /**
  * @brief Generates a storage key from a value based on the object type.
@@ -602,10 +633,9 @@ void ble_store_key_from_value_cccd(struct ble_store_key_cccd *out_key,
  *                                  containing the value from which the key will
  *                                  be generated.
  */
-void ble_store_key_from_value(int obj_type,
-                              union ble_store_key *out_key,
-                              const union ble_store_value *value);
-
+void
+ble_store_key_from_value(int obj_type, union ble_store_key* out_key,
+                         const union ble_store_value* value);
 
 /**
  * @brief Function signature for the storage iterator callback.
@@ -620,10 +650,8 @@ void ble_store_key_from_value(int obj_type,
  * @return                      0 to continue iterating;
  *                              Non-zero value to stop the iteration.
  */
-typedef int ble_store_iterator_fn(int obj_type,
-                                  union ble_store_value *val,
-                                  void *cookie);
-
+typedef int
+ble_store_iterator_fn(int obj_type, union ble_store_value* val, void* cookie);
 
 /**
  * @brief Iterates over stored objects of a specific type in a store.
@@ -640,10 +668,8 @@ typedef int ble_store_iterator_fn(int obj_type,
  * @return                      0 on success;
  *                              Non-zero on error.
  */
-int ble_store_iterate(int obj_type,
-                      ble_store_iterator_fn *callback,
-                      void *cookie);
-
+int
+ble_store_iterate(int obj_type, ble_store_iterator_fn* callback, void* cookie);
 
 /**
  * @brief Clears all stored objects from a store.
@@ -654,7 +680,8 @@ int ble_store_iterate(int obj_type,
  * @return                      0 on success;
  *                              Non-zero on error.
  */
-int ble_store_clear(void);
+int
+ble_store_clear(void);
 
 /**
  * @defgroup ble_store_util Bluetooth Store Utility Functions
@@ -673,9 +700,9 @@ int ble_store_clear(void);
  *                                  small;
  *                              Other non-zero on error.
  */
-int ble_store_util_bonded_peers(ble_addr_t *out_peer_id_addrs,
-                                int *out_num_peers,
-                                int max_peers);
+int
+ble_store_util_bonded_peers(ble_addr_t* out_peer_id_addrs, int* out_num_peers,
+                            int max_peers);
 
 /**
  * Deletes all entries from a store that match the specified key.
@@ -686,7 +713,8 @@ int ble_store_util_bonded_peers(ble_addr_t *out_peer_id_addrs,
  * @return                      0 on success;
  *                              Non-zero on error.
  */
-int ble_store_util_delete_all(int type, const union ble_store_key *key);
+int
+ble_store_util_delete_all(int type, const union ble_store_key* key);
 
 /**
  * Deletes all entries from a store that are attached to the specified peer
@@ -697,7 +725,8 @@ int ble_store_util_delete_all(int type, const union ble_store_key *key);
  * @return                      0 on success;
  *                              Non-zero on error.
  */
-int ble_store_util_delete_peer(const ble_addr_t *peer_id_addr);
+int
+ble_store_util_delete_peer(const ble_addr_t* peer_id_addr);
 
 /**
  * @brief Deletes the oldest peer from a store.
@@ -708,7 +737,8 @@ int ble_store_util_delete_peer(const ble_addr_t *peer_id_addr);
  * @return                      0 on success;
  *                              Non-zero on error.
  */
-int ble_store_util_delete_oldest_peer(void);
+int
+ble_store_util_delete_oldest_peer(void);
 
 /**
  * @brief Counts the number of stored objects of a given type.
@@ -722,7 +752,8 @@ int ble_store_util_delete_oldest_peer(void);
  * @return                      0 on success;
  *                              Non-zero on error.
  */
-int ble_store_util_count(int type, int *out_count);
+int
+ble_store_util_count(int type, int* out_count);
 
 /**
  * @brief Round-robin status callback for handling store status events.
@@ -742,7 +773,8 @@ int ble_store_util_count(int type, int *out_count);
  * @return                      0 on success;
  *                              Non-zero on error.
  */
-int ble_store_util_status_rr(struct ble_store_status_event *event, void *arg);
+int
+ble_store_util_status_rr(struct ble_store_status_event* event, void* arg);
 
 /** @} */
 
diff --git a/nimble/host/src/ascon/aead.c b/nimble/host/src/ascon/aead.c
new file mode 100644
index 00000000..e818ecca
--- /dev/null
+++ b/nimble/host/src/ascon/aead.c
@@ -0,0 +1,245 @@
+#include "api.h"
+#include "ascon.h"
+#include "crypto_aead.h"
+#include "permutations.h"
+#include "printstate.h"
+#include "word.h"
+
+int crypto_aead_encrypt(unsigned char* c, unsigned long long* clen,
+                        const unsigned char* m, unsigned long long mlen,
+                        const unsigned char* ad, unsigned long long adlen,
+                        const unsigned char* nsec, const unsigned char* npub,
+                        const unsigned char* k) {
+  (void)nsec;
+
+  /* set ciphertext size */
+  *clen = mlen + CRYPTO_ABYTES;
+
+  /* print input bytes */
+  print("encrypt\n");
+  printbytes("k", k, CRYPTO_KEYBYTES);
+  printbytes("n", npub, CRYPTO_NPUBBYTES);
+  printbytes("a", ad, adlen);
+  printbytes("m", m, mlen);
+
+  /* load key and nonce */
+  const uint64_t K0 = LOADBYTES(k, 8);
+  const uint64_t K1 = LOADBYTES(k + 8, 8);
+  const uint64_t N0 = LOADBYTES(npub, 8);
+  const uint64_t N1 = LOADBYTES(npub + 8, 8);
+
+  /* initialize */
+  ascon_state_t s;
+  s.x[0] = ASCON_128A_IV;
+  s.x[1] = K0;
+  s.x[2] = K1;
+  s.x[3] = N0;
+  s.x[4] = N1;
+  printstate("init 1st key xor", &s);
+  P12(&s);
+  s.x[3] ^= K0;
+  s.x[4] ^= K1;
+  printstate("init 2nd key xor", &s);
+
+  if (adlen) {
+    /* full associated data blocks */
+    while (adlen >= ASCON_128A_RATE) {
+      s.x[0] ^= LOADBYTES(ad, 8);
+      s.x[1] ^= LOADBYTES(ad + 8, 8);
+      printstate("absorb adata", &s);
+      P8(&s);
+      ad += ASCON_128A_RATE;
+      adlen -= ASCON_128A_RATE;
+    }
+    /* final associated data block */
+    if (adlen >= 8) {
+      s.x[0] ^= LOADBYTES(ad, 8);
+      s.x[1] ^= LOADBYTES(ad + 8, adlen - 8);
+      s.x[1] ^= PAD(adlen - 8);
+    } else {
+      s.x[0] ^= LOADBYTES(ad, adlen);
+      s.x[0] ^= PAD(adlen);
+    }
+    printstate("pad adata", &s);
+    P8(&s);
+  }
+  /* domain separation */
+  s.x[4] ^= DSEP();
+  printstate("domain separation", &s);
+
+  /* full plaintext blocks */
+  while (mlen >= ASCON_128A_RATE) {
+    s.x[0] ^= LOADBYTES(m, 8);
+    s.x[1] ^= LOADBYTES(m + 8, 8);
+    STOREBYTES(c, s.x[0], 8);
+    STOREBYTES(c + 8, s.x[1], 8);
+    printstate("absorb plaintext", &s);
+    P8(&s);
+    m += ASCON_128A_RATE;
+    c += ASCON_128A_RATE;
+    mlen -= ASCON_128A_RATE;
+  }
+  /* final plaintext block */
+  if (mlen >= 8) {
+    s.x[0] ^= LOADBYTES(m, 8);
+    s.x[1] ^= LOADBYTES(m + 8, mlen - 8);
+    STOREBYTES(c, s.x[0], 8);
+    STOREBYTES(c + 8, s.x[1], mlen - 8);
+    s.x[1] ^= PAD(mlen - 8);
+  } else {
+    s.x[0] ^= LOADBYTES(m, mlen);
+    STOREBYTES(c, s.x[0], mlen);
+    s.x[0] ^= PAD(mlen);
+  }
+  m += mlen;
+  c += mlen;
+  printstate("pad plaintext", &s);
+
+  /* finalize */
+  s.x[2] ^= K0;
+  s.x[3] ^= K1;
+  printstate("final 1st key xor", &s);
+  P12(&s);
+  s.x[3] ^= K0;
+  s.x[4] ^= K1;
+  printstate("final 2nd key xor", &s);
+
+  /* get tag */
+  STOREBYTES(c, s.x[3], 8);
+  STOREBYTES(c + 8, s.x[4], 8);
+
+  /* print output bytes */
+  printbytes("c", c - *clen + CRYPTO_ABYTES, *clen - CRYPTO_ABYTES);
+  printbytes("t", c, CRYPTO_ABYTES);
+  print("\n");
+
+  return 0;
+}
+
+int crypto_aead_decrypt(unsigned char* m, unsigned long long* mlen,
+                        unsigned char* nsec, const unsigned char* c,
+                        unsigned long long clen, const unsigned char* ad,
+                        unsigned long long adlen, const unsigned char* npub,
+                        const unsigned char* k) {
+  (void)nsec;
+
+  if (clen < CRYPTO_ABYTES) return -1;
+
+  /* set plaintext size */
+  *mlen = clen - CRYPTO_ABYTES;
+
+  /* print input bytes */
+  print("decrypt\n");
+  printbytes("k", k, CRYPTO_KEYBYTES);
+  printbytes("n", npub, CRYPTO_NPUBBYTES);
+  printbytes("a", ad, adlen);
+  printbytes("c", c, *mlen);
+  printbytes("t", c + *mlen, CRYPTO_ABYTES);
+
+  /* load key and nonce */
+  const uint64_t K0 = LOADBYTES(k, 8);
+  const uint64_t K1 = LOADBYTES(k + 8, 8);
+  const uint64_t N0 = LOADBYTES(npub, 8);
+  const uint64_t N1 = LOADBYTES(npub + 8, 8);
+
+  /* initialize */
+  ascon_state_t s;
+  s.x[0] = ASCON_128A_IV;
+  s.x[1] = K0;
+  s.x[2] = K1;
+  s.x[3] = N0;
+  s.x[4] = N1;
+  printstate("init 1st key xor", &s);
+  P12(&s);
+  s.x[3] ^= K0;
+  s.x[4] ^= K1;
+  printstate("init 2nd key xor", &s);
+
+  if (adlen) {
+    /* full associated data blocks */
+    while (adlen >= ASCON_128A_RATE) {
+      s.x[0] ^= LOADBYTES(ad, 8);
+      s.x[1] ^= LOADBYTES(ad + 8, 8);
+      printstate("absorb adata", &s);
+      P8(&s);
+      ad += ASCON_128A_RATE;
+      adlen -= ASCON_128A_RATE;
+    }
+    /* final associated data block */
+    if (adlen >= 8) {
+      s.x[0] ^= LOADBYTES(ad, 8);
+      s.x[1] ^= LOADBYTES(ad + 8, adlen - 8);
+      s.x[1] ^= PAD(adlen - 8);
+    } else {
+      s.x[0] ^= LOADBYTES(ad, adlen);
+      s.x[0] ^= PAD(adlen);
+    }
+    printstate("pad adata", &s);
+    P8(&s);
+  }
+  /* domain separation */
+  s.x[4] ^= DSEP();
+  printstate("domain separation", &s);
+
+  /* full ciphertext blocks */
+  clen -= CRYPTO_ABYTES;
+  while (clen >= ASCON_128A_RATE) {
+    uint64_t c0 = LOADBYTES(c, 8);
+    uint64_t c1 = LOADBYTES(c + 8, 8);
+    STOREBYTES(m, s.x[0] ^ c0, 8);
+    STOREBYTES(m + 8, s.x[1] ^ c1, 8);
+    s.x[0] = c0;
+    s.x[1] = c1;
+    printstate("insert ciphertext", &s);
+    P8(&s);
+    m += ASCON_128A_RATE;
+    c += ASCON_128A_RATE;
+    clen -= ASCON_128A_RATE;
+  }
+  /* final ciphertext block */
+  if (clen >= 8) {
+    uint64_t c0 = LOADBYTES(c, 8);
+    uint64_t c1 = LOADBYTES(c + 8, clen - 8);
+    STOREBYTES(m, s.x[0] ^ c0, 8);
+    STOREBYTES(m + 8, s.x[1] ^ c1, clen - 8);
+    s.x[0] = c0;
+    s.x[1] = CLEARBYTES(s.x[1], clen - 8);
+    s.x[1] |= c1;
+    s.x[1] ^= PAD(clen - 8);
+  } else {
+    uint64_t c0 = LOADBYTES(c, clen);
+    STOREBYTES(m, s.x[0] ^ c0, clen);
+    s.x[0] = CLEARBYTES(s.x[0], clen);
+    s.x[0] |= c0;
+    s.x[0] ^= PAD(clen);
+  }
+  m += clen;
+  c += clen;
+  printstate("pad ciphertext", &s);
+
+  /* finalize */
+  s.x[2] ^= K0;
+  s.x[3] ^= K1;
+  printstate("final 1st key xor", &s);
+  P12(&s);
+  s.x[3] ^= K0;
+  s.x[4] ^= K1;
+  printstate("final 2nd key xor", &s);
+
+  /* get tag */
+  uint8_t t[16];
+  STOREBYTES(t, s.x[3], 8);
+  STOREBYTES(t + 8, s.x[4], 8);
+
+  /* verify should be constant time, check compiler output */
+  int i;
+  int result = 0;
+  for (i = 0; i < CRYPTO_ABYTES; ++i) result |= c[i] ^ t[i];
+  result = (((result - 1) >> 8) & 1) - 1;
+
+  /* print output bytes */
+  printbytes("m", m - *mlen, *mlen);
+  print("\n");
+
+  return result;
+}
diff --git a/nimble/host/src/ascon/api.h b/nimble/host/src/ascon/api.h
new file mode 100644
index 00000000..0f8c8c14
--- /dev/null
+++ b/nimble/host/src/ascon/api.h
@@ -0,0 +1,17 @@
+#define CRYPTO_VERSION "1.3.0"
+
+// AEAD defines
+#define CRYPTO_KEYBYTES 16
+#define CRYPTO_NSECBYTES 0
+#define CRYPTO_NPUBBYTES 16
+#define CRYPTO_ABYTES 16
+#define CRYPTO_NOOVERLAP 1
+#define ASCON_AEAD_RATE 16
+
+// Hash defines
+#define ASCON_HASH_BYTES 0 /* XOF */
+#define ASCON_HASH_ROUNDS 12
+#define ASCON_VARIANT 3
+
+#define ASCON_PRF_BYTES 16
+#define ASCON_PRF_ROUNDS 12
\ No newline at end of file
diff --git a/nimble/host/src/ascon/ascon.h b/nimble/host/src/ascon/ascon.h
new file mode 100644
index 00000000..23500040
--- /dev/null
+++ b/nimble/host/src/ascon/ascon.h
@@ -0,0 +1,10 @@
+#ifndef ASCON_H_
+#define ASCON_H_
+
+#include <stdint.h>
+
+typedef struct {
+  uint64_t x[5];
+} ascon_state_t;
+
+#endif /* ASCON_H_ */
diff --git a/nimble/host/src/ascon/constants.h b/nimble/host/src/ascon/constants.h
new file mode 100644
index 00000000..5ca9eb17
--- /dev/null
+++ b/nimble/host/src/ascon/constants.h
@@ -0,0 +1,126 @@
+#ifndef CONSTANTS_H_
+#define CONSTANTS_H_
+
+#include <stdint.h>
+
+#define ASCON_80PQ_VARIANT 0
+#define ASCON_AEAD_VARIANT 1
+#define ASCON_HASH_VARIANT 2
+#define ASCON_XOF_VARIANT 3
+#define ASCON_CXOF_VARIANT 4
+#define ASCON_MAC_VARIANT 5
+#define ASCON_PRF_VARIANT 6
+#define ASCON_PRFS_VARIANT 7
+
+#define ASCON_TAG_SIZE 16
+#define ASCON_HASH_SIZE 32
+
+#define ASCON_128_RATE 8
+#define ASCON_128A_RATE 16
+#define ASCON_HASH_RATE 8
+#define ASCON_PRF_IN_RATE 32
+#define ASCON_PRFA_IN_RATE 40
+#define ASCON_PRF_OUT_RATE 16
+
+#define ASCON_PA_ROUNDS 12
+#define ASCON_128_PB_ROUNDS 6
+#define ASCON_128A_PB_ROUNDS 8
+#define ASCON_HASH_PB_ROUNDS 12
+#define ASCON_HASHA_PB_ROUNDS 8
+#define ASCON_PRF_PB_ROUNDS 12
+#define ASCON_PRFA_PB_ROUNDS 8
+
+#define ASCON_128_IV                         \
+  (((uint64_t)(ASCON_AEAD_VARIANT) << 0) |   \
+   ((uint64_t)(ASCON_PA_ROUNDS) << 16) |     \
+   ((uint64_t)(ASCON_128_PB_ROUNDS) << 20) | \
+   ((uint64_t)(ASCON_TAG_SIZE * 8) << 24) |  \
+   ((uint64_t)(ASCON_128_RATE) << 40))
+
+#define ASCON_128A_IV                         \
+  (((uint64_t)(ASCON_AEAD_VARIANT) << 0) |    \
+   ((uint64_t)(ASCON_PA_ROUNDS) << 16) |      \
+   ((uint64_t)(ASCON_128A_PB_ROUNDS) << 20) | \
+   ((uint64_t)(ASCON_TAG_SIZE * 8) << 24) |   \
+   ((uint64_t)(ASCON_128A_RATE) << 40))
+
+#define ASCON_80PQ_IV                                                          \
+  (((uint64_t)(ASCON_80PQ_VARIANT) << 0) | ((uint64_t)(ASCON_128_RATE) << 8) | \
+   ((uint64_t)(ASCON_PA_ROUNDS) << 16) |                                       \
+   ((uint64_t)(ASCON_128_PB_ROUNDS) << 20) |                                   \
+   ((uint64_t)(ASCON_TAG_SIZE * 8) << 24))
+
+#define ASCON_HASH_IV                         \
+  (((uint64_t)(ASCON_HASH_VARIANT) << 0) |    \
+   ((uint64_t)(ASCON_PA_ROUNDS) << 16) |      \
+   ((uint64_t)(ASCON_HASH_PB_ROUNDS) << 20) | \
+   ((uint64_t)(ASCON_HASH_SIZE * 8) << 24) |  \
+   ((uint64_t)(ASCON_HASH_RATE) << 40))
+
+#define ASCON_HASHA_IV                         \
+  (((uint64_t)(ASCON_HASH_VARIANT) << 0) |     \
+   ((uint64_t)(ASCON_PA_ROUNDS) << 16) |       \
+   ((uint64_t)(ASCON_HASHA_PB_ROUNDS) << 20) | \
+   ((uint64_t)(ASCON_HASH_SIZE * 8) << 24) |   \
+   ((uint64_t)(ASCON_HASH_RATE) << 40))
+
+#define ASCON_XOF_IV                          \
+  (((uint64_t)(ASCON_XOF_VARIANT) << 0) |     \
+   ((uint64_t)(ASCON_PA_ROUNDS) << 16) |      \
+   ((uint64_t)(ASCON_HASH_PB_ROUNDS) << 20) | \
+   ((uint64_t)(ASCON_HASH_RATE) << 40))
+
+#define ASCON_XOFA_IV                          \
+  (((uint64_t)(ASCON_XOF_VARIANT) << 0) |      \
+   ((uint64_t)(ASCON_PA_ROUNDS) << 16) |       \
+   ((uint64_t)(ASCON_HASHA_PB_ROUNDS) << 20) | \
+   ((uint64_t)(ASCON_HASH_RATE) << 40))
+
+#define ASCON_CXOF_IV                         \
+  (((uint64_t)(ASCON_CXOF_VARIANT) << 0) |    \
+   ((uint64_t)(ASCON_PA_ROUNDS) << 16) |      \
+   ((uint64_t)(ASCON_HASH_PB_ROUNDS) << 20) | \
+   ((uint64_t)(ASCON_HASH_RATE) << 40))
+
+#define ASCON_CXOFA_IV                         \
+  (((uint64_t)(ASCON_CXOF_VARIANT) << 0) |     \
+   ((uint64_t)(ASCON_PA_ROUNDS) << 16) |       \
+   ((uint64_t)(ASCON_HASHA_PB_ROUNDS) << 20) | \
+   ((uint64_t)(ASCON_HASH_RATE) << 40))
+
+#define ASCON_MAC_IV                         \
+  (((uint64_t)(ASCON_MAC_VARIANT) << 0) |    \
+   ((uint64_t)(ASCON_PA_ROUNDS) << 16) |     \
+   ((uint64_t)(ASCON_PRF_PB_ROUNDS) << 20) | \
+   ((uint64_t)(ASCON_TAG_SIZE * 8) << 24) |  \
+   ((uint64_t)(ASCON_PRF_IN_RATE) << 40) |   \
+   ((uint64_t)(ASCON_PRF_OUT_RATE) << 48))
+
+#define ASCON_MACA_IV                         \
+  (((uint64_t)(ASCON_MAC_VARIANT) << 0) |     \
+   ((uint64_t)(ASCON_PA_ROUNDS) << 16) |      \
+   ((uint64_t)(ASCON_PRFA_PB_ROUNDS) << 20) | \
+   ((uint64_t)(ASCON_TAG_SIZE * 8) << 24) |   \
+   ((uint64_t)(ASCON_PRFA_IN_RATE) << 40) |   \
+   ((uint64_t)(ASCON_PRF_OUT_RATE) << 48))
+
+#define ASCON_PRF_IV                         \
+  (((uint64_t)(ASCON_PRF_VARIANT) << 0) |    \
+   ((uint64_t)(ASCON_PA_ROUNDS) << 16) |     \
+   ((uint64_t)(ASCON_PRF_PB_ROUNDS) << 20) | \
+   ((uint64_t)(ASCON_PRF_IN_RATE) << 40) |   \
+   ((uint64_t)(ASCON_PRF_OUT_RATE) << 48))
+
+#define ASCON_PRFA_IV                         \
+  (((uint64_t)(ASCON_PRF_VARIANT) << 0) |     \
+   ((uint64_t)(ASCON_PA_ROUNDS) << 16) |      \
+   ((uint64_t)(ASCON_PRFA_PB_ROUNDS) << 20) | \
+   ((uint64_t)(ASCON_PRFA_IN_RATE) << 40) |   \
+   ((uint64_t)(ASCON_PRF_OUT_RATE) << 48))
+
+#define ASCON_PRFS_IV                      \
+  (((uint64_t)(ASCON_PRFS_VARIANT) << 0) | \
+   ((uint64_t)(ASCON_PA_ROUNDS) << 16) |   \
+   ((uint64_t)(ASCON_TAG_SIZE * 8) << 24))
+
+#endif /* CONSTANTS_H_ */
diff --git a/nimble/host/src/ascon/crypto_aead.h b/nimble/host/src/ascon/crypto_aead.h
new file mode 100644
index 00000000..d9396b8c
--- /dev/null
+++ b/nimble/host/src/ascon/crypto_aead.h
@@ -0,0 +1,11 @@
+int crypto_aead_encrypt(unsigned char *c, unsigned long long *clen,
+                        const unsigned char *m, unsigned long long mlen,
+                        const unsigned char *ad, unsigned long long adlen,
+                        const unsigned char *nsec, const unsigned char *npub,
+                        const unsigned char *k);
+
+int crypto_aead_decrypt(unsigned char *m, unsigned long long *mlen,
+                        unsigned char *nsec, const unsigned char *c,
+                        unsigned long long clen, const unsigned char *ad,
+                        unsigned long long adlen, const unsigned char *npub,
+                        const unsigned char *k);
\ No newline at end of file
diff --git a/nimble/host/src/ascon/crypto_auth.h b/nimble/host/src/ascon/crypto_auth.h
new file mode 100644
index 00000000..4fede647
--- /dev/null
+++ b/nimble/host/src/ascon/crypto_auth.h
@@ -0,0 +1,12 @@
+int
+crypto_prf(unsigned char* out, unsigned long long outlen,
+           const unsigned char* in, unsigned long long inlen,
+           const unsigned char* k);
+
+int
+crypto_auth(unsigned char* out, const unsigned char* in, unsigned long long len,
+            const unsigned char* k);
+
+int
+crypto_auth_verify(const unsigned char* h, const unsigned char* in,
+                   unsigned long long len, const unsigned char* k);
\ No newline at end of file
diff --git a/nimble/host/src/ascon/crypto_hash.h b/nimble/host/src/ascon/crypto_hash.h
new file mode 100644
index 00000000..278cb12e
--- /dev/null
+++ b/nimble/host/src/ascon/crypto_hash.h
@@ -0,0 +1,2 @@
+int crypto_hash(unsigned char *out, const unsigned char *in,
+                unsigned long long len);
\ No newline at end of file
diff --git a/nimble/host/src/ascon/hash.c b/nimble/host/src/ascon/hash.c
new file mode 100644
index 00000000..f56f1796
--- /dev/null
+++ b/nimble/host/src/ascon/hash.c
@@ -0,0 +1,54 @@
+#include "api.h"
+#include "ascon.h"
+#include "crypto_hash.h"
+#include "permutations.h"
+#include "printstate.h"
+#include "word.h"
+
+#define CRYPTO_BYTES 32
+
+int
+crypto_hash(unsigned char* out, const unsigned char* in, unsigned long long len)
+{
+    printbytes("m", in, len);
+    /* initialize */
+    ascon_state_t s;
+    s.x[0] = ASCON_XOF_IV;
+    s.x[1] = 0;
+    s.x[2] = 0;
+    s.x[3] = 0;
+    s.x[4] = 0;
+    printstate("initial value", &s);
+    P12(&s);
+    printstate("initialization", &s);
+
+    /* absorb full plaintext blocks */
+    while (len >= ASCON_HASH_RATE) {
+        s.x[0] ^= LOADBYTES(in, 8);
+        printstate("absorb plaintext", &s);
+        P12(&s);
+        in += ASCON_HASH_RATE;
+        len -= ASCON_HASH_RATE;
+    }
+    /* absorb final plaintext block */
+    s.x[0] ^= LOADBYTES(in, len);
+    s.x[0] ^= PAD(len);
+    printstate("pad plaintext", &s);
+    P12(&s);
+
+    /* squeeze full output blocks */
+    len = CRYPTO_BYTES;
+    while (len > ASCON_HASH_RATE) {
+        STOREBYTES(out, s.x[0], 8);
+        printstate("squeeze output", &s);
+        P12(&s);
+        out += ASCON_HASH_RATE;
+        len -= ASCON_HASH_RATE;
+    }
+    /* squeeze final output block */
+    STOREBYTES(out, s.x[0], len);
+    printstate("squeeze output", &s);
+    printbytes("h", out + len - CRYPTO_BYTES, CRYPTO_BYTES);
+
+    return 0;
+}
diff --git a/nimble/host/src/ascon/permutations.h b/nimble/host/src/ascon/permutations.h
new file mode 100644
index 00000000..02f1bcd5
--- /dev/null
+++ b/nimble/host/src/ascon/permutations.h
@@ -0,0 +1,46 @@
+#ifndef PERMUTATIONS_H_
+#define PERMUTATIONS_H_
+
+#include <stdint.h>
+
+#include "ascon.h"
+#include "constants.h"
+#include "printstate.h"
+#include "round.h"
+
+static inline void P12(ascon_state_t* s) {
+  ROUND(s, 0xf0);
+  ROUND(s, 0xe1);
+  ROUND(s, 0xd2);
+  ROUND(s, 0xc3);
+  ROUND(s, 0xb4);
+  ROUND(s, 0xa5);
+  ROUND(s, 0x96);
+  ROUND(s, 0x87);
+  ROUND(s, 0x78);
+  ROUND(s, 0x69);
+  ROUND(s, 0x5a);
+  ROUND(s, 0x4b);
+}
+
+static inline void P8(ascon_state_t* s) {
+  ROUND(s, 0xb4);
+  ROUND(s, 0xa5);
+  ROUND(s, 0x96);
+  ROUND(s, 0x87);
+  ROUND(s, 0x78);
+  ROUND(s, 0x69);
+  ROUND(s, 0x5a);
+  ROUND(s, 0x4b);
+}
+
+static inline void P6(ascon_state_t* s) {
+  ROUND(s, 0x96);
+  ROUND(s, 0x87);
+  ROUND(s, 0x78);
+  ROUND(s, 0x69);
+  ROUND(s, 0x5a);
+  ROUND(s, 0x4b);
+}
+
+#endif /* PERMUTATIONS_H_ */
diff --git a/nimble/host/src/ascon/prf.c b/nimble/host/src/ascon/prf.c
new file mode 100644
index 00000000..d93aa92f
--- /dev/null
+++ b/nimble/host/src/ascon/prf.c
@@ -0,0 +1,96 @@
+#include "api.h"
+#include "ascon.h"
+#include "crypto_auth.h"
+#include "permutations.h"
+#include "printstate.h"
+#include "word.h"
+
+#define CRYPTO_BYTES 16
+
+int
+crypto_prf(unsigned char* out, unsigned long long outlen,
+           const unsigned char* in, unsigned long long inlen,
+           const unsigned char* k)
+{
+    if (CRYPTO_BYTES && outlen > CRYPTO_BYTES)
+        return -1;
+    /* load key */
+    const uint64_t K0 = LOADBYTES(k, 8);
+    const uint64_t K1 = LOADBYTES(k + 8, 8);
+    int i;
+    printbytes("k", k, CRYPTO_KEYBYTES);
+    printbytes("m", in, inlen);
+    /* initialize */
+    ascon_state_t s;
+    s.x[0] = ASCON_MAC_IV;
+    s.x[1] = K0;
+    s.x[2] = K1;
+    s.x[3] = 0;
+    s.x[4] = 0;
+    printstate("initial value", &s);
+    P12(&s);
+    printstate("initialization", &s);
+
+    /* absorb full plaintext words */
+    i = 0;
+    while (inlen >= 8) {
+        ((uint64_t*)(&s.x[0]))[i] ^= LOADBYTES(in, 8);
+        if (++i == 4)
+            i = 0;
+        if (i == 0)
+            printstate("absorb plaintext", &s);
+        if (i == 0)
+            P12(&s);
+        in += 8;
+        inlen -= 8;
+    }
+    /* absorb final plaintext word */
+    ((uint64_t*)(&s.x[0]))[i] ^= LOADBYTES(in, inlen);
+    ((uint64_t*)(&s.x[0]))[i] ^= PAD(inlen);
+    printstate("pad plaintext", &s);
+    /* domain separation */
+    s.x[4] ^= DSEP();
+    printstate("domain separation", &s);
+
+    /* squeeze */
+    P12(&s);
+    /* squeeze output words */
+    i = 0;
+    while (outlen > 8) {
+        STOREBYTES(out, ((uint64_t*)(&s.x[0]))[i], 8);
+        if (++i == 2)
+            i = 0;
+        if (i == 0)
+            printstate("squeeze output", &s);
+        if (i == 0)
+            P12(&s);
+        out += 8;
+        outlen -= 8;
+    }
+    /* squeeze final output word */
+    STOREBYTES(out, ((uint64_t*)(&s.x[0]))[i], outlen);
+    printstate("squeeze output", &s);
+    printbytes("t", out, CRYPTO_BYTES);
+    print("\n");
+    return 0;
+}
+
+int
+crypto_auth(unsigned char* out, const unsigned char* in, unsigned long long len,
+            const unsigned char* k)
+{
+    return crypto_prf(out, CRYPTO_BYTES, in, len, k);
+}
+
+int
+crypto_auth_verify(const unsigned char* h, const unsigned char* in,
+                   unsigned long long len, const unsigned char* k)
+{
+    int i;
+    uint8_t diff = 0;
+    uint8_t tag[CRYPTO_BYTES];
+    crypto_prf(tag, CRYPTO_BYTES, in, len, k);
+    for (i = 0; i < CRYPTO_BYTES; ++i)
+        diff |= h[i] ^ tag[i];
+    return (1 & ((diff - 1) >> 8)) - 1;
+}
diff --git a/nimble/host/src/ascon/printstate.c b/nimble/host/src/ascon/printstate.c
new file mode 100644
index 00000000..2f0d0bc9
--- /dev/null
+++ b/nimble/host/src/ascon/printstate.c
@@ -0,0 +1,50 @@
+#ifdef ASCON_PRINT_STATE
+
+#include "printstate.h"
+
+#include <inttypes.h>
+#include <stdio.h>
+#include <string.h>
+
+#ifndef WORDTOU64
+#define WORDTOU64
+#endif
+
+#ifndef U64LE
+#define U64LE
+#endif
+
+void print(const char* text) { printf("%s", text); }
+
+void printbytes(const char* text, const uint8_t* b, uint64_t len) {
+  uint64_t i;
+  printf(" %s[%" PRIu64 "]\t= {", text, len);
+  for (i = 0; i < len; ++i) printf("0x%02x%s", b[i], i < len - 1 ? ", " : "");
+  printf("}\n");
+}
+
+void printword(const char* text, const uint64_t x) {
+  printf("%s=0x%016" PRIx64, text, U64LE(WORDTOU64(x)));
+}
+
+void printstate(const char* text, const ascon_state_t* s) {
+  int i;
+  printf("%s:", text);
+  for (i = strlen(text); i < 17; ++i) printf(" ");
+  printword(" x0", s->x[0]);
+  printword(" x1", s->x[1]);
+  printword(" x2", s->x[2]);
+  printword(" x3", s->x[3]);
+  printword(" x4", s->x[4]);
+#ifdef ASCON_PRINT_BI
+  printf(" ");
+  printf(" x0=%08x_%08x", s->w[0][1], s->w[0][0]);
+  printf(" x1=%08x_%08x", s->w[1][1], s->w[1][0]);
+  printf(" x2=%08x_%08x", s->w[2][1], s->w[2][0]);
+  printf(" x3=%08x_%08x", s->w[3][1], s->w[3][0]);
+  printf(" x4=%08x_%08x", s->w[4][1], s->w[4][0]);
+#endif
+  printf("\n");
+}
+
+#endif
diff --git a/nimble/host/src/ascon/printstate.h b/nimble/host/src/ascon/printstate.h
new file mode 100644
index 00000000..5b30bef1
--- /dev/null
+++ b/nimble/host/src/ascon/printstate.h
@@ -0,0 +1,34 @@
+#ifndef PRINTSTATE_H_
+#define PRINTSTATE_H_
+
+#ifdef ASCON_PRINT_STATE
+
+#include "ascon.h"
+#include "word.h"
+
+void print(const char* text);
+void printbytes(const char* text, const uint8_t* b, uint64_t len);
+void printword(const char* text, const uint64_t x);
+void printstate(const char* text, const ascon_state_t* s);
+
+#else
+
+#define print(text) \
+  do {              \
+  } while (0)
+
+#define printbytes(text, b, l) \
+  do {                         \
+  } while (0)
+
+#define printword(text, w) \
+  do {                     \
+  } while (0)
+
+#define printstate(text, s) \
+  do {                      \
+  } while (0)
+
+#endif
+
+#endif /* PRINTSTATE_H_ */
diff --git a/nimble/host/src/ascon/round.h b/nimble/host/src/ascon/round.h
new file mode 100644
index 00000000..a3ef5bfc
--- /dev/null
+++ b/nimble/host/src/ascon/round.h
@@ -0,0 +1,42 @@
+#ifndef ROUND_H_
+#define ROUND_H_
+
+#include "ascon.h"
+#include "constants.h"
+#include "printstate.h"
+
+static inline uint64_t ROR(uint64_t x, int n) {
+  return x >> n | x << (-n & 63);
+}
+
+static inline void ROUND(ascon_state_t* s, uint8_t C) {
+  ascon_state_t t;
+  /* addition of round constant */
+  s->x[2] ^= C;
+  /* printstate(" round constant", s); */
+  /* substitution layer */
+  s->x[0] ^= s->x[4];
+  s->x[4] ^= s->x[3];
+  s->x[2] ^= s->x[1];
+  /* start of keccak s-box */
+  t.x[0] = s->x[0] ^ (~s->x[1] & s->x[2]);
+  t.x[1] = s->x[1] ^ (~s->x[2] & s->x[3]);
+  t.x[2] = s->x[2] ^ (~s->x[3] & s->x[4]);
+  t.x[3] = s->x[3] ^ (~s->x[4] & s->x[0]);
+  t.x[4] = s->x[4] ^ (~s->x[0] & s->x[1]);
+  /* end of keccak s-box */
+  t.x[1] ^= t.x[0];
+  t.x[0] ^= t.x[4];
+  t.x[3] ^= t.x[2];
+  t.x[2] = ~t.x[2];
+  /* printstate(" substitution layer", &t); */
+  /* linear diffusion layer */
+  s->x[0] = t.x[0] ^ ROR(t.x[0], 19) ^ ROR(t.x[0], 28);
+  s->x[1] = t.x[1] ^ ROR(t.x[1], 61) ^ ROR(t.x[1], 39);
+  s->x[2] = t.x[2] ^ ROR(t.x[2], 1) ^ ROR(t.x[2], 6);
+  s->x[3] = t.x[3] ^ ROR(t.x[3], 10) ^ ROR(t.x[3], 17);
+  s->x[4] = t.x[4] ^ ROR(t.x[4], 7) ^ ROR(t.x[4], 41);
+  printstate(" round output", s);
+}
+
+#endif /* ROUND_H_ */
diff --git a/nimble/host/src/ascon/word.h b/nimble/host/src/ascon/word.h
new file mode 100644
index 00000000..9a1125c9
--- /dev/null
+++ b/nimble/host/src/ascon/word.h
@@ -0,0 +1,39 @@
+#ifndef WORD_H_
+#define WORD_H_
+
+#include <stdint.h>
+
+/* get byte from 64-bit Ascon word */
+#define GETBYTE(x, i) ((uint8_t)((uint64_t)(x) >> (8 * (i))))
+
+/* set byte in 64-bit Ascon word */
+#define SETBYTE(b, i) ((uint64_t)(b) << (8 * (i)))
+
+/* set padding byte in 64-bit Ascon word */
+#define PAD(i) SETBYTE(0x01, i)
+
+/* define domain separation bit in 64-bit Ascon word */
+#define DSEP() SETBYTE(0x80, 7)
+
+/* load bytes into 64-bit Ascon word */
+static inline uint64_t LOADBYTES(const uint8_t* bytes, int n) {
+  int i;
+  uint64_t x = 0;
+  for (i = 0; i < n; ++i) x |= SETBYTE(bytes[i], i);
+  return x;
+}
+
+/* store bytes from 64-bit Ascon word */
+static inline void STOREBYTES(uint8_t* bytes, uint64_t x, int n) {
+  int i;
+  for (i = 0; i < n; ++i) bytes[i] = GETBYTE(x, i);
+}
+
+/* clear bytes in 64-bit Ascon word */
+static inline uint64_t CLEARBYTES(uint64_t x, int n) {
+  int i;
+  for (i = 0; i < n; ++i) x &= ~SETBYTE(0xff, i);
+  return x;
+}
+
+#endif /* WORD_H_ */
diff --git a/nimble/host/src/blake/blake2-impl.h b/nimble/host/src/blake/blake2-impl.h
new file mode 100644
index 00000000..6f2f7e96
--- /dev/null
+++ b/nimble/host/src/blake/blake2-impl.h
@@ -0,0 +1,161 @@
+/*
+   BLAKE2 reference source code package - reference C implementations
+
+   Copyright 2012, Samuel Neves <sneves@dei.uc.pt>.  You may use this under the
+   terms of the CC0, the OpenSSL Licence, or the Apache Public License 2.0, at
+   your option.  The terms of these licenses can be found at:
+
+   - CC0 1.0 Universal : http://creativecommons.org/publicdomain/zero/1.0
+   - OpenSSL license   : https://www.openssl.org/source/license.html
+   - Apache 2.0        : http://www.apache.org/licenses/LICENSE-2.0
+
+   More information about the BLAKE2 hash function can be found at
+   https://blake2.net.
+*/
+#ifndef BLAKE2_IMPL_H
+#define BLAKE2_IMPL_H
+
+#include <stdint.h>
+#include <string.h>
+
+#if !defined(__cplusplus) && (!defined(__STDC_VERSION__) || __STDC_VERSION__ < 199901L)
+#if defined(_MSC_VER)
+#define BLAKE2_INLINE __inline
+#elif defined(__GNUC__)
+#define BLAKE2_INLINE __inline__
+#else
+#define BLAKE2_INLINE
+#endif
+#else
+#define BLAKE2_INLINE inline
+#endif
+
+static BLAKE2_INLINE uint32_t load32(const void *src)
+{
+#if defined(NATIVE_LITTLE_ENDIAN)
+    uint32_t w;
+    memcpy(&w, src, sizeof w);
+    return w;
+#else
+    const uint8_t *p = (const uint8_t *)src;
+    return ((uint32_t)(p[0]) << 0) |
+           ((uint32_t)(p[1]) << 8) |
+           ((uint32_t)(p[2]) << 16) |
+           ((uint32_t)(p[3]) << 24);
+#endif
+}
+
+static BLAKE2_INLINE uint64_t load64(const void *src)
+{
+#if defined(NATIVE_LITTLE_ENDIAN)
+    uint64_t w;
+    memcpy(&w, src, sizeof w);
+    return w;
+#else
+    const uint8_t *p = (const uint8_t *)src;
+    return ((uint64_t)(p[0]) << 0) |
+           ((uint64_t)(p[1]) << 8) |
+           ((uint64_t)(p[2]) << 16) |
+           ((uint64_t)(p[3]) << 24) |
+           ((uint64_t)(p[4]) << 32) |
+           ((uint64_t)(p[5]) << 40) |
+           ((uint64_t)(p[6]) << 48) |
+           ((uint64_t)(p[7]) << 56);
+#endif
+}
+
+static BLAKE2_INLINE uint16_t load16(const void *src)
+{
+#if defined(NATIVE_LITTLE_ENDIAN)
+    uint16_t w;
+    memcpy(&w, src, sizeof w);
+    return w;
+#else
+    const uint8_t *p = (const uint8_t *)src;
+    return (uint16_t)(((uint32_t)(p[0]) << 0) |
+                      ((uint32_t)(p[1]) << 8));
+#endif
+}
+
+static BLAKE2_INLINE void store16(void *dst, uint16_t w)
+{
+#if defined(NATIVE_LITTLE_ENDIAN)
+    memcpy(dst, &w, sizeof w);
+#else
+    uint8_t *p = (uint8_t *)dst;
+    *p++ = (uint8_t)w;
+    w >>= 8;
+    *p++ = (uint8_t)w;
+#endif
+}
+
+static BLAKE2_INLINE void store32(void *dst, uint32_t w)
+{
+#if defined(NATIVE_LITTLE_ENDIAN)
+    memcpy(dst, &w, sizeof w);
+#else
+    uint8_t *p = (uint8_t *)dst;
+    p[0] = (uint8_t)(w >> 0);
+    p[1] = (uint8_t)(w >> 8);
+    p[2] = (uint8_t)(w >> 16);
+    p[3] = (uint8_t)(w >> 24);
+#endif
+}
+
+static BLAKE2_INLINE void store64(void *dst, uint64_t w)
+{
+#if defined(NATIVE_LITTLE_ENDIAN)
+    memcpy(dst, &w, sizeof w);
+#else
+    uint8_t *p = (uint8_t *)dst;
+    p[0] = (uint8_t)(w >> 0);
+    p[1] = (uint8_t)(w >> 8);
+    p[2] = (uint8_t)(w >> 16);
+    p[3] = (uint8_t)(w >> 24);
+    p[4] = (uint8_t)(w >> 32);
+    p[5] = (uint8_t)(w >> 40);
+    p[6] = (uint8_t)(w >> 48);
+    p[7] = (uint8_t)(w >> 56);
+#endif
+}
+
+static BLAKE2_INLINE uint64_t load48(const void *src)
+{
+    const uint8_t *p = (const uint8_t *)src;
+    return ((uint64_t)(p[0]) << 0) |
+           ((uint64_t)(p[1]) << 8) |
+           ((uint64_t)(p[2]) << 16) |
+           ((uint64_t)(p[3]) << 24) |
+           ((uint64_t)(p[4]) << 32) |
+           ((uint64_t)(p[5]) << 40);
+}
+
+static BLAKE2_INLINE void store48(void *dst, uint64_t w)
+{
+    uint8_t *p = (uint8_t *)dst;
+    p[0] = (uint8_t)(w >> 0);
+    p[1] = (uint8_t)(w >> 8);
+    p[2] = (uint8_t)(w >> 16);
+    p[3] = (uint8_t)(w >> 24);
+    p[4] = (uint8_t)(w >> 32);
+    p[5] = (uint8_t)(w >> 40);
+}
+
+static BLAKE2_INLINE uint32_t rotr32(const uint32_t w, const unsigned c)
+{
+    return (w >> c) | (w << (32 - c));
+}
+
+static BLAKE2_INLINE uint64_t rotr64(const uint64_t w, const unsigned c)
+{
+    return (w >> c) | (w << (64 - c));
+}
+
+/* prevents compiler optimizing out memset() */
+static BLAKE2_INLINE void secure_zero_memory(void *v, size_t n)
+{
+    static void *(*const volatile memset_v)(void *, int, size_t) = &memset;
+    memset_v(v, 0, n);
+}
+
+#endif
\ No newline at end of file
diff --git a/nimble/host/src/blake/blake2.h b/nimble/host/src/blake/blake2.h
new file mode 100644
index 00000000..8e6b79ae
--- /dev/null
+++ b/nimble/host/src/blake/blake2.h
@@ -0,0 +1,194 @@
+/*
+   BLAKE2 reference source code package - reference C implementations
+
+   Copyright 2012, Samuel Neves <sneves@dei.uc.pt>.  You may use this under the
+   terms of the CC0, the OpenSSL Licence, or the Apache Public License 2.0, at
+   your option.  The terms of these licenses can be found at:
+
+   - CC0 1.0 Universal : http://creativecommons.org/publicdomain/zero/1.0
+   - OpenSSL license   : https://www.openssl.org/source/license.html
+   - Apache 2.0        : http://www.apache.org/licenses/LICENSE-2.0
+
+   More information about the BLAKE2 hash function can be found at
+   https://blake2.net.
+*/
+#ifndef BLAKE2_H
+#define BLAKE2_H
+
+#include <stddef.h>
+#include <stdint.h>
+
+#if defined(_MSC_VER)
+#define BLAKE2_PACKED(x) __pragma(pack(push, 1)) x __pragma(pack(pop))
+#else
+#define BLAKE2_PACKED(x) x __attribute__((packed))
+#endif
+
+#if defined(__cplusplus)
+extern "C"
+{
+#endif
+
+    enum blake2s_constant
+    {
+        BLAKE2S_BLOCKBYTES = 64,
+        BLAKE2S_OUTBYTES = 32,
+        BLAKE2S_KEYBYTES = 32,
+        BLAKE2S_SALTBYTES = 8,
+        BLAKE2S_PERSONALBYTES = 8
+    };
+
+    enum blake2b_constant
+    {
+        BLAKE2B_BLOCKBYTES = 128,
+        BLAKE2B_OUTBYTES = 64,
+        BLAKE2B_KEYBYTES = 64,
+        BLAKE2B_SALTBYTES = 16,
+        BLAKE2B_PERSONALBYTES = 16
+    };
+
+    typedef struct blake2s_state__
+    {
+        uint32_t h[8];
+        uint32_t t[2];
+        uint32_t f[2];
+        uint8_t buf[BLAKE2S_BLOCKBYTES];
+        size_t buflen;
+        size_t outlen;
+        uint8_t last_node;
+    } blake2s_state;
+
+    typedef struct blake2b_state__
+    {
+        uint64_t h[8];
+        uint64_t t[2];
+        uint64_t f[2];
+        uint8_t buf[BLAKE2B_BLOCKBYTES];
+        size_t buflen;
+        size_t outlen;
+        uint8_t last_node;
+    } blake2b_state;
+
+    typedef struct blake2sp_state__
+    {
+        blake2s_state S[8][1];
+        blake2s_state R[1];
+        uint8_t buf[8 * BLAKE2S_BLOCKBYTES];
+        size_t buflen;
+        size_t outlen;
+    } blake2sp_state;
+
+    typedef struct blake2bp_state__
+    {
+        blake2b_state S[4][1];
+        blake2b_state R[1];
+        uint8_t buf[4 * BLAKE2B_BLOCKBYTES];
+        size_t buflen;
+        size_t outlen;
+    } blake2bp_state;
+
+    BLAKE2_PACKED(struct blake2s_param__ {
+        uint8_t digest_length; /* 1 */
+        uint8_t key_length;    /* 2 */
+        uint8_t fanout;        /* 3 */
+        uint8_t depth;         /* 4 */
+        uint32_t leaf_length;  /* 8 */
+        uint32_t node_offset;  /* 12 */
+        uint16_t xof_length;   /* 14 */
+        uint8_t node_depth;    /* 15 */
+        uint8_t inner_length;  /* 16 */
+        /* uint8_t  reserved[0]; */
+        uint8_t salt[BLAKE2S_SALTBYTES];         /* 24 */
+        uint8_t personal[BLAKE2S_PERSONALBYTES]; /* 32 */
+    });
+
+    typedef struct blake2s_param__ blake2s_param;
+
+    BLAKE2_PACKED(struct blake2b_param__ {
+        uint8_t digest_length;                   /* 1 */
+        uint8_t key_length;                      /* 2 */
+        uint8_t fanout;                          /* 3 */
+        uint8_t depth;                           /* 4 */
+        uint32_t leaf_length;                    /* 8 */
+        uint32_t node_offset;                    /* 12 */
+        uint32_t xof_length;                     /* 16 */
+        uint8_t node_depth;                      /* 17 */
+        uint8_t inner_length;                    /* 18 */
+        uint8_t reserved[14];                    /* 32 */
+        uint8_t salt[BLAKE2B_SALTBYTES];         /* 48 */
+        uint8_t personal[BLAKE2B_PERSONALBYTES]; /* 64 */
+    });
+
+    typedef struct blake2b_param__ blake2b_param;
+
+    typedef struct blake2xs_state__
+    {
+        blake2s_state S[1];
+        blake2s_param P[1];
+    } blake2xs_state;
+
+    typedef struct blake2xb_state__
+    {
+        blake2b_state S[1];
+        blake2b_param P[1];
+    } blake2xb_state;
+
+    /* Padded structs result in a compile-time error */
+    enum
+    {
+        BLAKE2_DUMMY_1 = 1 / (int)(sizeof(blake2s_param) == BLAKE2S_OUTBYTES),
+        BLAKE2_DUMMY_2 = 1 / (int)(sizeof(blake2b_param) == BLAKE2B_OUTBYTES)
+    };
+
+    /* Streaming API */
+    int blake2s_init(blake2s_state *S, size_t outlen);
+    int blake2s_init_key(blake2s_state *S, size_t outlen, const void *key, size_t keylen);
+    int blake2s_init_param(blake2s_state *S, const blake2s_param *P);
+    int blake2s_update(blake2s_state *S, const void *in, size_t inlen);
+    int blake2s_final(blake2s_state *S, void *out, size_t outlen);
+
+    int blake2b_init(blake2b_state *S, size_t outlen);
+    int blake2b_init_key(blake2b_state *S, size_t outlen, const void *key, size_t keylen);
+    int blake2b_init_param(blake2b_state *S, const blake2b_param *P);
+    int blake2b_update(blake2b_state *S, const void *in, size_t inlen);
+    int blake2b_final(blake2b_state *S, void *out, size_t outlen);
+
+    int blake2sp_init(blake2sp_state *S, size_t outlen);
+    int blake2sp_init_key(blake2sp_state *S, size_t outlen, const void *key, size_t keylen);
+    int blake2sp_update(blake2sp_state *S, const void *in, size_t inlen);
+    int blake2sp_final(blake2sp_state *S, void *out, size_t outlen);
+
+    int blake2bp_init(blake2bp_state *S, size_t outlen);
+    int blake2bp_init_key(blake2bp_state *S, size_t outlen, const void *key, size_t keylen);
+    int blake2bp_update(blake2bp_state *S, const void *in, size_t inlen);
+    int blake2bp_final(blake2bp_state *S, void *out, size_t outlen);
+
+    /* Variable output length API */
+    int blake2xs_init(blake2xs_state *S, const size_t outlen);
+    int blake2xs_init_key(blake2xs_state *S, const size_t outlen, const void *key, size_t keylen);
+    int blake2xs_update(blake2xs_state *S, const void *in, size_t inlen);
+    int blake2xs_final(blake2xs_state *S, void *out, size_t outlen);
+
+    int blake2xb_init(blake2xb_state *S, const size_t outlen);
+    int blake2xb_init_key(blake2xb_state *S, const size_t outlen, const void *key, size_t keylen);
+    int blake2xb_update(blake2xb_state *S, const void *in, size_t inlen);
+    int blake2xb_final(blake2xb_state *S, void *out, size_t outlen);
+
+    /* Simple API */
+    int blake2s(void *out, size_t outlen, const void *in, size_t inlen, const void *key, size_t keylen);
+    int blake2b(void *out, size_t outlen, const void *in, size_t inlen, const void *key, size_t keylen);
+
+    int blake2sp(void *out, size_t outlen, const void *in, size_t inlen, const void *key, size_t keylen);
+    int blake2bp(void *out, size_t outlen, const void *in, size_t inlen, const void *key, size_t keylen);
+
+    int blake2xs(void *out, size_t outlen, const void *in, size_t inlen, const void *key, size_t keylen);
+    int blake2xb(void *out, size_t outlen, const void *in, size_t inlen, const void *key, size_t keylen);
+
+    /* This is simply an alias for blake2b */
+    int blake2(void *out, size_t outlen, const void *in, size_t inlen, const void *key, size_t keylen);
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif
\ No newline at end of file
diff --git a/nimble/host/src/blake/blake2b.c b/nimble/host/src/blake/blake2b.c
new file mode 100644
index 00000000..e7aad911
--- /dev/null
+++ b/nimble/host/src/blake/blake2b.c
@@ -0,0 +1,399 @@
+/*
+   BLAKE2 reference source code package - reference C implementations
+
+   Copyright 2012, Samuel Neves <sneves@dei.uc.pt>.  You may use this under the
+   terms of the CC0, the OpenSSL Licence, or the Apache Public License 2.0, at
+   your option.  The terms of these licenses can be found at:
+
+   - CC0 1.0 Universal : http://creativecommons.org/publicdomain/zero/1.0
+   - OpenSSL license   : https://www.openssl.org/source/license.html
+   - Apache 2.0        : http://www.apache.org/licenses/LICENSE-2.0
+
+   More information about the BLAKE2 hash function can be found at
+   https://blake2.net.
+*/
+
+#include <stdint.h>
+#include <string.h>
+#include <stdio.h>
+
+#include "blake2.h"
+#include "blake2-impl.h"
+
+static const uint64_t blake2b_IV[8] = {
+    0x6a09e667f3bcc908ULL, 0xbb67ae8584caa73bULL, 0x3c6ef372fe94f82bULL,
+    0xa54ff53a5f1d36f1ULL, 0x510e527fade682d1ULL, 0x9b05688c2b3e6c1fULL,
+    0x1f83d9abfb41bd6bULL, 0x5be0cd19137e2179ULL};
+
+static const uint8_t blake2b_sigma[12][16] = {
+    {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15},
+    {14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3},
+    {11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4},
+    {7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8},
+    {9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13},
+    {2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9},
+    {12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11},
+    {13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10},
+    {6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5},
+    {10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0},
+    {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15},
+    {14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3}};
+
+static void
+blake2b_set_lastnode(blake2b_state* S)
+{
+    S->f[1] = (uint64_t)-1;
+}
+
+/* Some helper functions, not necessarily useful */
+static int
+blake2b_is_lastblock(const blake2b_state* S)
+{
+    return S->f[0] != 0;
+}
+
+static void
+blake2b_set_lastblock(blake2b_state* S)
+{
+    if (S->last_node)
+        blake2b_set_lastnode(S);
+
+    S->f[0] = (uint64_t)-1;
+}
+
+static void
+blake2b_increment_counter(blake2b_state* S, const uint64_t inc)
+{
+    S->t[0] += inc;
+    S->t[1] += (S->t[0] < inc);
+}
+
+static void
+blake2b_init0(blake2b_state* S)
+{
+    size_t i;
+    memset(S, 0, sizeof(blake2b_state));
+
+    for (i = 0; i < 8; ++i)
+        S->h[i] = blake2b_IV[i];
+}
+
+/* init xors IV with input parameter block */
+int
+blake2b_init_param(blake2b_state* S, const blake2b_param* P)
+{
+    const uint8_t* p = (const uint8_t*)(P);
+    size_t i;
+
+    blake2b_init0(S);
+
+    /* IV XOR ParamBlock */
+    for (i = 0; i < 8; ++i)
+        S->h[i] ^= load64(p + sizeof(S->h[i]) * i);
+
+    S->outlen = P->digest_length;
+    return 0;
+}
+
+int
+blake2b_init(blake2b_state* S, size_t outlen)
+{
+    blake2b_param P[1];
+
+    if ((!outlen) || (outlen > BLAKE2B_OUTBYTES))
+        return -1;
+
+    P->digest_length = (uint8_t)outlen;
+    P->key_length = 0;
+    P->fanout = 1;
+    P->depth = 1;
+    store32(&P->leaf_length, 0);
+    store32(&P->node_offset, 0);
+    store32(&P->xof_length, 0);
+    P->node_depth = 0;
+    P->inner_length = 0;
+    memset(P->reserved, 0, sizeof(P->reserved));
+    memset(P->salt, 0, sizeof(P->salt));
+    memset(P->personal, 0, sizeof(P->personal));
+    return blake2b_init_param(S, P);
+}
+
+int
+blake2b_init_key(blake2b_state* S, size_t outlen, const void* key,
+                 size_t keylen)
+{
+    blake2b_param P[1];
+
+    if ((!outlen) || (outlen > BLAKE2B_OUTBYTES))
+        return -1;
+
+    if (!key || !keylen || keylen > BLAKE2B_KEYBYTES)
+        return -1;
+
+    P->digest_length = (uint8_t)outlen;
+    P->key_length = (uint8_t)keylen;
+    P->fanout = 1;
+    P->depth = 1;
+    store32(&P->leaf_length, 0);
+    store32(&P->node_offset, 0);
+    store32(&P->xof_length, 0);
+    P->node_depth = 0;
+    P->inner_length = 0;
+    memset(P->reserved, 0, sizeof(P->reserved));
+    memset(P->salt, 0, sizeof(P->salt));
+    memset(P->personal, 0, sizeof(P->personal));
+
+    if (blake2b_init_param(S, P) < 0)
+        return -1;
+
+    {
+        uint8_t block[BLAKE2B_BLOCKBYTES];
+        memset(block, 0, BLAKE2B_BLOCKBYTES);
+        memcpy(block, key, keylen);
+        blake2b_update(S, block, BLAKE2B_BLOCKBYTES);
+        secure_zero_memory(block,
+                           BLAKE2B_BLOCKBYTES); /* Burn the key from stack */
+    }
+    return 0;
+}
+
+#define G(r, i, a, b, c, d)                                                    \
+    do {                                                                       \
+        a = a + b + m[blake2b_sigma[r][2 * i + 0]];                            \
+        d = rotr64(d ^ a, 32);                                                 \
+        c = c + d;                                                             \
+        b = rotr64(b ^ c, 24);                                                 \
+        a = a + b + m[blake2b_sigma[r][2 * i + 1]];                            \
+        d = rotr64(d ^ a, 16);                                                 \
+        c = c + d;                                                             \
+        b = rotr64(b ^ c, 63);                                                 \
+    } while (0)
+
+#define ROUND(r)                                                               \
+    do {                                                                       \
+        G(r, 0, v[0], v[4], v[8], v[12]);                                      \
+        G(r, 1, v[1], v[5], v[9], v[13]);                                      \
+        G(r, 2, v[2], v[6], v[10], v[14]);                                     \
+        G(r, 3, v[3], v[7], v[11], v[15]);                                     \
+        G(r, 4, v[0], v[5], v[10], v[15]);                                     \
+        G(r, 5, v[1], v[6], v[11], v[12]);                                     \
+        G(r, 6, v[2], v[7], v[8], v[13]);                                      \
+        G(r, 7, v[3], v[4], v[9], v[14]);                                      \
+    } while (0)
+
+static void
+blake2b_compress(blake2b_state* S, const uint8_t block[BLAKE2B_BLOCKBYTES])
+{
+    uint64_t m[16];
+    uint64_t v[16];
+    size_t i;
+
+    for (i = 0; i < 16; ++i) {
+        m[i] = load64(block + i * sizeof(m[i]));
+    }
+
+    for (i = 0; i < 8; ++i) {
+        v[i] = S->h[i];
+    }
+
+    v[8] = blake2b_IV[0];
+    v[9] = blake2b_IV[1];
+    v[10] = blake2b_IV[2];
+    v[11] = blake2b_IV[3];
+    v[12] = blake2b_IV[4] ^ S->t[0];
+    v[13] = blake2b_IV[5] ^ S->t[1];
+    v[14] = blake2b_IV[6] ^ S->f[0];
+    v[15] = blake2b_IV[7] ^ S->f[1];
+
+    ROUND(0);
+    ROUND(1);
+    ROUND(2);
+    ROUND(3);
+    ROUND(4);
+    ROUND(5);
+    ROUND(6);
+    ROUND(7);
+    ROUND(8);
+    ROUND(9);
+    ROUND(10);
+    ROUND(11);
+
+    for (i = 0; i < 8; ++i) {
+        S->h[i] = S->h[i] ^ v[i] ^ v[i + 8];
+    }
+}
+
+#undef G
+#undef ROUND
+
+int
+blake2b_update(blake2b_state* S, const void* pin, size_t inlen)
+{
+    const unsigned char* in = (const unsigned char*)pin;
+    if (inlen > 0) {
+        size_t left = S->buflen;
+        size_t fill = BLAKE2B_BLOCKBYTES - left;
+        if (inlen > fill) {
+            S->buflen = 0;
+            memcpy(S->buf + left, in, fill); /* Fill buffer */
+            blake2b_increment_counter(S, BLAKE2B_BLOCKBYTES);
+            blake2b_compress(S, S->buf); /* Compress */
+            in += fill;
+            inlen -= fill;
+            while (inlen > BLAKE2B_BLOCKBYTES) {
+                blake2b_increment_counter(S, BLAKE2B_BLOCKBYTES);
+                blake2b_compress(S, in);
+                in += BLAKE2B_BLOCKBYTES;
+                inlen -= BLAKE2B_BLOCKBYTES;
+            }
+        }
+        memcpy(S->buf + S->buflen, in, inlen);
+        S->buflen += inlen;
+    }
+    return 0;
+}
+
+int
+blake2b_final(blake2b_state* S, void* out, size_t outlen)
+{
+    uint8_t buffer[BLAKE2B_OUTBYTES] = {0};
+    size_t i;
+
+    if (out == NULL || outlen < S->outlen)
+        return -1;
+
+    if (blake2b_is_lastblock(S))
+        return -1;
+
+    blake2b_increment_counter(S, S->buflen);
+    blake2b_set_lastblock(S);
+    memset(S->buf + S->buflen, 0, BLAKE2B_BLOCKBYTES - S->buflen); /* Padding */
+    blake2b_compress(S, S->buf);
+
+    for (i = 0; i < 8; ++i) /* Output full hash to temp buffer */
+        store64(buffer + sizeof(S->h[i]) * i, S->h[i]);
+
+    memcpy(out, buffer, S->outlen);
+    secure_zero_memory(buffer, sizeof(buffer));
+    return 0;
+}
+
+/* inlen, at least, should be uint64_t. Others can be size_t. */
+int
+blake2b(void* out, size_t outlen, const void* in, size_t inlen, const void* key,
+        size_t keylen)
+{
+    blake2b_state S[1];
+
+    /* Verify parameters */
+    if (NULL == in && inlen > 0)
+        return -1;
+
+    if (NULL == out)
+        return -1;
+
+    if (NULL == key && keylen > 0)
+        return -1;
+
+    if (!outlen || outlen > BLAKE2B_OUTBYTES)
+        return -1;
+
+    if (keylen > BLAKE2B_KEYBYTES)
+        return -1;
+
+    if (keylen > 0) {
+        if (blake2b_init_key(S, outlen, key, keylen) < 0)
+            return -1;
+    }
+    else {
+        if (blake2b_init(S, outlen) < 0)
+            return -1;
+    }
+
+    blake2b_update(S, (const uint8_t*)in, inlen);
+    blake2b_final(S, out, outlen);
+    return 0;
+}
+
+int
+blake2(void* out, size_t outlen, const void* in, size_t inlen, const void* key,
+       size_t keylen)
+{
+    return blake2b(out, outlen, in, inlen, key, keylen);
+}
+
+#if defined(SUPERCOP)
+int
+crypto_hash(unsigned char* out, unsigned char* in, unsigned long long inlen)
+{
+    return blake2b(out, BLAKE2B_OUTBYTES, in, inlen, NULL, 0);
+}
+#endif
+
+#if defined(BLAKE2B_SELFTEST)
+#include <string.h>
+#include "blake2-kat.h"
+int
+main(void)
+{
+    uint8_t key[BLAKE2B_KEYBYTES];
+    uint8_t buf[BLAKE2_KAT_LENGTH];
+    size_t i, step;
+
+    for (i = 0; i < BLAKE2B_KEYBYTES; ++i)
+        key[i] = (uint8_t)i;
+
+    for (i = 0; i < BLAKE2_KAT_LENGTH; ++i)
+        buf[i] = (uint8_t)i;
+
+    /* Test simple API */
+    for (i = 0; i < BLAKE2_KAT_LENGTH; ++i) {
+        uint8_t hash[BLAKE2B_OUTBYTES];
+        blake2b(hash, BLAKE2B_OUTBYTES, buf, i, key, BLAKE2B_KEYBYTES);
+
+        if (0 != memcmp(hash, blake2b_keyed_kat[i], BLAKE2B_OUTBYTES)) {
+            goto fail;
+        }
+    }
+
+    /* Test streaming API */
+    for (step = 1; step < BLAKE2B_BLOCKBYTES; ++step) {
+        for (i = 0; i < BLAKE2_KAT_LENGTH; ++i) {
+            uint8_t hash[BLAKE2B_OUTBYTES];
+            blake2b_state S;
+            uint8_t* p = buf;
+            size_t mlen = i;
+            int err = 0;
+
+            if ((err = blake2b_init_key(&S, BLAKE2B_OUTBYTES, key,
+                                        BLAKE2B_KEYBYTES)) < 0) {
+                goto fail;
+            }
+
+            while (mlen >= step) {
+                if ((err = blake2b_update(&S, p, step)) < 0) {
+                    goto fail;
+                }
+                mlen -= step;
+                p += step;
+            }
+            if ((err = blake2b_update(&S, p, mlen)) < 0) {
+                goto fail;
+            }
+            if ((err = blake2b_final(&S, hash, BLAKE2B_OUTBYTES)) < 0) {
+                goto fail;
+            }
+
+            if (0 != memcmp(hash, blake2b_keyed_kat[i], BLAKE2B_OUTBYTES)) {
+                goto fail;
+            }
+        }
+    }
+
+    puts("ok");
+    return 0;
+fail:
+    puts("error");
+    return -1;
+}
+#endif
\ No newline at end of file
diff --git a/nimble/host/src/blake2s.c b/nimble/host/src/blake2s.c
new file mode 100644
index 00000000..c59115f9
--- /dev/null
+++ b/nimble/host/src/blake2s.c
@@ -0,0 +1,393 @@
+/*
+   BLAKE2 reference source code package - reference C implementations
+
+   Copyright 2012, Samuel Neves <sneves@dei.uc.pt>.  You may use this under the
+   terms of the CC0, the OpenSSL Licence, or the Apache Public License 2.0, at
+   your option.  The terms of these licenses can be found at:
+
+   - CC0 1.0 Universal : http://creativecommons.org/publicdomain/zero/1.0
+   - OpenSSL license   : https://www.openssl.org/source/license.html
+   - Apache 2.0        : http://www.apache.org/licenses/LICENSE-2.0
+
+   More information about the BLAKE2 hash function can be found at
+   https://blake2.net.
+*/
+
+#include <stdint.h>
+#include <string.h>
+#include <stdio.h>
+
+#include "crypto/blake2.h"
+#include "crypto/blake2-impl.h"
+
+static const uint32_t blake2s_IV[8] =
+    {
+        0x6A09E667UL, 0xBB67AE85UL, 0x3C6EF372UL, 0xA54FF53AUL,
+        0x510E527FUL, 0x9B05688CUL, 0x1F83D9ABUL, 0x5BE0CD19UL};
+
+static const uint8_t blake2s_sigma[10][16] =
+    {
+        {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15},
+        {14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3},
+        {11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4},
+        {7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8},
+        {9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13},
+        {2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9},
+        {12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11},
+        {13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10},
+        {6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5},
+        {10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0},
+};
+
+static void blake2s_set_lastnode(blake2s_state *S)
+{
+    S->f[1] = (uint32_t)-1;
+}
+
+/* Some helper functions, not necessarily useful */
+static int blake2s_is_lastblock(const blake2s_state *S)
+{
+    return S->f[0] != 0;
+}
+
+static void blake2s_set_lastblock(blake2s_state *S)
+{
+    if (S->last_node)
+        blake2s_set_lastnode(S);
+
+    S->f[0] = (uint32_t)-1;
+}
+
+static void blake2s_increment_counter(blake2s_state *S, const uint32_t inc)
+{
+    S->t[0] += inc;
+    S->t[1] += (S->t[0] < inc);
+}
+
+static void blake2s_init0(blake2s_state *S)
+{
+    size_t i;
+    memset(S, 0, sizeof(blake2s_state));
+
+    for (i = 0; i < 8; ++i)
+        S->h[i] = blake2s_IV[i];
+}
+
+/* init2 xors IV with input parameter block */
+int blake2s_init_param(blake2s_state *S, const blake2s_param *P)
+{
+    const unsigned char *p = (const unsigned char *)(P);
+    size_t i;
+
+    blake2s_init0(S);
+
+    /* IV XOR ParamBlock */
+    for (i = 0; i < 8; ++i)
+        S->h[i] ^= load32(&p[i * 4]);
+
+    S->outlen = P->digest_length;
+    return 0;
+}
+
+/* Sequential blake2s initialization */
+int blake2s_init(blake2s_state *S, size_t outlen)
+{
+    blake2s_param P[1];
+
+    /* Move interval verification here? */
+    if ((!outlen) || (outlen > BLAKE2S_OUTBYTES))
+        return -1;
+
+    P->digest_length = (uint8_t)outlen;
+    P->key_length = 0;
+    P->fanout = 1;
+    P->depth = 1;
+    store32(&P->leaf_length, 0);
+    store32(&P->node_offset, 0);
+    store16(&P->xof_length, 0);
+    P->node_depth = 0;
+    P->inner_length = 0;
+    /* memset(P->reserved, 0, sizeof(P->reserved) ); */
+    memset(P->salt, 0, sizeof(P->salt));
+    memset(P->personal, 0, sizeof(P->personal));
+    return blake2s_init_param(S, P);
+}
+
+int blake2s_init_key(blake2s_state *S, size_t outlen, const void *key, size_t keylen)
+{
+    blake2s_param P[1];
+
+    if ((!outlen) || (outlen > BLAKE2S_OUTBYTES))
+        return -1;
+
+    if (!key || !keylen || keylen > BLAKE2S_KEYBYTES)
+        return -1;
+
+    P->digest_length = (uint8_t)outlen;
+    P->key_length = (uint8_t)keylen;
+    P->fanout = 1;
+    P->depth = 1;
+    store32(&P->leaf_length, 0);
+    store32(&P->node_offset, 0);
+    store16(&P->xof_length, 0);
+    P->node_depth = 0;
+    P->inner_length = 0;
+    /* memset(P->reserved, 0, sizeof(P->reserved) ); */
+    memset(P->salt, 0, sizeof(P->salt));
+    memset(P->personal, 0, sizeof(P->personal));
+
+    if (blake2s_init_param(S, P) < 0)
+        return -1;
+
+    {
+        uint8_t block[BLAKE2S_BLOCKBYTES];
+        memset(block, 0, BLAKE2S_BLOCKBYTES);
+        memcpy(block, key, keylen);
+        blake2s_update(S, block, BLAKE2S_BLOCKBYTES);
+        secure_zero_memory(block, BLAKE2S_BLOCKBYTES); /* Burn the key from stack */
+    }
+    return 0;
+}
+
+#define G(r, i, a, b, c, d)                         \
+    do                                              \
+    {                                               \
+        a = a + b + m[blake2s_sigma[r][2 * i + 0]]; \
+        d = rotr32(d ^ a, 16);                      \
+        c = c + d;                                  \
+        b = rotr32(b ^ c, 12);                      \
+        a = a + b + m[blake2s_sigma[r][2 * i + 1]]; \
+        d = rotr32(d ^ a, 8);                       \
+        c = c + d;                                  \
+        b = rotr32(b ^ c, 7);                       \
+    } while (0)
+
+#define ROUND(r)                           \
+    do                                     \
+    {                                      \
+        G(r, 0, v[0], v[4], v[8], v[12]);  \
+        G(r, 1, v[1], v[5], v[9], v[13]);  \
+        G(r, 2, v[2], v[6], v[10], v[14]); \
+        G(r, 3, v[3], v[7], v[11], v[15]); \
+        G(r, 4, v[0], v[5], v[10], v[15]); \
+        G(r, 5, v[1], v[6], v[11], v[12]); \
+        G(r, 6, v[2], v[7], v[8], v[13]);  \
+        G(r, 7, v[3], v[4], v[9], v[14]);  \
+    } while (0)
+
+static void blake2s_compress(blake2s_state *S, const uint8_t in[BLAKE2S_BLOCKBYTES])
+{
+    uint32_t m[16];
+    uint32_t v[16];
+    size_t i;
+
+    for (i = 0; i < 16; ++i)
+    {
+        m[i] = load32(in + i * sizeof(m[i]));
+    }
+
+    for (i = 0; i < 8; ++i)
+    {
+        v[i] = S->h[i];
+    }
+
+    v[8] = blake2s_IV[0];
+    v[9] = blake2s_IV[1];
+    v[10] = blake2s_IV[2];
+    v[11] = blake2s_IV[3];
+    v[12] = S->t[0] ^ blake2s_IV[4];
+    v[13] = S->t[1] ^ blake2s_IV[5];
+    v[14] = S->f[0] ^ blake2s_IV[6];
+    v[15] = S->f[1] ^ blake2s_IV[7];
+
+    ROUND(0);
+    ROUND(1);
+    ROUND(2);
+    ROUND(3);
+    ROUND(4);
+    ROUND(5);
+    ROUND(6);
+    ROUND(7);
+    ROUND(8);
+    ROUND(9);
+
+    for (i = 0; i < 8; ++i)
+    {
+        S->h[i] = S->h[i] ^ v[i] ^ v[i + 8];
+    }
+}
+
+#undef G
+#undef ROUND
+
+int blake2s_update(blake2s_state *S, const void *pin, size_t inlen)
+{
+    const unsigned char *in = (const unsigned char *)pin;
+    if (inlen > 0)
+    {
+        size_t left = S->buflen;
+        size_t fill = BLAKE2S_BLOCKBYTES - left;
+        if (inlen > fill)
+        {
+            S->buflen = 0;
+            memcpy(S->buf + left, in, fill); /* Fill buffer */
+            blake2s_increment_counter(S, BLAKE2S_BLOCKBYTES);
+            blake2s_compress(S, S->buf); /* Compress */
+            in += fill;
+            inlen -= fill;
+            while (inlen > BLAKE2S_BLOCKBYTES)
+            {
+                blake2s_increment_counter(S, BLAKE2S_BLOCKBYTES);
+                blake2s_compress(S, in);
+                in += BLAKE2S_BLOCKBYTES;
+                inlen -= BLAKE2S_BLOCKBYTES;
+            }
+        }
+        memcpy(S->buf + S->buflen, in, inlen);
+        S->buflen += inlen;
+    }
+    return 0;
+}
+
+int blake2s_final(blake2s_state *S, void *out, size_t outlen)
+{
+    uint8_t buffer[BLAKE2S_OUTBYTES] = {0};
+    size_t i;
+
+    if (out == NULL || outlen < S->outlen)
+        return -1;
+
+    if (blake2s_is_lastblock(S))
+        return -1;
+
+    blake2s_increment_counter(S, (uint32_t)S->buflen);
+    blake2s_set_lastblock(S);
+    memset(S->buf + S->buflen, 0, BLAKE2S_BLOCKBYTES - S->buflen); /* Padding */
+    blake2s_compress(S, S->buf);
+
+    for (i = 0; i < 8; ++i) /* Output full hash to temp buffer */
+        store32(buffer + sizeof(S->h[i]) * i, S->h[i]);
+
+    memcpy(out, buffer, outlen);
+    secure_zero_memory(buffer, sizeof(buffer));
+    return 0;
+}
+
+int blake2s(void *out, size_t outlen, const void *in, size_t inlen, const void *key, size_t keylen)
+{
+    blake2s_state S[1];
+
+    /* Verify parameters */
+    if (NULL == in && inlen > 0)
+        return -1;
+
+    if (NULL == out)
+        return -1;
+
+    if (NULL == key && keylen > 0)
+        return -1;
+
+    if (!outlen || outlen > BLAKE2S_OUTBYTES)
+        return -1;
+
+    if (keylen > BLAKE2S_KEYBYTES)
+        return -1;
+
+    if (keylen > 0)
+    {
+        if (blake2s_init_key(S, outlen, key, keylen) < 0)
+            return -1;
+    }
+    else
+    {
+        if (blake2s_init(S, outlen) < 0)
+            return -1;
+    }
+
+    blake2s_update(S, (const uint8_t *)in, inlen);
+    blake2s_final(S, out, outlen);
+    return 0;
+}
+
+#if defined(SUPERCOP)
+int crypto_hash(unsigned char *out, unsigned char *in, unsigned long long inlen)
+{
+    return blake2s(out, BLAKE2S_OUTBYTES, in, inlen, NULL, 0);
+}
+#endif
+
+#if defined(BLAKE2S_SELFTEST)
+#include <string.h>
+#include "blake2-kat.h"
+int main(void)
+{
+    uint8_t key[BLAKE2S_KEYBYTES];
+    uint8_t buf[BLAKE2_KAT_LENGTH];
+    size_t i, step;
+
+    for (i = 0; i < BLAKE2S_KEYBYTES; ++i)
+        key[i] = (uint8_t)i;
+
+    for (i = 0; i < BLAKE2_KAT_LENGTH; ++i)
+        buf[i] = (uint8_t)i;
+
+    /* Test simple API */
+    for (i = 0; i < BLAKE2_KAT_LENGTH; ++i)
+    {
+        uint8_t hash[BLAKE2S_OUTBYTES];
+        blake2s(hash, BLAKE2S_OUTBYTES, buf, i, key, BLAKE2S_KEYBYTES);
+
+        if (0 != memcmp(hash, blake2s_keyed_kat[i], BLAKE2S_OUTBYTES))
+        {
+            goto fail;
+        }
+    }
+
+    /* Test streaming API */
+    for (step = 1; step < BLAKE2S_BLOCKBYTES; ++step)
+    {
+        for (i = 0; i < BLAKE2_KAT_LENGTH; ++i)
+        {
+            uint8_t hash[BLAKE2S_OUTBYTES];
+            blake2s_state S;
+            uint8_t *p = buf;
+            size_t mlen = i;
+            int err = 0;
+
+            if ((err = blake2s_init_key(&S, BLAKE2S_OUTBYTES, key, BLAKE2S_KEYBYTES)) < 0)
+            {
+                goto fail;
+            }
+
+            while (mlen >= step)
+            {
+                if ((err = blake2s_update(&S, p, step)) < 0)
+                {
+                    goto fail;
+                }
+                mlen -= step;
+                p += step;
+            }
+            if ((err = blake2s_update(&S, p, mlen)) < 0)
+            {
+                goto fail;
+            }
+            if ((err = blake2s_final(&S, hash, BLAKE2S_OUTBYTES)) < 0)
+            {
+                goto fail;
+            }
+
+            if (0 != memcmp(hash, blake2s_keyed_kat[i], BLAKE2S_OUTBYTES))
+            {
+                goto fail;
+            }
+        }
+    }
+
+    puts("ok");
+    return 0;
+fail:
+    puts("error");
+    return -1;
+}
+#endif
\ No newline at end of file
diff --git a/nimble/host/src/blake3.c b/nimble/host/src/blake3.c
new file mode 100644
index 00000000..82515614
--- /dev/null
+++ b/nimble/host/src/blake3.c
@@ -0,0 +1,180 @@
+#include <stdint.h>
+#include <string.h>
+#include "blake3.h"
+
+#define CHUNK_START (1u << 0)
+#define CHUNK_END (1u << 1)
+#define PARENT (1u << 2)
+#define ROOT (1u << 3)
+
+static const uint32_t iv[] = {
+    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
+    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,
+};
+
+static void
+compress(uint32_t* out, const uint32_t m[static 16], const uint32_t h[static 8],
+         uint64_t t, uint32_t b, uint32_t d)
+{
+    static const unsigned char s[][16] = {
+        {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15},
+        {2, 6, 3, 10, 7, 0, 4, 13, 1, 11, 12, 5, 9, 14, 15, 8},
+        {3, 4, 10, 12, 13, 2, 7, 14, 6, 5, 9, 0, 11, 15, 8, 1},
+        {10, 7, 12, 9, 14, 3, 13, 15, 4, 0, 11, 2, 5, 8, 1, 6},
+        {12, 13, 9, 11, 15, 10, 14, 8, 7, 2, 5, 3, 0, 1, 6, 4},
+        {9, 14, 11, 5, 8, 12, 15, 1, 13, 3, 0, 10, 2, 6, 4, 7},
+        {11, 15, 5, 0, 1, 9, 8, 6, 14, 10, 2, 12, 3, 4, 7, 13},
+    };
+    uint32_t v[16] = {
+        h[0],  h[1],  h[2],  h[3],  h[4], h[5],    h[6], h[7],
+        iv[0], iv[1], iv[2], iv[3], t,    t >> 32, b,    d,
+    };
+    unsigned i;
+
+#define G(i, j, a, b, c, d)                                                    \
+    a = a + b + m[s[i][j * 2]];                                                \
+    d = d ^ a;                                                                 \
+    d = d >> 16 | d << 16;                                                     \
+    c = c + d;                                                                 \
+    b = b ^ c;                                                                 \
+    b = b >> 12 | b << 20;                                                     \
+    a = a + b + m[s[i][j * 2 + 1]];                                            \
+    d = d ^ a;                                                                 \
+    d = d >> 8 | d << 24;                                                      \
+    c = c + d;                                                                 \
+    b = b ^ c;                                                                 \
+    b = b >> 7 | b << 25;
+
+#define ROUND(i)                                                               \
+    G(i, 0, v[0], v[4], v[8], v[12])                                           \
+    G(i, 1, v[1], v[5], v[9], v[13])                                           \
+    G(i, 2, v[2], v[6], v[10], v[14])                                          \
+    G(i, 3, v[3], v[7], v[11], v[15])                                          \
+    G(i, 4, v[0], v[5], v[10], v[15])                                          \
+    G(i, 5, v[1], v[6], v[11], v[12])                                          \
+    G(i, 6, v[2], v[7], v[8], v[13])                                           \
+    G(i, 7, v[3], v[4], v[9], v[14])
+
+    ROUND(0)
+    ROUND(1)
+    ROUND(2) ROUND(3) ROUND(4) ROUND(5) ROUND(6)
+
+#undef G
+#undef ROUND
+
+        if (d & ROOT)
+    {
+        for (i = 8; i < 16; ++i)
+            out[i] = v[i] ^ h[i - 8];
+    }
+    for (i = 0; i < 8; ++i)
+        out[i] = v[i] ^ v[i + 8];
+}
+
+static void
+load(uint32_t d[static 16], const unsigned char s[static 64])
+{
+    uint32_t* end;
+
+    for (end = d + 16; d < end; ++d, s += 4) {
+        *d = (uint32_t)s[0] | (uint32_t)s[1] << 8 | (uint32_t)s[2] << 16 |
+             (uint32_t)s[3] << 24;
+    }
+}
+
+static void
+block(struct blake3* ctx, const unsigned char* buf)
+{
+    uint32_t m[16], flags, *cv = ctx->cv;
+    uint64_t t;
+
+    flags = 0;
+    switch (ctx->block) {
+    case 0:
+        flags |= CHUNK_START;
+        break;
+    case 15:
+        flags |= CHUNK_END;
+        break;
+    }
+    load(m, buf);
+    compress(cv, m, cv, ctx->chunk, 64, flags);
+    if (++ctx->block == 16) {
+        ctx->block = 0;
+        for (t = ++ctx->chunk; (t & 1) == 0; t >>= 1) {
+            cv -= 8;
+            compress(cv, cv, iv, 0, 64, PARENT);
+        }
+        cv += 8;
+        memcpy(cv, iv, sizeof(iv));
+    }
+    ctx->cv = cv;
+}
+
+void
+blake3_init(struct blake3* ctx)
+{
+    ctx->bytes = 0;
+    ctx->block = 0;
+    ctx->chunk = 0;
+    ctx->cv = ctx->cv_buf;
+    memcpy(ctx->cv, iv, sizeof(iv));
+}
+
+void
+blake3_update(struct blake3* ctx, const void* buf, size_t len)
+{
+    const unsigned char* pos = buf;
+    size_t n;
+
+    if (ctx->bytes) {
+        n = 64 - ctx->bytes;
+        if (len < n)
+            n = len;
+        memcpy(ctx->input + ctx->bytes, pos, n);
+        pos += n, len -= n;
+        ctx->bytes += n;
+        if (!len)
+            return;
+        block(ctx, ctx->input);
+    }
+    for (; len > 64; pos += 64, len -= 64)
+        block(ctx, pos);
+    ctx->bytes = len;
+    memcpy(ctx->input, pos, len);
+}
+
+void
+blake3_out(struct blake3* ctx, unsigned char* restrict out, size_t len)
+{
+    uint32_t flags, b, x, *in, *cv, m[16], root[16];
+    size_t i;
+
+    cv = ctx->cv;
+    memset(ctx->input + ctx->bytes, 0, 64 - ctx->bytes);
+    load(m, ctx->input);
+    flags = CHUNK_END;
+    if (ctx->block == 0)
+        flags |= CHUNK_START;
+    if (cv == ctx->cv_buf) {
+        b = ctx->bytes;
+        in = m;
+    }
+    else {
+        compress(cv, m, cv, ctx->chunk, ctx->bytes, flags);
+        flags = PARENT;
+        while ((cv -= 8) != ctx->cv_buf)
+            compress(cv, cv, iv, 0, 64, flags);
+        b = 64;
+        in = cv;
+        cv = (uint32_t*)iv;
+    }
+    flags |= ROOT;
+    for (i = 0; i < len; ++i, ++out, x >>= 8) {
+        if ((i & 63) == 0)
+            compress(root, in, cv, i >> 6, b, flags);
+        if ((i & 3) == 0)
+            x = root[i >> 2 & 15];
+        *out = x & 0xff;
+    }
+}
\ No newline at end of file
diff --git a/nimble/host/src/blake3.h b/nimble/host/src/blake3.h
new file mode 100644
index 00000000..cb94aeb1
--- /dev/null
+++ b/nimble/host/src/blake3.h
@@ -0,0 +1,18 @@
+#ifndef BLAKE3_H
+#define BLAKE3_H 1
+
+#include <stdint.h>
+
+struct blake3 {
+	unsigned char input[64];      /* current input bytes */
+	unsigned bytes;               /* bytes in current input block */
+	unsigned block;               /* block index in chunk */
+	uint64_t chunk;               /* chunk index */
+	uint32_t *cv, cv_buf[54 * 8]; /* chain value stack */
+};
+
+void blake3_init(struct blake3 *);
+void blake3_update(struct blake3 *, const void *, size_t);
+void blake3_out(struct blake3 *, unsigned char *restrict, size_t);
+
+#endif
\ No newline at end of file
diff --git a/nimble/host/src/ble_gap.c b/nimble/host/src/ble_gap.c
index 6369b447..dc4bc915 100644
--- a/nimble/host/src/ble_gap.c
+++ b/nimble/host/src/ble_gap.c
@@ -26,6 +26,7 @@
 #include "host/ble_hs_hci.h"
 #include "ble_hs_priv.h"
 #include "ble_gap_priv.h"
+#include "ble_rm.h"
 
 #ifndef min
 #define min(a, b) ((a) < (b) ? (a) : (b))
@@ -42,7 +43,7 @@
 #endif
 
 #undef SET_BIT
-#define SET_BIT(t, n)  (t |= 1UL << (n))
+#define SET_BIT(t, n) (t |= 1UL << (n))
 
 /**
  * GAP - Generic Access Profile.
@@ -87,20 +88,20 @@
  */
 
 /** GAP procedure op codes. */
-#define BLE_GAP_OP_NULL             0
-#define BLE_GAP_OP_M_DISC           1
-#define BLE_GAP_OP_M_CONN           2
-#define BLE_GAP_OP_S_ADV            1
-#define BLE_GAP_OP_S_PERIODIC_ADV   2
-#define BLE_GAP_OP_SYNC             1
+#define BLE_GAP_OP_NULL 0
+#define BLE_GAP_OP_M_DISC 1
+#define BLE_GAP_OP_M_CONN 2
+#define BLE_GAP_OP_S_ADV 1
+#define BLE_GAP_OP_S_PERIODIC_ADV 2
+#define BLE_GAP_OP_SYNC 1
 
 /**
  * If an attempt to cancel an active procedure fails, the attempt is retried
  * at this rate (ms).
  */
-#define BLE_GAP_CANCEL_RETRY_TIMEOUT_MS         100 /* ms */
+#define BLE_GAP_CANCEL_RETRY_TIMEOUT_MS 100 /* ms */
 
-#define BLE_GAP_UPDATE_TIMEOUT_MS               40000 /* ms */
+#define BLE_GAP_UPDATE_TIMEOUT_MS 40000 /* ms */
 
 #if MYNEWT_VAL(BLE_ROLE_CENTRAL)
 static const struct ble_gap_conn_params ble_gap_conn_params_dflt = {
@@ -119,18 +120,19 @@ static const struct ble_gap_conn_params ble_gap_conn_params_dflt = {
  * The state of the in-progress master connection.  If no master connection is
  * currently in progress, then the op field is set to BLE_GAP_OP_NULL.
  */
-struct ble_gap_master_state {
+struct ble_gap_master_state
+{
     uint8_t op;
 
 #if MYNEWT_VAL(BLE_EXT_ADV)
     /* indicates if discovery was started with legacy API */
     uint8_t legacy_discovery;
 #endif
-    uint8_t exp_set:1;
+    uint8_t exp_set : 1;
     ble_npl_time_t exp_os_ticks;
 
-    ble_gap_event_fn *cb;
-    void *cb_arg;
+    ble_gap_event_fn* cb;
+    void* cb_arg;
 
     /**
      * Indicates the type of master procedure that was preempted, or
@@ -139,14 +141,16 @@ struct ble_gap_master_state {
     uint8_t preempted_op;
 
     union {
-        struct {
-            uint8_t using_wl:1;
-            uint8_t our_addr_type:2;
-            uint8_t cancel:1;
+        struct
+        {
+            uint8_t using_wl : 1;
+            uint8_t our_addr_type : 2;
+            uint8_t cancel : 1;
         } conn;
 
-        struct {
-            uint8_t limited:1;
+        struct
+        {
+            uint8_t limited : 1;
         } disc;
     };
 };
@@ -157,12 +161,13 @@ static bssnz_t struct ble_gap_master_state ble_gap_master;
  * The state of the in-progress sync creation. If no sync creation connection is
  * currently in progress, then the op field is set to BLE_GAP_OP_NULL.
  */
-struct ble_gap_sync_state {
+struct ble_gap_sync_state
+{
     uint8_t op;
-    struct ble_hs_periodic_sync *psync;
+    struct ble_hs_periodic_sync* psync;
 
-    ble_gap_event_fn *cb;
-    void *cb_arg;
+    ble_gap_event_fn* cb;
+    void* cb_arg;
 };
 
 static bssnz_t struct ble_gap_sync_state ble_gap_sync;
@@ -172,33 +177,34 @@ static bssnz_t struct ble_gap_sync_state ble_gap_sync;
  * The state of the in-progress slave connection.  If no slave connection is
  * currently in progress, then the op field is set to BLE_GAP_OP_NULL.
  */
-struct ble_gap_slave_state {
+struct ble_gap_slave_state
+{
     uint8_t op;
 
-    unsigned int our_addr_type:2;
-    unsigned int preempted:1;  /** Set to 1 if advertising was preempted. */
-    unsigned int connectable:1;
+    unsigned int our_addr_type : 2;
+    unsigned int preempted : 1; /** Set to 1 if advertising was preempted. */
+    unsigned int connectable : 1;
 
 #if MYNEWT_VAL(BLE_EXT_ADV)
-    unsigned int configured:1; /** If instance is configured */
-    unsigned int scannable:1;
-    unsigned int directed:1;
-    unsigned int high_duty_directed:1;
-    unsigned int legacy_pdu:1;
-    unsigned int rnd_addr_set:1;
+    unsigned int configured : 1; /** If instance is configured */
+    unsigned int scannable : 1;
+    unsigned int directed : 1;
+    unsigned int high_duty_directed : 1;
+    unsigned int legacy_pdu : 1;
+    unsigned int rnd_addr_set : 1;
 #if MYNEWT_VAL(BLE_PERIODIC_ADV)
-    unsigned int periodic_configured:1;
-    uint8_t      periodic_op;
+    unsigned int periodic_configured : 1;
+    uint8_t periodic_op;
 #endif
     uint8_t rnd_addr[6];
 #else
-/* timer is used only with legacy advertising */
-    unsigned int exp_set:1;
+    /* timer is used only with legacy advertising */
+    unsigned int exp_set : 1;
     ble_npl_time_t exp_os_ticks;
 #endif
 
-    ble_gap_event_fn *cb;
-    void *cb_arg;
+    ble_gap_event_fn* cb;
+    void* cb_arg;
 };
 
 static bssnz_t struct ble_gap_slave_state ble_gap_slave[BLE_ADV_INSTANCES];
@@ -209,7 +215,8 @@ static bool ext_adv_legacy_configured = false;
 #endif
 #endif
 
-struct ble_gap_update_entry {
+struct ble_gap_update_entry
+{
     SLIST_ENTRY(ble_gap_update_entry) next;
     struct ble_gap_upd_params params;
     ble_npl_time_t exp_os_ticks;
@@ -217,78 +224,84 @@ struct ble_gap_update_entry {
 };
 SLIST_HEAD(ble_gap_update_entry_list, ble_gap_update_entry);
 
-struct ble_gap_snapshot {
-    struct ble_gap_conn_desc *desc;
-    ble_gap_event_fn *cb;
-    void *cb_arg;
+struct ble_gap_snapshot
+{
+    struct ble_gap_conn_desc* desc;
+    ble_gap_event_fn* cb;
+    void* cb_arg;
 };
 
-static SLIST_HEAD(ble_gap_hook_list, ble_gap_event_listener) ble_gap_event_listener_list;
-static os_membuf_t ble_gap_update_entry_mem[
-                        OS_MEMPOOL_SIZE(MYNEWT_VAL(BLE_GAP_MAX_PENDING_CONN_PARAM_UPDATE),
-                                        sizeof (struct ble_gap_update_entry))];
+static SLIST_HEAD(ble_gap_hook_list,
+                  ble_gap_event_listener) ble_gap_event_listener_list;
+static os_membuf_t ble_gap_update_entry_mem[OS_MEMPOOL_SIZE(
+    MYNEWT_VAL(BLE_GAP_MAX_PENDING_CONN_PARAM_UPDATE),
+    sizeof(struct ble_gap_update_entry))];
 static struct os_mempool ble_gap_update_entry_pool;
 static struct ble_gap_update_entry_list ble_gap_update_entries;
 
-static void ble_gap_update_entry_free(struct ble_gap_update_entry *entry);
+static void
+ble_gap_update_entry_free(struct ble_gap_update_entry* entry);
 
 #if NIMBLE_BLE_CONNECT
-static struct ble_gap_update_entry *
+static struct ble_gap_update_entry*
 ble_gap_update_entry_find(uint16_t conn_handle,
-                          struct ble_gap_update_entry **out_prev);
+                          struct ble_gap_update_entry** out_prev);
 
 static void
-ble_gap_update_l2cap_cb(uint16_t conn_handle, int status, void *arg);
+ble_gap_update_l2cap_cb(uint16_t conn_handle, int status, void* arg);
 #endif
 
-static struct ble_gap_update_entry *
+static struct ble_gap_update_entry*
 ble_gap_update_entry_remove(uint16_t conn_handle);
 
 #if NIMBLE_BLE_ADVERTISE && !MYNEWT_VAL(BLE_EXT_ADV)
-static int ble_gap_adv_enable_tx(int enable);
+static int
+ble_gap_adv_enable_tx(int enable);
 #endif
 
 #if NIMBLE_BLE_CONNECT
-static int ble_gap_conn_cancel_tx(void);
+static int
+ble_gap_conn_cancel_tx(void);
 #endif
 
 #if NIMBLE_BLE_SCAN && !MYNEWT_VAL(BLE_EXT_ADV)
-static int ble_gap_disc_enable_tx(int enable, int filter_duplicates);
+static int
+ble_gap_disc_enable_tx(int enable, int filter_duplicates);
 #endif
 
 STATS_SECT_DECL(ble_gap_stats) ble_gap_stats;
 STATS_NAME_START(ble_gap_stats)
-    STATS_NAME(ble_gap_stats, wl_set)
-    STATS_NAME(ble_gap_stats, wl_set_fail)
-    STATS_NAME(ble_gap_stats, adv_stop)
-    STATS_NAME(ble_gap_stats, adv_stop_fail)
-    STATS_NAME(ble_gap_stats, adv_start)
-    STATS_NAME(ble_gap_stats, adv_start_fail)
-    STATS_NAME(ble_gap_stats, adv_set_data)
-    STATS_NAME(ble_gap_stats, adv_set_data_fail)
-    STATS_NAME(ble_gap_stats, adv_rsp_set_data)
-    STATS_NAME(ble_gap_stats, adv_rsp_set_data_fail)
-    STATS_NAME(ble_gap_stats, discover)
-    STATS_NAME(ble_gap_stats, discover_fail)
-    STATS_NAME(ble_gap_stats, initiate)
-    STATS_NAME(ble_gap_stats, initiate_fail)
-    STATS_NAME(ble_gap_stats, terminate)
-    STATS_NAME(ble_gap_stats, terminate_fail)
-    STATS_NAME(ble_gap_stats, cancel)
-    STATS_NAME(ble_gap_stats, cancel_fail)
-    STATS_NAME(ble_gap_stats, update)
-    STATS_NAME(ble_gap_stats, update_fail)
-    STATS_NAME(ble_gap_stats, connect_mst)
-    STATS_NAME(ble_gap_stats, connect_slv)
-    STATS_NAME(ble_gap_stats, disconnect)
-    STATS_NAME(ble_gap_stats, rx_disconnect)
-    STATS_NAME(ble_gap_stats, rx_update_complete)
-    STATS_NAME(ble_gap_stats, rx_adv_report)
-    STATS_NAME(ble_gap_stats, rx_conn_complete)
-    STATS_NAME(ble_gap_stats, discover_cancel)
-    STATS_NAME(ble_gap_stats, discover_cancel_fail)
-    STATS_NAME(ble_gap_stats, security_initiate)
-    STATS_NAME(ble_gap_stats, security_initiate_fail)
+STATS_NAME(ble_gap_stats, wl_set)
+STATS_NAME(ble_gap_stats, wl_set_fail)
+STATS_NAME(ble_gap_stats, adv_stop)
+STATS_NAME(ble_gap_stats, adv_stop_fail)
+STATS_NAME(ble_gap_stats, adv_start)
+STATS_NAME(ble_gap_stats, adv_start_fail)
+STATS_NAME(ble_gap_stats, adv_set_data)
+STATS_NAME(ble_gap_stats, adv_set_data_fail)
+STATS_NAME(ble_gap_stats, adv_rsp_set_data)
+STATS_NAME(ble_gap_stats, adv_rsp_set_data_fail)
+STATS_NAME(ble_gap_stats, discover)
+STATS_NAME(ble_gap_stats, discover_fail)
+STATS_NAME(ble_gap_stats, initiate)
+STATS_NAME(ble_gap_stats, initiate_fail)
+STATS_NAME(ble_gap_stats, terminate)
+STATS_NAME(ble_gap_stats, terminate_fail)
+STATS_NAME(ble_gap_stats, cancel)
+STATS_NAME(ble_gap_stats, cancel_fail)
+STATS_NAME(ble_gap_stats, update)
+STATS_NAME(ble_gap_stats, update_fail)
+STATS_NAME(ble_gap_stats, connect_mst)
+STATS_NAME(ble_gap_stats, connect_slv)
+STATS_NAME(ble_gap_stats, disconnect)
+STATS_NAME(ble_gap_stats, rx_disconnect)
+STATS_NAME(ble_gap_stats, rx_update_complete)
+STATS_NAME(ble_gap_stats, rx_adv_report)
+STATS_NAME(ble_gap_stats, rx_conn_complete)
+STATS_NAME(ble_gap_stats, discover_cancel)
+STATS_NAME(ble_gap_stats, discover_cancel_fail)
+STATS_NAME(ble_gap_stats, security_initiate)
+STATS_NAME(ble_gap_stats, security_initiate_fail)
 STATS_NAME_END(ble_gap_stats)
 
 /*****************************************************************************
@@ -299,7 +312,7 @@ STATS_NAME_END(ble_gap_stats)
 int
 ble_gap_dbg_update_active(uint16_t conn_handle)
 {
-    const struct ble_gap_update_entry *entry;
+    const struct ble_gap_update_entry* entry;
 
     ble_hs_lock();
     entry = ble_gap_update_entry_find(conn_handle, NULL);
@@ -319,7 +332,8 @@ ble_gap_log_duration(int32_t duration_ms)
 {
     if (duration_ms == BLE_HS_FOREVER) {
         BLE_HS_LOG(INFO, "duration=forever");
-    } else {
+    }
+    else {
         BLE_HS_LOG(INFO, "duration=%dms", duration_ms);
     }
 }
@@ -327,17 +341,18 @@ ble_gap_log_duration(int32_t duration_ms)
 
 #if MYNEWT_VAL(BLE_ROLE_CENTRAL) && !MYNEWT_VAL(BLE_EXT_ADV)
 static void
-ble_gap_log_conn(uint8_t own_addr_type, const ble_addr_t *peer_addr,
-                 const struct ble_gap_conn_params *params)
+ble_gap_log_conn(uint8_t own_addr_type, const ble_addr_t* peer_addr,
+                 const struct ble_gap_conn_params* params)
 {
     if (peer_addr != NULL) {
         BLE_HS_LOG(INFO, "peer_addr_type=%d peer_addr=", peer_addr->type);
         BLE_HS_LOG_ADDR(INFO, peer_addr->val);
     }
 
-    BLE_HS_LOG(INFO, " scan_itvl=%d scan_window=%d itvl_min=%d itvl_max=%d "
-                     "latency=%d supervision_timeout=%d min_ce_len=%d "
-                     "max_ce_len=%d own_addr_type=%d",
+    BLE_HS_LOG(INFO,
+               " scan_itvl=%d scan_window=%d itvl_min=%d itvl_max=%d "
+               "latency=%d supervision_timeout=%d min_ce_len=%d "
+               "max_ce_len=%d own_addr_type=%d",
                params->scan_itvl, params->scan_window, params->itvl_min,
                params->itvl_max, params->latency, params->supervision_timeout,
                params->min_ce_len, params->max_ce_len, own_addr_type);
@@ -347,10 +362,11 @@ ble_gap_log_conn(uint8_t own_addr_type, const ble_addr_t *peer_addr,
 #if NIMBLE_BLE_SCAN && !MYNEWT_VAL(BLE_EXT_ADV)
 static void
 ble_gap_log_disc(uint8_t own_addr_type, int32_t duration_ms,
-                 const struct ble_gap_disc_params *disc_params)
+                 const struct ble_gap_disc_params* disc_params)
 {
-    BLE_HS_LOG(INFO, "own_addr_type=%d filter_policy=%d passive=%d limited=%d "
-                     "filter_duplicates=%d ",
+    BLE_HS_LOG(INFO,
+               "own_addr_type=%d filter_policy=%d passive=%d limited=%d "
+               "filter_duplicates=%d ",
                own_addr_type, disc_params->filter_policy, disc_params->passive,
                disc_params->limited, disc_params->filter_duplicates);
     ble_gap_log_duration(duration_ms);
@@ -360,20 +376,21 @@ ble_gap_log_disc(uint8_t own_addr_type, int32_t duration_ms,
 #if NIMBLE_BLE_CONNECT
 static void
 ble_gap_log_update(uint16_t conn_handle,
-                   const struct ble_gap_upd_params *params)
+                   const struct ble_gap_upd_params* params)
 {
-    BLE_HS_LOG(INFO, "connection parameter update; "
-                     "conn_handle=%d itvl_min=%d itvl_max=%d latency=%d "
-                     "supervision_timeout=%d min_ce_len=%d max_ce_len=%d",
-               conn_handle, params->itvl_min, params->itvl_max,
-               params->latency, params->supervision_timeout,
-               params->min_ce_len, params->max_ce_len);
+    BLE_HS_LOG(INFO,
+               "connection parameter update; "
+               "conn_handle=%d itvl_min=%d itvl_max=%d latency=%d "
+               "supervision_timeout=%d min_ce_len=%d max_ce_len=%d",
+               conn_handle, params->itvl_min, params->itvl_max, params->latency,
+               params->supervision_timeout, params->min_ce_len,
+               params->max_ce_len);
 }
 #endif
 
 #if MYNEWT_VAL(BLE_WHITELIST)
 static void
-ble_gap_log_wl(const ble_addr_t *addr, uint8_t white_list_count)
+ble_gap_log_wl(const ble_addr_t* addr, uint8_t white_list_count)
 {
     int i;
 
@@ -389,21 +406,20 @@ ble_gap_log_wl(const ble_addr_t *addr, uint8_t white_list_count)
 
 #if NIMBLE_BLE_ADVERTISE && !MYNEWT_VAL(BLE_EXT_ADV)
 static void
-ble_gap_log_adv(uint8_t own_addr_type, const ble_addr_t *direct_addr,
-                const struct ble_gap_adv_params *adv_params)
+ble_gap_log_adv(uint8_t own_addr_type, const ble_addr_t* direct_addr,
+                const struct ble_gap_adv_params* adv_params)
 {
     BLE_HS_LOG(INFO, "disc_mode=%d", adv_params->disc_mode);
     if (direct_addr) {
-        BLE_HS_LOG(INFO, " direct_addr_type=%d direct_addr=",
-                   direct_addr->type);
+        BLE_HS_LOG(INFO,
+                   " direct_addr_type=%d direct_addr=", direct_addr->type);
         BLE_HS_LOG_ADDR(INFO, direct_addr->val);
     }
-    BLE_HS_LOG(INFO, " adv_channel_map=%d own_addr_type=%d "
-                     "adv_filter_policy=%d adv_itvl_min=%d adv_itvl_max=%d",
-               adv_params->channel_map,
-               own_addr_type,
-               adv_params->filter_policy,
-               adv_params->itvl_min,
+    BLE_HS_LOG(INFO,
+               " adv_channel_map=%d own_addr_type=%d "
+               "adv_filter_policy=%d adv_itvl_min=%d adv_itvl_max=%d",
+               adv_params->channel_map, own_addr_type,
+               adv_params->filter_policy, adv_params->itvl_min,
                adv_params->itvl_max);
 }
 #endif
@@ -414,8 +430,7 @@ ble_gap_log_adv(uint8_t own_addr_type, const ble_addr_t *direct_addr,
 
 #if NIMBLE_BLE_CONNECT
 static void
-ble_gap_fill_conn_desc(struct ble_hs_conn *conn,
-                       struct ble_gap_conn_desc *desc)
+ble_gap_fill_conn_desc(struct ble_hs_conn* conn, struct ble_gap_conn_desc* desc)
 {
     struct ble_hs_conn_addrs addrs;
 
@@ -435,14 +450,15 @@ ble_gap_fill_conn_desc(struct ble_hs_conn *conn,
 
     if (conn->bhc_flags & BLE_HS_CONN_F_MASTER) {
         desc->role = BLE_GAP_ROLE_MASTER;
-    } else {
+    }
+    else {
         desc->role = BLE_GAP_ROLE_SLAVE;
     }
 }
 
 static void
-ble_gap_conn_to_snapshot(struct ble_hs_conn *conn,
-                         struct ble_gap_snapshot *snap)
+ble_gap_conn_to_snapshot(struct ble_hs_conn* conn,
+                         struct ble_gap_snapshot* snap)
 {
     ble_gap_fill_conn_desc(conn, snap->desc);
     snap->cb = conn->bhc_cb;
@@ -450,9 +466,9 @@ ble_gap_conn_to_snapshot(struct ble_hs_conn *conn,
 }
 
 static int
-ble_gap_find_snapshot(uint16_t handle, struct ble_gap_snapshot *snap)
+ble_gap_find_snapshot(uint16_t handle, struct ble_gap_snapshot* snap)
 {
-    struct ble_hs_conn *conn;
+    struct ble_hs_conn* conn;
 
     ble_hs_lock();
 
@@ -465,17 +481,18 @@ ble_gap_find_snapshot(uint16_t handle, struct ble_gap_snapshot *snap)
 
     if (conn == NULL) {
         return BLE_HS_ENOTCONN;
-    } else {
+    }
+    else {
         return 0;
     }
 }
 #endif
 
 int
-ble_gap_conn_find(uint16_t handle, struct ble_gap_conn_desc *out_desc)
+ble_gap_conn_find(uint16_t handle, struct ble_gap_conn_desc* out_desc)
 {
 #if NIMBLE_BLE_CONNECT
-    struct ble_hs_conn *conn;
+    struct ble_hs_conn* conn;
 
     ble_hs_lock();
 
@@ -488,7 +505,8 @@ ble_gap_conn_find(uint16_t handle, struct ble_gap_conn_desc *out_desc)
 
     if (conn == NULL) {
         return BLE_HS_ENOTCONN;
-    } else {
+    }
+    else {
         return 0;
     }
 #else
@@ -497,11 +515,11 @@ ble_gap_conn_find(uint16_t handle, struct ble_gap_conn_desc *out_desc)
 }
 
 int
-ble_gap_conn_find_by_addr(const ble_addr_t *addr,
-                          struct ble_gap_conn_desc *out_desc)
+ble_gap_conn_find_by_addr(const ble_addr_t* addr,
+                          struct ble_gap_conn_desc* out_desc)
 {
 #if NIMBLE_BLE_CONNECT
-    struct ble_hs_conn *conn;
+    struct ble_hs_conn* conn;
 
     if (!ble_hs_is_enabled()) {
         return BLE_HS_EDISABLED;
@@ -527,17 +545,19 @@ ble_gap_conn_find_by_addr(const ble_addr_t *addr,
 }
 
 int
-ble_gap_conn_find_handle_by_addr(const ble_addr_t *addr, uint16_t *out_conn_handle)
+ble_gap_conn_find_handle_by_addr(const ble_addr_t* addr,
+                                 uint16_t* out_conn_handle)
 {
 #if NIMBLE_BLE_CONNECT
-    struct ble_hs_conn *conn;
+    struct ble_hs_conn* conn;
 
     ble_hs_lock();
 
     conn = ble_hs_conn_find_by_addr(addr);
     if (conn != NULL) {
         *out_conn_handle = conn->bhc_handle;
-    } else {
+    }
+    else {
         *out_conn_handle = BLE_HS_CONN_HANDLE_NONE;
     }
 
@@ -553,21 +573,22 @@ ble_gap_conn_find_handle_by_addr(const ble_addr_t *addr, uint16_t *out_conn_hand
 #endif
 }
 
-struct foreach_handle_cb_arg {
-    ble_gap_conn_foreach_handle_fn *cb;
-    void *arg;
+struct foreach_handle_cb_arg
+{
+    ble_gap_conn_foreach_handle_fn* cb;
+    void* arg;
 };
 
 static int
-ble_gap_conn_foreach_handle_callback(struct ble_hs_conn *conn, void *arg)
+ble_gap_conn_foreach_handle_callback(struct ble_hs_conn* conn, void* arg)
 {
-    struct foreach_handle_cb_arg *cb_arg = (struct foreach_handle_cb_arg *)arg;
+    struct foreach_handle_cb_arg* cb_arg = (struct foreach_handle_cb_arg*)arg;
 
     return cb_arg->cb(conn->bhc_handle, cb_arg->arg);
 }
 
 void
-ble_gap_conn_foreach_handle(ble_gap_conn_foreach_handle_fn *cb, void *arg)
+ble_gap_conn_foreach_handle(ble_gap_conn_foreach_handle_fn* cb, void* arg)
 {
     struct foreach_handle_cb_arg cb_arg = {
         .cb = cb,
@@ -579,10 +600,10 @@ ble_gap_conn_foreach_handle(ble_gap_conn_foreach_handle_fn *cb, void *arg)
 
 #if NIMBLE_BLE_CONNECT
 static int
-ble_gap_extract_conn_cb(uint16_t conn_handle,
-                        ble_gap_event_fn **out_cb, void **out_cb_arg)
+ble_gap_extract_conn_cb(uint16_t conn_handle, ble_gap_event_fn** out_cb,
+                        void** out_cb_arg)
 {
-    const struct ble_hs_conn *conn;
+    const struct ble_hs_conn* conn;
 
     BLE_HS_DBG_ASSERT(conn_handle <= BLE_HCI_LE_CONN_HANDLE_MAX);
 
@@ -592,7 +613,8 @@ ble_gap_extract_conn_cb(uint16_t conn_handle,
     if (conn != NULL) {
         *out_cb = conn->bhc_cb;
         *out_cb_arg = conn->bhc_cb_arg;
-    } else {
+    }
+    else {
         *out_cb = NULL;
         *out_cb_arg = NULL;
     }
@@ -601,14 +623,15 @@ ble_gap_extract_conn_cb(uint16_t conn_handle,
 
     if (conn == NULL) {
         return BLE_HS_ENOTCONN;
-    } else {
+    }
+    else {
         return 0;
     }
 }
 #endif
 
 int
-ble_gap_set_priv_mode(const ble_addr_t *peer_addr, uint8_t priv_mode)
+ble_gap_set_priv_mode(const ble_addr_t* peer_addr, uint8_t priv_mode)
 {
 #if NIMBLE_BLE_CONNECT
     if (!ble_hs_is_enabled()) {
@@ -622,12 +645,12 @@ ble_gap_set_priv_mode(const ble_addr_t *peer_addr, uint8_t priv_mode)
 }
 
 int
-ble_gap_read_le_phy(uint16_t conn_handle, uint8_t *tx_phy, uint8_t *rx_phy)
+ble_gap_read_le_phy(uint16_t conn_handle, uint8_t* tx_phy, uint8_t* rx_phy)
 {
 #if NIMBLE_BLE_CONNECT
     struct ble_hci_le_rd_phy_cp cmd;
     struct ble_hci_le_rd_phy_rp rsp;
-    struct ble_hs_conn *conn;
+    struct ble_hs_conn* conn;
     int rc;
 
     if (!ble_hs_is_enabled()) {
@@ -670,15 +693,15 @@ ble_gap_set_prefered_default_le_phy(uint8_t tx_phys_mask, uint8_t rx_phys_mask)
 #if NIMBLE_BLE_CONNECT
     struct ble_hci_le_set_default_phy_cp cmd;
 
-    if (tx_phys_mask > (BLE_HCI_LE_PHY_1M_PREF_MASK |
-                        BLE_HCI_LE_PHY_2M_PREF_MASK |
-                        BLE_HCI_LE_PHY_CODED_PREF_MASK)) {
+    if (tx_phys_mask >
+        (BLE_HCI_LE_PHY_1M_PREF_MASK | BLE_HCI_LE_PHY_2M_PREF_MASK |
+         BLE_HCI_LE_PHY_CODED_PREF_MASK)) {
         return BLE_ERR_INV_HCI_CMD_PARMS;
     }
 
-    if (rx_phys_mask > (BLE_HCI_LE_PHY_1M_PREF_MASK |
-                        BLE_HCI_LE_PHY_2M_PREF_MASK |
-                        BLE_HCI_LE_PHY_CODED_PREF_MASK)) {
+    if (rx_phys_mask >
+        (BLE_HCI_LE_PHY_1M_PREF_MASK | BLE_HCI_LE_PHY_2M_PREF_MASK |
+         BLE_HCI_LE_PHY_CODED_PREF_MASK)) {
         return BLE_ERR_INV_HCI_CMD_PARMS;
     }
 
@@ -690,19 +713,21 @@ ble_gap_set_prefered_default_le_phy(uint8_t tx_phys_mask, uint8_t rx_phys_mask)
 
     if (tx_phys_mask == 0) {
         cmd.all_phys |= BLE_HCI_LE_PHY_NO_TX_PREF_MASK;
-    } else {
+    }
+    else {
         cmd.tx_phys = tx_phys_mask;
     }
 
     if (rx_phys_mask == 0) {
         cmd.all_phys |= BLE_HCI_LE_PHY_NO_RX_PREF_MASK;
-    } else {
+    }
+    else {
         cmd.rx_phys = rx_phys_mask;
     }
 
-    return ble_hs_hci_cmd_tx(BLE_HCI_OP(BLE_HCI_OGF_LE,
-                                        BLE_HCI_OCF_LE_SET_DEFAULT_PHY),
-                            &cmd, sizeof(cmd), NULL, 0);
+    return ble_hs_hci_cmd_tx(
+        BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_SET_DEFAULT_PHY), &cmd,
+        sizeof(cmd), NULL, 0);
 #else
     return BLE_HS_ENOTSUP;
 #endif
@@ -710,11 +735,11 @@ ble_gap_set_prefered_default_le_phy(uint8_t tx_phys_mask, uint8_t rx_phys_mask)
 
 int
 ble_gap_set_prefered_le_phy(uint16_t conn_handle, uint8_t tx_phys_mask,
-                   uint8_t rx_phys_mask, uint16_t phy_opts)
+                            uint8_t rx_phys_mask, uint16_t phy_opts)
 {
 #if NIMBLE_BLE_CONNECT
     struct ble_hci_le_set_phy_cp cmd;
-    struct ble_hs_conn *conn;
+    struct ble_hs_conn* conn;
 
     if (!ble_hs_is_enabled()) {
         return BLE_HS_EDISABLED;
@@ -728,15 +753,15 @@ ble_gap_set_prefered_le_phy(uint16_t conn_handle, uint8_t tx_phys_mask,
         return BLE_HS_ENOTCONN;
     }
 
-    if (tx_phys_mask > (BLE_HCI_LE_PHY_1M_PREF_MASK |
-                        BLE_HCI_LE_PHY_2M_PREF_MASK |
-                        BLE_HCI_LE_PHY_CODED_PREF_MASK)) {
+    if (tx_phys_mask >
+        (BLE_HCI_LE_PHY_1M_PREF_MASK | BLE_HCI_LE_PHY_2M_PREF_MASK |
+         BLE_HCI_LE_PHY_CODED_PREF_MASK)) {
         return BLE_ERR_INV_HCI_CMD_PARMS;
     }
 
-    if (rx_phys_mask > (BLE_HCI_LE_PHY_1M_PREF_MASK |
-                        BLE_HCI_LE_PHY_2M_PREF_MASK |
-                        BLE_HCI_LE_PHY_CODED_PREF_MASK)) {
+    if (rx_phys_mask >
+        (BLE_HCI_LE_PHY_1M_PREF_MASK | BLE_HCI_LE_PHY_2M_PREF_MASK |
+         BLE_HCI_LE_PHY_CODED_PREF_MASK)) {
         return BLE_ERR_INV_HCI_CMD_PARMS;
     }
 
@@ -749,13 +774,15 @@ ble_gap_set_prefered_le_phy(uint16_t conn_handle, uint8_t tx_phys_mask,
 
     if (tx_phys_mask == 0) {
         cmd.all_phys |= BLE_HCI_LE_PHY_NO_TX_PREF_MASK;
-    } else {
+    }
+    else {
         cmd.tx_phys = tx_phys_mask;
     }
 
     if (rx_phys_mask == 0) {
         cmd.all_phys |= BLE_HCI_LE_PHY_NO_RX_PREF_MASK;
-    } else {
+    }
+    else {
         cmd.rx_phys = rx_phys_mask;
     }
 
@@ -773,11 +800,11 @@ ble_gap_set_prefered_le_phy(uint16_t conn_handle, uint8_t tx_phys_mask,
  *****************************************************************************/
 
 static int
-ble_gap_event_listener_call(struct ble_gap_event *event);
+ble_gap_event_listener_call(struct ble_gap_event* event);
 
 static int
-ble_gap_call_event_cb(struct ble_gap_event *event,
-                      ble_gap_event_fn *cb, void *cb_arg)
+ble_gap_call_event_cb(struct ble_gap_event* event, ble_gap_event_fn* cb,
+                      void* cb_arg)
 {
     int rc;
 
@@ -785,7 +812,8 @@ ble_gap_call_event_cb(struct ble_gap_event *event,
 
     if (cb != NULL) {
         rc = cb(event, cb_arg);
-    } else {
+    }
+    else {
         if (event->type == BLE_GAP_EVENT_CONN_UPDATE_REQ) {
             /* Just copy peer parameters back into the reply. */
             *event->conn_update_req.self_params =
@@ -799,10 +827,10 @@ ble_gap_call_event_cb(struct ble_gap_event *event,
 
 #if NIMBLE_BLE_CONNECT
 static int
-ble_gap_call_conn_event_cb(struct ble_gap_event *event, uint16_t conn_handle)
+ble_gap_call_conn_event_cb(struct ble_gap_event* event, uint16_t conn_handle)
 {
-    ble_gap_event_fn *cb;
-    void *cb_arg;
+    ble_gap_event_fn* cb;
+    void* cb_arg;
     int rc;
 
     rc = ble_gap_extract_conn_cb(conn_handle, &cb, &cb_arg);
@@ -867,9 +895,10 @@ ble_gap_slave_reset_state(uint8_t instance)
 }
 #endif
 
-#if MYNEWT_VAL(BLE_ROLE_CENTRAL) || MYNEWT_VAL(BLE_ROLE_PERIPHERAL) || MYNEWT_VAL(BLE_ROLE_OBSERVER)
+#if MYNEWT_VAL(BLE_ROLE_CENTRAL) || MYNEWT_VAL(BLE_ROLE_PERIPHERAL) ||         \
+    MYNEWT_VAL(BLE_ROLE_OBSERVER)
 static bool
-ble_gap_has_client(struct ble_gap_master_state *out_state)
+ble_gap_has_client(struct ble_gap_master_state* out_state)
 {
     if (!out_state) {
         return 0;
@@ -881,7 +910,7 @@ ble_gap_has_client(struct ble_gap_master_state *out_state)
 
 #if MYNEWT_VAL(BLE_ROLE_OBSERVER) || NIMBLE_BLE_CONNECT
 static void
-ble_gap_master_extract_state(struct ble_gap_master_state *out_state,
+ble_gap_master_extract_state(struct ble_gap_master_state* out_state,
                              int reset_state)
 {
     ble_hs_lock();
@@ -899,8 +928,8 @@ ble_gap_master_extract_state(struct ble_gap_master_state *out_state,
 
 #if NIMBLE_BLE_ADVERTISE || NIMBLE_BLE_CONNECT
 static void
-ble_gap_slave_extract_cb(uint8_t instance,
-                         ble_gap_event_fn **out_cb, void **out_cb_arg)
+ble_gap_slave_extract_cb(uint8_t instance, ble_gap_event_fn** out_cb,
+                         void** out_cb_arg)
 {
     ble_hs_lock();
 
@@ -916,8 +945,8 @@ ble_gap_adv_finished(uint8_t instance, int reason, uint16_t conn_handle,
                      uint8_t num_events)
 {
     struct ble_gap_event event;
-    ble_gap_event_fn *cb;
-    void *cb_arg;
+    ble_gap_event_fn* cb;
+    void* cb_arg;
 
     memset(&event, 0, sizeof event);
     event.type = BLE_GAP_EVENT_ADV_COMPLETE;
@@ -952,7 +981,8 @@ ble_gap_master_connect_failure(int status)
         event.connect.status = status;
 
         rc = state.cb(&event, state.cb_arg);
-    } else {
+    }
+    else {
         rc = 0;
     }
 
@@ -973,7 +1003,8 @@ ble_gap_master_connect_cancelled(void)
         if (state.conn.cancel) {
             /* Connect procedure successfully cancelled. */
             event.connect.status = BLE_HS_EAPP;
-        } else {
+        }
+        else {
             /* Connect procedure timed out. */
             event.connect.status = BLE_HS_ETIMEOUT;
         }
@@ -984,14 +1015,14 @@ ble_gap_master_connect_cancelled(void)
 
 #if NIMBLE_BLE_SCAN
 static void
-ble_gap_disc_report(void *desc)
+ble_gap_disc_report(void* desc)
 {
     struct ble_gap_master_state state;
     struct ble_gap_event event;
 
     memset(&event, 0, sizeof event);
     event.type = BLE_GAP_EVENT_DISC;
-    event.disc = *((struct ble_gap_disc_desc *)desc);
+    event.disc = *((struct ble_gap_disc_desc*)desc);
 
     ble_gap_master_extract_state(&state, 0);
     if (ble_gap_has_client(&state)) {
@@ -1003,9 +1034,9 @@ ble_gap_disc_report(void *desc)
 
 #if MYNEWT_VAL(BLE_EXT_ADV)
 static void
-ble_gap_ext_disc_report(void *desc)
+ble_gap_ext_disc_report(void* desc)
 {
-    struct ble_gap_ext_disc_desc *ext_desc = desc;
+    struct ble_gap_ext_disc_desc* ext_desc = desc;
     struct ble_gap_disc_desc legacy_desc;
     struct ble_gap_master_state state;
     struct ble_gap_event event;
@@ -1028,7 +1059,7 @@ ble_gap_ext_disc_report(void *desc)
 
     memset(&event, 0, sizeof event);
     event.type = BLE_GAP_EVENT_EXT_DISC;
-    event.ext_disc = *((struct ble_gap_ext_disc_desc *)desc);
+    event.ext_disc = *((struct ble_gap_ext_disc_desc*)desc);
 
     ble_gap_master_extract_state(&state, 0);
     if (ble_gap_has_client(&state)) {
@@ -1133,9 +1164,9 @@ ble_gap_slave_ticks_until_exp(void)
  *                                  active update procedures.
  */
 static uint16_t
-ble_gap_update_next_exp(int32_t *out_ticks_from_now)
+ble_gap_update_next_exp(int32_t* out_ticks_from_now)
 {
-    struct ble_gap_update_entry *entry;
+    struct ble_gap_update_entry* entry;
     ble_npl_time_t now;
     uint16_t conn_handle;
     int32_t best_ticks;
@@ -1147,7 +1178,8 @@ ble_gap_update_next_exp(int32_t *out_ticks_from_now)
     best_ticks = BLE_HS_FOREVER;
     now = ble_npl_time_get();
 
-    SLIST_FOREACH(entry, &ble_gap_update_entries, next) {
+    SLIST_FOREACH(entry, &ble_gap_update_entries, next)
+    {
         ticks = entry->exp_os_ticks - now;
         if (ticks <= 0) {
             ticks = 0;
@@ -1164,7 +1196,6 @@ ble_gap_update_next_exp(int32_t *out_ticks_from_now)
     }
 
     return conn_handle;
-
 }
 
 #if NIMBLE_BLE_SCAN
@@ -1224,7 +1255,7 @@ ble_gap_master_failed(int status)
 static void
 ble_gap_update_failed(uint16_t conn_handle, int status)
 {
-    struct ble_gap_update_entry *entry;
+    struct ble_gap_update_entry* entry;
 
     STATS_INC(ble_gap_stats, update_fail);
 
@@ -1242,7 +1273,7 @@ static void
 ble_gap_conn_broken(uint16_t conn_handle, int reason)
 {
 #if NIMBLE_BLE_CONNECT
-    struct ble_gap_update_entry *entry;
+    struct ble_gap_update_entry* entry;
     struct ble_gap_snapshot snap;
     struct ble_gap_event event;
     int rc;
@@ -1276,7 +1307,8 @@ ble_gap_conn_broken(uint16_t conn_handle, int reason)
     ble_sm_connection_broken(conn_handle);
     ble_gatts_connection_broken(conn_handle);
     ble_gattc_connection_broken(conn_handle);
-    ble_hs_flow_connection_broken(conn_handle);;
+    ble_hs_flow_connection_broken(conn_handle);
+    ;
 
     ble_hs_atomic_conn_delete(conn_handle);
 
@@ -1292,8 +1324,8 @@ ble_gap_conn_broken(uint16_t conn_handle, int reason)
 
 #if NIMBLE_BLE_CONNECT
 static void
-ble_gap_update_to_l2cap(const struct ble_gap_upd_params *params,
-                        struct ble_l2cap_sig_update_params *l2cap_params)
+ble_gap_update_to_l2cap(const struct ble_gap_upd_params* params,
+                        struct ble_l2cap_sig_update_params* l2cap_params)
 {
     l2cap_params->itvl_min = params->itvl_min;
     l2cap_params->itvl_max = params->itvl_max;
@@ -1303,7 +1335,7 @@ ble_gap_update_to_l2cap(const struct ble_gap_upd_params *params,
 #endif
 
 void
-ble_gap_rx_disconn_complete(const struct ble_hci_ev_disconn_cmp *ev)
+ble_gap_rx_disconn_complete(const struct ble_hci_ev_disconn_cmp* ev)
 {
 #if NIMBLE_BLE_CONNECT
     struct ble_gap_event event;
@@ -1313,7 +1345,8 @@ ble_gap_rx_disconn_complete(const struct ble_hci_ev_disconn_cmp *ev)
 
     if (ev->status == 0) {
         ble_gap_conn_broken(handle, BLE_HS_HCI_ERR(ev->reason));
-    } else {
+    }
+    else {
         memset(&event, 0, sizeof event);
         event.type = BLE_GAP_EVENT_TERM_FAILURE;
         event.term_failure.conn_handle = handle;
@@ -1326,13 +1359,14 @@ ble_gap_rx_disconn_complete(const struct ble_hci_ev_disconn_cmp *ev)
 }
 
 void
-ble_gap_rx_update_complete(const struct ble_hci_ev_le_subev_conn_upd_complete *ev)
+ble_gap_rx_update_complete(
+    const struct ble_hci_ev_le_subev_conn_upd_complete* ev)
 {
 #if NIMBLE_BLE_CONNECT
-    struct ble_gap_update_entry *entry;
+    struct ble_gap_update_entry* entry;
     struct ble_l2cap_sig_update_params l2cap_params;
     struct ble_gap_event event;
-    struct ble_hs_conn *conn;
+    struct ble_hs_conn* conn;
     uint16_t conn_handle;
     int cb_status;
     int call_cb;
@@ -1366,8 +1400,9 @@ ble_gap_rx_update_complete(const struct ble_hci_ev_le_subev_conn_upd_complete *e
             entry = ble_gap_update_entry_find(conn_handle, NULL);
             if (entry != NULL && !(conn->bhc_flags & BLE_HS_CONN_F_MASTER)) {
                 ble_gap_update_to_l2cap(&entry->params, &l2cap_params);
-                entry->exp_os_ticks = ble_npl_time_get() +
-                                      ble_npl_time_ms_to_ticks32(BLE_GAP_UPDATE_TIMEOUT_MS);
+                entry->exp_os_ticks =
+                    ble_npl_time_get() +
+                    ble_npl_time_ms_to_ticks32(BLE_GAP_UPDATE_TIMEOUT_MS);
             }
             break;
 
@@ -1389,11 +1424,13 @@ ble_gap_rx_update_complete(const struct ble_hci_ev_le_subev_conn_upd_complete *e
                                   ble_gap_update_l2cap_cb, NULL);
         if (rc == 0) {
             call_cb = 0;
-        } else {
+        }
+        else {
             call_cb = 1;
             cb_status = rc;
         }
-    } else {
+    }
+    else {
         call_cb = 1;
         cb_status = BLE_HS_HCI_ERR(ev->status);
     }
@@ -1427,7 +1464,8 @@ ble_gap_adv_active_instance(uint8_t instance)
 #endif
 
 #if MYNEWT_VAL(BLE_EXT_ADV)
-int ble_gap_ext_adv_active(uint8_t instance)
+int
+ble_gap_ext_adv_active(uint8_t instance)
 {
     if (instance >= BLE_ADV_INSTANCES) {
         return 0;
@@ -1436,7 +1474,7 @@ int ble_gap_ext_adv_active(uint8_t instance)
 }
 
 int
-ble_gap_adv_get_free_instance(uint8_t *out_adv_instance)
+ble_gap_adv_get_free_instance(uint8_t* out_adv_instance)
 {
     uint8_t i;
 
@@ -1528,13 +1566,16 @@ ble_gap_accept_slave_conn(uint8_t instance)
     int rc;
 
     if (instance >= BLE_ADV_INSTANCES) {
-       rc = BLE_HS_ENOENT;
-    } else if (!ble_gap_adv_active_instance(instance)) {
         rc = BLE_HS_ENOENT;
-    } else {
+    }
+    else if (!ble_gap_adv_active_instance(instance)) {
+        rc = BLE_HS_ENOENT;
+    }
+    else {
         if (ble_gap_slave[instance].connectable) {
             rc = 0;
-        } else {
+        }
+        else {
             rc = BLE_HS_ENOENT;
         }
     }
@@ -1549,9 +1590,10 @@ ble_gap_accept_slave_conn(uint8_t instance)
 
 #if NIMBLE_BLE_SCAN
 static int
-ble_gap_rx_adv_report_sanity_check(const uint8_t *adv_data, uint8_t adv_data_len)
+ble_gap_rx_adv_report_sanity_check(const uint8_t* adv_data,
+                                   uint8_t adv_data_len)
 {
-    const struct ble_hs_adv_field *flags;
+    const struct ble_hs_adv_field* flags;
     int rc;
 
     STATS_INC(ble_gap_stats, rx_adv_report);
@@ -1577,7 +1619,7 @@ ble_gap_rx_adv_report_sanity_check(const uint8_t *adv_data, uint8_t adv_data_len
 #endif
 
 void
-ble_gap_rx_adv_report(struct ble_gap_disc_desc *desc)
+ble_gap_rx_adv_report(struct ble_gap_disc_desc* desc)
 {
 #if NIMBLE_BLE_SCAN
     if (ble_gap_rx_adv_report_sanity_check(desc->data, desc->length_data)) {
@@ -1597,7 +1639,7 @@ ble_gap_rx_le_scan_timeout(void)
 }
 
 void
-ble_gap_rx_ext_adv_report(struct ble_gap_ext_disc_desc *desc)
+ble_gap_rx_ext_adv_report(struct ble_gap_ext_disc_desc* desc)
 {
     if (ble_gap_rx_adv_report_sanity_check(desc->data, desc->length_data)) {
         return;
@@ -1608,7 +1650,8 @@ ble_gap_rx_ext_adv_report(struct ble_gap_ext_disc_desc *desc)
 #endif
 
 void
-ble_gap_rx_adv_set_terminated(const struct ble_hci_ev_le_subev_adv_set_terminated *ev)
+ble_gap_rx_adv_set_terminated(
+    const struct ble_hci_ev_le_subev_adv_set_terminated* ev)
 {
     uint16_t conn_handle;
     int reason;
@@ -1618,7 +1661,8 @@ ble_gap_rx_adv_set_terminated(const struct ble_hci_ev_le_subev_adv_set_terminate
     if (ev->status) {
         reason = BLE_HS_ETIMEOUT;
         conn_handle = 0;
-    } else {
+    }
+    else {
         reason = 0;
         conn_handle = le16toh(ev->conn_handle);
     }
@@ -1627,8 +1671,8 @@ ble_gap_rx_adv_set_terminated(const struct ble_hci_ev_le_subev_adv_set_terminate
 }
 
 static void
-ble_gap_slave_get_cb(uint8_t instance,
-                     ble_gap_event_fn **out_cb, void **out_cb_arg)
+ble_gap_slave_get_cb(uint8_t instance, ble_gap_event_fn** out_cb,
+                     void** out_cb_arg)
 {
     ble_hs_lock();
 
@@ -1639,11 +1683,11 @@ ble_gap_slave_get_cb(uint8_t instance,
 }
 
 void
-ble_gap_rx_scan_req_rcvd(const struct ble_hci_ev_le_subev_scan_req_rcvd *ev)
+ble_gap_rx_scan_req_rcvd(const struct ble_hci_ev_le_subev_scan_req_rcvd* ev)
 {
     struct ble_gap_event event;
-    ble_gap_event_fn *cb;
-    void *cb_arg;
+    ble_gap_event_fn* cb;
+    void* cb_arg;
 
     ble_gap_slave_get_cb(ev->adv_handle, &cb, &cb_arg);
     if (cb != NULL) {
@@ -1651,7 +1695,8 @@ ble_gap_rx_scan_req_rcvd(const struct ble_hci_ev_le_subev_scan_req_rcvd *ev)
         event.type = BLE_GAP_EVENT_SCAN_REQ_RCVD;
         event.scan_req_rcvd.instance = ev->adv_handle;
         event.scan_req_rcvd.scan_addr.type = ev->peer_addr_type;
-        memcpy(event.scan_req_rcvd.scan_addr.val, ev->peer_addr, BLE_DEV_ADDR_LEN);
+        memcpy(event.scan_req_rcvd.scan_addr.val, ev->peer_addr,
+               BLE_DEV_ADDR_LEN);
         cb(&event, cb_arg);
     }
 }
@@ -1661,12 +1706,13 @@ ble_gap_rx_scan_req_rcvd(const struct ble_hci_ev_le_subev_scan_req_rcvd *ev)
 #if MYNEWT_VAL(BLE_PERIODIC_ADV)
 
 void
-ble_gap_rx_peroidic_adv_sync_estab(const struct ble_hci_ev_le_subev_periodic_adv_sync_estab *ev)
+ble_gap_rx_peroidic_adv_sync_estab(
+    const struct ble_hci_ev_le_subev_periodic_adv_sync_estab* ev)
 {
     uint16_t sync_handle;
     struct ble_gap_event event;
-    ble_gap_event_fn *cb;
-    void *cb_arg;
+    ble_gap_event_fn* cb;
+    void* cb_arg;
 
     memset(&event, 0, sizeof event);
 
@@ -1696,7 +1742,8 @@ ble_gap_rx_peroidic_adv_sync_estab(const struct ble_hci_ev_le_subev_periodic_adv
         event.periodic_sync.adv_clk_accuracy = ev->aca;
 
         ble_hs_periodic_sync_insert(ble_gap_sync.psync);
-    } else {
+    }
+    else {
         ble_hs_periodic_sync_free(ble_gap_sync.psync);
     }
 
@@ -1717,12 +1764,13 @@ ble_gap_rx_peroidic_adv_sync_estab(const struct ble_hci_ev_le_subev_periodic_adv
 }
 
 void
-ble_gap_rx_periodic_adv_rpt(const struct ble_hci_ev_le_subev_periodic_adv_rpt *ev)
+ble_gap_rx_periodic_adv_rpt(
+    const struct ble_hci_ev_le_subev_periodic_adv_rpt* ev)
 {
-    struct ble_hs_periodic_sync *psync;
+    struct ble_hs_periodic_sync* psync;
     struct ble_gap_event event;
-    ble_gap_event_fn *cb;
-    void *cb_arg;
+    ble_gap_event_fn* cb;
+    void* cb_arg;
 
     ble_hs_lock();
     psync = ble_hs_periodic_sync_find_by_handle(le16toh(ev->sync_handle));
@@ -1749,16 +1797,17 @@ ble_gap_rx_periodic_adv_rpt(const struct ble_hci_ev_le_subev_periodic_adv_rpt *e
     /* TODO should we allow for listener too? this can be spammy and is more
      * like ACL data, not general event
      */
-     cb(&event, cb_arg);
+    cb(&event, cb_arg);
 }
 
 void
-ble_gap_rx_periodic_adv_sync_lost(const struct ble_hci_ev_le_subev_periodic_adv_sync_lost *ev)
+ble_gap_rx_periodic_adv_sync_lost(
+    const struct ble_hci_ev_le_subev_periodic_adv_sync_lost* ev)
 {
-    struct ble_hs_periodic_sync *psync;
+    struct ble_hs_periodic_sync* psync;
     struct ble_gap_event event;
-    ble_gap_event_fn *cb;
-    void *cb_arg;
+    ble_gap_event_fn* cb;
+    void* cb_arg;
 
     ble_hs_lock();
     /* The handle must be in the list */
@@ -1793,7 +1842,8 @@ ble_gap_rx_periodic_adv_sync_lost(const struct ble_hci_ev_le_subev_periodic_adv_
 
 #if MYNEWT_VAL(BLE_POWER_CONTROL)
 void
-ble_gap_rx_le_pathloss_threshold(const struct ble_hci_ev_le_subev_path_loss_threshold *ev)
+ble_gap_rx_le_pathloss_threshold(
+    const struct ble_hci_ev_le_subev_path_loss_threshold* ev)
 {
     struct ble_gap_event event;
     uint16_t conn_handle = le16toh(ev->conn_handle);
@@ -1810,7 +1860,8 @@ ble_gap_rx_le_pathloss_threshold(const struct ble_hci_ev_le_subev_path_loss_thre
 }
 
 void
-ble_gap_rx_transmit_power_report(const struct ble_hci_ev_le_subev_transmit_power_report *ev)
+ble_gap_rx_transmit_power_report(
+    const struct ble_hci_ev_le_subev_transmit_power_report* ev)
 {
     struct ble_gap_event event;
     uint16_t conn_handle = le16toh(ev->conn_handle);
@@ -1823,7 +1874,8 @@ ble_gap_rx_transmit_power_report(const struct ble_hci_ev_le_subev_transmit_power
     event.transmit_power.reason = ev->reason;
     event.transmit_power.phy = ev->phy;
     event.transmit_power.transmit_power_level = ev->transmit_power_level;
-    event.transmit_power.transmit_power_level_flag = ev->transmit_power_level_flag;
+    event.transmit_power.transmit_power_level_flag =
+        ev->transmit_power_level_flag;
     event.transmit_power.delta = ev->delta;
 
     ble_gap_event_listener_call(&event);
@@ -1840,7 +1892,8 @@ periodic_adv_transfer_disable(uint16_t conn_handle)
     uint16_t opcode;
     int rc;
 
-    opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_PERIODIC_ADV_SYNC_TRANSFER_PARAMS);
+    opcode = BLE_HCI_OP(BLE_HCI_OGF_LE,
+                        BLE_HCI_OCF_LE_PERIODIC_ADV_SYNC_TRANSFER_PARAMS);
 
     cmd.conn_handle = htole16(conn_handle);
     cmd.sync_cte_type = 0x00;
@@ -1857,16 +1910,17 @@ periodic_adv_transfer_disable(uint16_t conn_handle)
 }
 
 void
-ble_gap_rx_periodic_adv_sync_transfer(const struct ble_hci_ev_le_subev_periodic_adv_sync_transfer *ev)
+ble_gap_rx_periodic_adv_sync_transfer(
+    const struct ble_hci_ev_le_subev_periodic_adv_sync_transfer* ev)
 {
     struct ble_hci_le_periodic_adv_term_sync_cp cmd_term;
     struct ble_gap_event event;
-    struct ble_hs_conn *conn;
-    ble_gap_event_fn *cb;
+    struct ble_hs_conn* conn;
+    ble_gap_event_fn* cb;
     uint16_t sync_handle;
     uint16_t conn_handle;
     uint16_t opcode;
-    void *cb_arg;
+    void* cb_arg;
 
     conn_handle = le16toh(ev->conn_handle);
 
@@ -1882,7 +1936,8 @@ ble_gap_rx_periodic_adv_sync_transfer(const struct ble_hci_ev_le_subev_periodic_
     if (!conn || !conn->psync) {
         /* terminate sync if we didn't expect it */
         if (!ev->status) {
-            opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_PERIODIC_ADV_TERM_SYNC);
+            opcode = BLE_HCI_OP(BLE_HCI_OGF_LE,
+                                BLE_HCI_OCF_LE_PERIODIC_ADV_TERM_SYNC);
             cmd_term.sync_handle = ev->sync_handle;
             ble_hs_hci_cmd_tx(opcode, &cmd_term, sizeof(cmd_term), NULL, 0);
         }
@@ -1903,7 +1958,8 @@ ble_gap_rx_periodic_adv_sync_transfer(const struct ble_hci_ev_le_subev_periodic_
     if (ev->status) {
         sync_handle = 0;
         ble_hs_periodic_sync_free(conn->psync);
-    } else {
+    }
+    else {
         sync_handle = le16toh(ev->sync_handle);
 
         conn->psync->sync_handle = sync_handle;
@@ -1934,12 +1990,13 @@ ble_gap_rx_periodic_adv_sync_transfer(const struct ble_hci_ev_le_subev_periodic_
 
 #if MYNEWT_VAL(BLE_PERIODIC_ADV_SYNC_BIGINFO_REPORTS)
 void
-ble_gap_rx_biginfo_adv_rpt(const struct ble_hci_ev_le_subev_biginfo_adv_report *ev)
+ble_gap_rx_biginfo_adv_rpt(
+    const struct ble_hci_ev_le_subev_biginfo_adv_report* ev)
 {
-    struct ble_hs_periodic_sync *psync;
+    struct ble_hs_periodic_sync* psync;
     struct ble_gap_event event;
-    ble_gap_event_fn *cb;
-    void *cb_arg;
+    ble_gap_event_fn* cb;
+    void* cb_arg;
 
     cb = NULL;
     cb_arg = NULL;
@@ -1978,7 +2035,7 @@ ble_gap_rx_biginfo_adv_rpt(const struct ble_hci_ev_le_subev_biginfo_adv_report *
 
 #if MYNEWT_VAL(BLE_CONN_SUBRATING)
 void
-ble_gap_rx_subrate_change(const struct ble_hci_ev_le_subev_subrate_change *ev)
+ble_gap_rx_subrate_change(const struct ble_hci_ev_le_subev_subrate_change* ev)
 {
     struct ble_gap_event event;
 
@@ -2004,9 +2061,9 @@ ble_gap_rd_rem_sup_feat_tx(uint16_t handle)
 
     cmd.conn_handle = htole16(handle);
 
-    return ble_hs_hci_cmd_tx(BLE_HCI_OP(BLE_HCI_OGF_LE,
-                                        BLE_HCI_OCF_LE_RD_REM_FEAT),
-                             &cmd, sizeof(cmd), NULL, 0);
+    return ble_hs_hci_cmd_tx(
+        BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_RD_REM_FEAT), &cmd,
+        sizeof(cmd), NULL, 0);
 }
 #endif
 
@@ -2015,11 +2072,11 @@ ble_gap_rd_rem_sup_feat_tx(uint16_t handle)
  * instance parameter is valid only for slave connection.
  */
 int
-ble_gap_rx_conn_complete(struct ble_gap_conn_complete *evt, uint8_t instance)
+ble_gap_rx_conn_complete(struct ble_gap_conn_complete* evt, uint8_t instance)
 {
 #if NIMBLE_BLE_CONNECT
     struct ble_gap_event event;
-    struct ble_hs_conn *conn;
+    struct ble_hs_conn* conn;
     int rc;
 
     STATS_INC(ble_gap_stats, rx_conn_complete);
@@ -2046,15 +2103,18 @@ ble_gap_rx_conn_complete(struct ble_gap_conn_complete *evt, uint8_t instance)
                 /* Connect procedure successfully cancelled. */
                 if (ble_gap_master.preempted_op == BLE_GAP_OP_M_CONN) {
                     ble_gap_master_failed(BLE_HS_EPREEMPTED);
-                } else {
+                }
+                else {
                     ble_gap_master_connect_cancelled();
                 }
             }
             break;
         default:
             /* this should never happen, unless controller is broken */
-            BLE_HS_LOG(INFO, "controller reported invalid error code in conn"
-                             "complete event: %u", evt->status);
+            BLE_HS_LOG(INFO,
+                       "controller reported invalid error code in conn"
+                       "complete event: %u",
+                       evt->status);
             assert(0);
             break;
         }
@@ -2103,7 +2163,8 @@ ble_gap_rx_conn_complete(struct ble_gap_conn_complete *evt, uint8_t instance)
         conn->bhc_flags |= BLE_HS_CONN_F_MASTER;
         conn->bhc_our_addr_type = ble_gap_master.conn.our_addr_type;
         ble_gap_master_reset_state();
-    } else {
+    }
+    else {
         conn->bhc_cb = ble_gap_slave[instance].cb;
         conn->bhc_cb_arg = ble_gap_slave[instance].cb_arg;
         conn->bhc_our_addr_type = ble_gap_slave[instance].our_addr_type;
@@ -2127,7 +2188,8 @@ ble_gap_rx_conn_complete(struct ble_gap_conn_complete *evt, uint8_t instance)
         if (BLE_ADDR_IS_RPA(&conn->bhc_peer_addr)) {
             conn->bhc_peer_rpa_addr = conn->bhc_peer_addr;
         }
-    } else {
+    }
+    else {
         conn->bhc_peer_rpa_addr.type = BLE_ADDR_RANDOM;
         memcpy(conn->bhc_peer_rpa_addr.val, evt->peer_rpa, 6);
     }
@@ -2155,10 +2217,11 @@ ble_gap_rx_conn_complete(struct ble_gap_conn_complete *evt, uint8_t instance)
 }
 
 void
-ble_gap_rx_rd_rem_sup_feat_complete(const struct ble_hci_ev_le_subev_rd_rem_used_feat *ev)
+ble_gap_rx_rd_rem_sup_feat_complete(
+    const struct ble_hci_ev_le_subev_rd_rem_used_feat* ev)
 {
 #if NIMBLE_BLE_CONNECT
-    struct ble_hs_conn *conn;
+    struct ble_hs_conn* conn;
 
     ble_hs_lock();
 
@@ -2173,7 +2236,7 @@ ble_gap_rx_rd_rem_sup_feat_complete(const struct ble_hci_ev_le_subev_rd_rem_used
 
 int
 ble_gap_rx_l2cap_update_req(uint16_t conn_handle,
-                            struct ble_gap_upd_params *params)
+                            struct ble_gap_upd_params* params)
 {
 #if NIMBLE_BLE_CONNECT
     struct ble_gap_upd_params peer_params;
@@ -2196,7 +2259,8 @@ ble_gap_rx_l2cap_update_req(uint16_t conn_handle,
 }
 
 void
-ble_gap_rx_phy_update_complete(const struct ble_hci_ev_le_subev_phy_update_complete *ev)
+ble_gap_rx_phy_update_complete(
+    const struct ble_hci_ev_le_subev_phy_update_complete* ev)
 {
 #if NIMBLE_BLE_CONNECT
     struct ble_gap_event event;
@@ -2237,7 +2301,8 @@ ble_gap_master_timer(void)
         if (rc != 0) {
             /* Failed to stop connecting; try again in 100 ms. */
             return ble_npl_time_ms_to_ticks32(BLE_GAP_CANCEL_RETRY_TIMEOUT_MS);
-        } else {
+        }
+        else {
             /* Stop the timer now that the cancel command has been acked. */
             ble_gap_master.exp_set = 0;
 
@@ -2309,7 +2374,7 @@ ble_gap_slave_timer(void)
 static int32_t
 ble_gap_update_timer(void)
 {
-    struct ble_gap_update_entry *entry;
+    struct ble_gap_update_entry* entry;
     int32_t ticks_until_exp;
     uint16_t conn_handle;
 
@@ -2319,7 +2384,8 @@ ble_gap_update_timer(void)
         conn_handle = ble_gap_update_next_exp(&ticks_until_exp);
         if (ticks_until_exp == 0) {
             entry = ble_gap_update_entry_remove(conn_handle);
-        } else {
+        }
+        else {
             entry = NULL;
         }
 
@@ -2334,10 +2400,10 @@ ble_gap_update_timer(void)
 }
 
 int
-ble_gap_set_event_cb(uint16_t conn_handle, ble_gap_event_fn *cb, void *cb_arg)
+ble_gap_set_event_cb(uint16_t conn_handle, ble_gap_event_fn* cb, void* cb_arg)
 {
 #if NIMBLE_BLE_CONNECT
-    struct ble_hs_conn *conn;
+    struct ble_hs_conn* conn;
 
     ble_hs_lock();
 
@@ -2400,7 +2466,7 @@ ble_gap_wl_busy(void)
 }
 
 static int
-ble_gap_wl_tx_add(const ble_addr_t *addr)
+ble_gap_wl_tx_add(const ble_addr_t* addr)
 {
     struct ble_hci_le_add_whte_list_cp cmd;
 
@@ -2411,28 +2477,28 @@ ble_gap_wl_tx_add(const ble_addr_t *addr)
     memcpy(cmd.addr, addr->val, BLE_DEV_ADDR_LEN);
     cmd.addr_type = addr->type;
 
-    return ble_hs_hci_cmd_tx(BLE_HCI_OP(BLE_HCI_OGF_LE,
-                                        BLE_HCI_OCF_LE_ADD_WHITE_LIST),
-                             &cmd, sizeof(cmd), NULL, 0);
+    return ble_hs_hci_cmd_tx(
+        BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_ADD_WHITE_LIST), &cmd,
+        sizeof(cmd), NULL, 0);
 }
 
 static int
 ble_gap_wl_tx_clear(void)
 {
-    return ble_hs_hci_cmd_tx(BLE_HCI_OP(BLE_HCI_OGF_LE,
-                                        BLE_HCI_OCF_LE_CLEAR_WHITE_LIST),
-                             NULL, 0, NULL, 0 );
+    return ble_hs_hci_cmd_tx(
+        BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_CLEAR_WHITE_LIST), NULL, 0,
+        NULL, 0);
 }
 
 int
-ble_gap_wl_read_size(uint8_t *size)
+ble_gap_wl_read_size(uint8_t* size)
 {
     struct ble_hci_le_rd_white_list_rp rsp;
     int rc;
 
-    rc = ble_hs_hci_cmd_tx(BLE_HCI_OP(BLE_HCI_OGF_LE,
-                                      BLE_HCI_OCF_LE_RD_WHITE_LIST_SIZE),
-                           NULL, 0, &rsp, sizeof(rsp));
+    rc = ble_hs_hci_cmd_tx(
+        BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_RD_WHITE_LIST_SIZE), NULL, 0,
+        &rsp, sizeof(rsp));
 
     if (rc == 0) {
         *size = rsp.size;
@@ -2443,7 +2509,7 @@ ble_gap_wl_read_size(uint8_t *size)
 #endif
 
 int
-ble_gap_wl_set(const ble_addr_t *addrs, uint8_t white_list_count)
+ble_gap_wl_set(const ble_addr_t* addrs, uint8_t white_list_count)
 {
 #if MYNEWT_VAL(BLE_WHITELIST)
     int rc;
@@ -2512,9 +2578,9 @@ ble_gap_adv_enable_tx(int enable)
 
     cmd.enable = !!enable;
 
-    return ble_hs_hci_cmd_tx(BLE_HCI_OP(BLE_HCI_OGF_LE,
-                                        BLE_HCI_OCF_LE_SET_ADV_ENABLE),
-                             &cmd, sizeof(cmd), NULL, 0);
+    return ble_hs_hci_cmd_tx(
+        BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_SET_ADV_ENABLE), &cmd,
+        sizeof(cmd), NULL, 0);
 }
 
 static int
@@ -2540,7 +2606,8 @@ ble_gap_adv_stop_no_lock(void)
 
     if (!active) {
         rc = BLE_HS_EALREADY;
-    } else {
+    }
+    else {
         rc = 0;
     }
 
@@ -2595,13 +2662,14 @@ ble_gap_adv_stop(void)
  *****************************************************************************/
 #if NIMBLE_BLE_ADVERTISE && !MYNEWT_VAL(BLE_EXT_ADV)
 static int
-ble_gap_adv_type(const struct ble_gap_adv_params *adv_params)
+ble_gap_adv_type(const struct ble_gap_adv_params* adv_params)
 {
     switch (adv_params->conn_mode) {
     case BLE_GAP_CONN_MODE_NON:
         if (adv_params->disc_mode == BLE_GAP_DISC_MODE_NON) {
             return BLE_HCI_ADV_TYPE_ADV_NONCONN_IND;
-        } else {
+        }
+        else {
             return BLE_HCI_ADV_TYPE_ADV_SCAN_IND;
         }
 
@@ -2611,7 +2679,8 @@ ble_gap_adv_type(const struct ble_gap_adv_params *adv_params)
     case BLE_GAP_CONN_MODE_DIR:
         if (adv_params->high_duty_cycle) {
             return BLE_HCI_ADV_TYPE_ADV_DIRECT_IND_HD;
-        } else {
+        }
+        else {
             return BLE_HCI_ADV_TYPE_ADV_DIRECT_IND_LD;
         }
 
@@ -2622,8 +2691,8 @@ ble_gap_adv_type(const struct ble_gap_adv_params *adv_params)
 }
 
 static void
-ble_gap_adv_dflt_itvls(uint8_t conn_mode,
-                       uint16_t *out_itvl_min, uint16_t *out_itvl_max)
+ble_gap_adv_dflt_itvls(uint8_t conn_mode, uint16_t* out_itvl_min,
+                       uint16_t* out_itvl_max)
 {
     switch (conn_mode) {
     case BLE_GAP_CONN_MODE_NON:
@@ -2650,11 +2719,11 @@ ble_gap_adv_dflt_itvls(uint8_t conn_mode,
 }
 
 static int
-ble_gap_adv_params_tx(uint8_t own_addr_type, const ble_addr_t *peer_addr,
-                      const struct ble_gap_adv_params *adv_params)
+ble_gap_adv_params_tx(uint8_t own_addr_type, const ble_addr_t* peer_addr,
+                      const struct ble_gap_adv_params* adv_params)
 
 {
-    const ble_addr_t *peer_any = BLE_ADDR_ANY;
+    const ble_addr_t* peer_any = BLE_ADDR_ANY;
     struct ble_hci_le_set_adv_params_cp cmd;
     uint16_t opcode;
     uint16_t min;
@@ -2665,7 +2734,8 @@ ble_gap_adv_params_tx(uint8_t own_addr_type, const ble_addr_t *peer_addr,
         ble_gap_adv_dflt_itvls(adv_params->conn_mode, &min, &max);
         cmd.min_interval = htole16(min);
         cmd.max_interval = htole16(max);
-    } else {
+    }
+    else {
         cmd.min_interval = htole16(adv_params->itvl_min);
         cmd.max_interval = htole16(adv_params->itvl_max);
     }
@@ -2682,7 +2752,8 @@ ble_gap_adv_params_tx(uint8_t own_addr_type, const ble_addr_t *peer_addr,
 
     if (adv_params->channel_map == 0) {
         cmd.chan_map = BLE_GAP_ADV_DFLT_CHANNEL_MAP;
-    } else {
+    }
+    else {
         cmd.chan_map = adv_params->channel_map;
     }
 
@@ -2695,8 +2766,8 @@ ble_gap_adv_params_tx(uint8_t own_addr_type, const ble_addr_t *peer_addr,
 }
 
 static int
-ble_gap_adv_validate(uint8_t own_addr_type, const ble_addr_t *peer_addr,
-                     const struct ble_gap_adv_params *adv_params)
+ble_gap_adv_validate(uint8_t own_addr_type, const ble_addr_t* peer_addr,
+                     const struct ble_gap_adv_params* adv_params)
 {
     if (adv_params == NULL) {
         return BLE_HS_EINVAL;
@@ -2766,10 +2837,10 @@ ble_gap_adv_validate(uint8_t own_addr_type, const ble_addr_t *peer_addr,
 #endif
 
 int
-ble_gap_adv_start(uint8_t own_addr_type, const ble_addr_t *direct_addr,
+ble_gap_adv_start(uint8_t own_addr_type, const ble_addr_t* direct_addr,
                   int32_t duration_ms,
-                  const struct ble_gap_adv_params *adv_params,
-                  ble_gap_event_fn *cb, void *cb_arg)
+                  const struct ble_gap_adv_params* adv_params,
+                  ble_gap_event_fn* cb, void* cb_arg)
 {
 #if NIMBLE_BLE_ADVERTISE
 #if MYNEWT_VAL(BLE_EXT_ADV)
@@ -2834,11 +2905,13 @@ ble_gap_adv_start(uint8_t own_addr_type, const ble_addr_t *direct_addr,
 
     if (duration_ms == BLE_HS_FOREVER) {
         duration = 0;
-    } else {
+    }
+    else {
         duration = duration_ms / 10;
     }
 
-    return ble_gap_ext_adv_start(MYNEWT_VAL(BLE_HS_EXT_ADV_LEGACY_INSTANCE), duration, 0);
+    return ble_gap_ext_adv_start(MYNEWT_VAL(BLE_HS_EXT_ADV_LEGACY_INSTANCE),
+                                 duration, 0);
 #else
     uint32_t duration_ticks;
     int rc;
@@ -2885,7 +2958,8 @@ ble_gap_adv_start(uint8_t own_addr_type, const ble_addr_t *direct_addr,
 
     if (adv_params->conn_mode != BLE_GAP_CONN_MODE_NON) {
         ble_gap_slave[0].connectable = 1;
-    } else {
+    }
+    else {
         ble_gap_slave[0].connectable = 0;
     }
 
@@ -2956,11 +3030,11 @@ ble_gap_ext_adv_legacy_preconfigure(void)
 #endif
 
 int
-ble_gap_adv_set_data(const uint8_t *data, int data_len)
+ble_gap_adv_set_data(const uint8_t* data, int data_len)
 {
 #if NIMBLE_BLE_ADVERTISE
 #if MYNEWT_VAL(BLE_EXT_ADV)
-    struct os_mbuf *mbuf;
+    struct os_mbuf* mbuf;
     int rc;
 
     if (((data == NULL) && (data_len != 0)) ||
@@ -2984,7 +3058,8 @@ ble_gap_adv_set_data(const uint8_t *data, int data_len)
         return BLE_HS_ENOMEM;
     }
 
-    return ble_gap_ext_adv_set_data(MYNEWT_VAL(BLE_HS_EXT_ADV_LEGACY_INSTANCE), mbuf);
+    return ble_gap_ext_adv_set_data(MYNEWT_VAL(BLE_HS_EXT_ADV_LEGACY_INSTANCE),
+                                    mbuf);
 #else
     struct ble_hci_le_set_adv_data_cp cmd;
     uint16_t opcode;
@@ -2997,7 +3072,7 @@ ble_gap_adv_set_data(const uint8_t *data, int data_len)
 
     /* Check for valid parameters */
     if (((data == NULL) && (data_len != 0)) ||
-            (data_len > BLE_HCI_MAX_ADV_DATA_LEN)) {
+        (data_len > BLE_HCI_MAX_ADV_DATA_LEN)) {
         return BLE_HS_EINVAL;
     }
 
@@ -3014,11 +3089,11 @@ ble_gap_adv_set_data(const uint8_t *data, int data_len)
 }
 
 int
-ble_gap_adv_rsp_set_data(const uint8_t *data, int data_len)
+ble_gap_adv_rsp_set_data(const uint8_t* data, int data_len)
 {
 #if NIMBLE_BLE_ADVERTISE
 #if MYNEWT_VAL(BLE_EXT_ADV)
-    struct os_mbuf *mbuf;
+    struct os_mbuf* mbuf;
     int rc;
 
     if (((data == NULL) && (data_len != 0)) ||
@@ -3042,7 +3117,8 @@ ble_gap_adv_rsp_set_data(const uint8_t *data, int data_len)
         return BLE_HS_ENOMEM;
     }
 
-    return ble_gap_ext_adv_rsp_set_data(MYNEWT_VAL(BLE_HS_EXT_ADV_LEGACY_INSTANCE), mbuf);
+    return ble_gap_ext_adv_rsp_set_data(
+        MYNEWT_VAL(BLE_HS_EXT_ADV_LEGACY_INSTANCE), mbuf);
 #else
     struct ble_hci_le_set_scan_rsp_data_cp cmd;
     uint16_t opcode;
@@ -3053,7 +3129,7 @@ ble_gap_adv_rsp_set_data(const uint8_t *data, int data_len)
 
     /* Check for valid parameters */
     if (((data == NULL) && (data_len != 0)) ||
-            (data_len > BLE_HCI_MAX_SCAN_RSP_DATA_LEN)) {
+        (data_len > BLE_HCI_MAX_SCAN_RSP_DATA_LEN)) {
         return BLE_HS_EINVAL;
     }
 
@@ -3070,7 +3146,7 @@ ble_gap_adv_rsp_set_data(const uint8_t *data, int data_len)
 }
 
 int
-ble_gap_adv_set_fields(const struct ble_hs_adv_fields *adv_fields)
+ble_gap_adv_set_fields(const struct ble_hs_adv_fields* adv_fields)
 {
 #if NIMBLE_BLE_ADVERTISE
     uint8_t buf[BLE_HS_ADV_MAX_SZ];
@@ -3098,7 +3174,7 @@ ble_gap_adv_set_fields(const struct ble_hs_adv_fields *adv_fields)
 }
 
 int
-ble_gap_adv_rsp_set_fields(const struct ble_hs_adv_fields *rsp_fields)
+ble_gap_adv_rsp_set_fields(const struct ble_hs_adv_fields* rsp_fields)
 {
 #if NIMBLE_BLE_ADVERTISE
     uint8_t buf[BLE_HS_ADV_MAX_SZ];
@@ -3125,7 +3201,8 @@ int
 ble_gap_adv_active(void)
 {
 #if NIMBLE_BLE_ADVERTISE
-    return ble_gap_adv_active_instance(MYNEWT_VAL(BLE_HS_EXT_ADV_LEGACY_INSTANCE));
+    return ble_gap_adv_active_instance(
+        MYNEWT_VAL(BLE_HS_EXT_ADV_LEGACY_INSTANCE));
 #else
     return 0;
 #endif
@@ -3133,9 +3210,10 @@ ble_gap_adv_active(void)
 
 #if MYNEWT_VAL(BLE_EXT_ADV)
 static int
-ble_gap_set_ext_adv_params(struct ble_hci_le_set_ext_adv_params_cp *cmd,
-                           uint8_t instance, const struct ble_gap_ext_adv_params *params,
-                           int8_t *selected_tx_power)
+ble_gap_set_ext_adv_params(struct ble_hci_le_set_ext_adv_params_cp* cmd,
+                           uint8_t instance,
+                           const struct ble_gap_ext_adv_params* params,
+                           int8_t* selected_tx_power)
 {
     cmd->adv_handle = instance;
 
@@ -3165,14 +3243,14 @@ ble_gap_set_ext_adv_params(struct ble_hci_le_set_ext_adv_params_cp *cmd,
         /* check right away if the applied configuration is valid before handing
          * the command to the controller to improve error reporting */
         switch (cmd->props) {
-            case BLE_HCI_LE_SET_EXT_ADV_PROP_LEGACY_IND:
-            case BLE_HCI_LE_SET_EXT_ADV_PROP_LEGACY_LD_DIR:
-            case BLE_HCI_LE_SET_EXT_ADV_PROP_LEGACY_HD_DIR:
-            case BLE_HCI_LE_SET_EXT_ADV_PROP_LEGACY_SCAN:
-            case BLE_HCI_LE_SET_EXT_ADV_PROP_LEGACY_NONCONN:
-                break;
-            default:
-                return BLE_HS_EINVAL;
+        case BLE_HCI_LE_SET_EXT_ADV_PROP_LEGACY_IND:
+        case BLE_HCI_LE_SET_EXT_ADV_PROP_LEGACY_LD_DIR:
+        case BLE_HCI_LE_SET_EXT_ADV_PROP_LEGACY_HD_DIR:
+        case BLE_HCI_LE_SET_EXT_ADV_PROP_LEGACY_SCAN:
+        case BLE_HCI_LE_SET_EXT_ADV_PROP_LEGACY_NONCONN:
+            break;
+        default:
+            return BLE_HS_EINVAL;
         }
     }
 
@@ -3181,14 +3259,16 @@ ble_gap_set_ext_adv_params(struct ble_hci_le_set_ext_adv_params_cp *cmd,
         /* TODO for now limited to legacy values*/
         put_le24(cmd->pri_itvl_min, BLE_GAP_ADV_FAST_INTERVAL1_MIN);
         put_le24(cmd->pri_itvl_max, BLE_GAP_ADV_FAST_INTERVAL2_MAX);
-    } else {
+    }
+    else {
         put_le24(cmd->pri_itvl_min, params->itvl_min);
         put_le24(cmd->pri_itvl_max, params->itvl_max);
     }
 
     if (params->channel_map == 0) {
         cmd->pri_chan_map = BLE_GAP_ADV_DFLT_CHANNEL_MAP;
-    } else {
+    }
+    else {
         cmd->pri_chan_map = params->channel_map;
     }
 
@@ -3199,7 +3279,8 @@ ble_gap_set_ext_adv_params(struct ble_hci_le_set_ext_adv_params_cp *cmd,
     if (params->legacy_pdu) {
         cmd->pri_phy = BLE_HCI_LE_PHY_1M;
         cmd->sec_phy = BLE_HCI_LE_PHY_1M;
-    } else {
+    }
+    else {
         cmd->pri_phy = params->primary_phy;
         cmd->sec_phy = params->secondary_phy;
     }
@@ -3214,8 +3295,8 @@ ble_gap_set_ext_adv_params(struct ble_hci_le_set_ext_adv_params_cp *cmd,
 
 static int
 ble_gap_ext_adv_params_tx_v1(uint8_t instance,
-                             const struct ble_gap_ext_adv_params *params,
-                             int8_t *selected_tx_power)
+                             const struct ble_gap_ext_adv_params* params,
+                             int8_t* selected_tx_power)
 {
     struct ble_hci_le_set_ext_adv_params_cp cmd;
     struct ble_hci_le_set_ext_adv_params_rp rsp;
@@ -3229,9 +3310,9 @@ ble_gap_ext_adv_params_tx_v1(uint8_t instance,
         return rc;
     }
 
-    rc = ble_hs_hci_cmd_tx(BLE_HCI_OP(BLE_HCI_OGF_LE,
-                           BLE_HCI_OCF_LE_SET_EXT_ADV_PARAM),
-                           &cmd, sizeof(cmd), &rsp, sizeof(rsp));
+    rc = ble_hs_hci_cmd_tx(
+        BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_SET_EXT_ADV_PARAM), &cmd,
+        sizeof(cmd), &rsp, sizeof(rsp));
 
     if (rc != 0) {
         return rc;
@@ -3242,13 +3323,12 @@ ble_gap_ext_adv_params_tx_v1(uint8_t instance,
     }
 
     return 0;
-
 }
 
 static int
 ble_gap_ext_adv_params_tx_v2(uint8_t instance,
-                             const struct ble_gap_ext_adv_params *params,
-                             int8_t *selected_tx_power)
+                             const struct ble_gap_ext_adv_params* params,
+                             int8_t* selected_tx_power)
 {
 
     struct ble_hci_le_set_ext_adv_params_v2_cp cmd;
@@ -3257,7 +3337,8 @@ ble_gap_ext_adv_params_tx_v2(uint8_t instance,
 
     memset(&cmd, 0, sizeof(cmd));
 
-    rc = ble_gap_set_ext_adv_params(&(cmd.params_v1), instance, params, selected_tx_power);
+    rc = ble_gap_set_ext_adv_params(&(cmd.params_v1), instance, params,
+                                    selected_tx_power);
 
     if (rc != 0) {
         return rc;
@@ -3266,9 +3347,9 @@ ble_gap_ext_adv_params_tx_v2(uint8_t instance,
     cmd.pri_phy_opt = params->primary_phy_opt;
     cmd.sec_phy_opt = params->secondary_phy_opt;
 
-    rc = ble_hs_hci_cmd_tx(BLE_HCI_OP(BLE_HCI_OGF_LE,
-                                  BLE_HCI_OCF_LE_SET_EXT_ADV_PARAM_V2),
-                           &cmd, sizeof(cmd), &rsp, sizeof(rsp));
+    rc = ble_hs_hci_cmd_tx(
+        BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_SET_EXT_ADV_PARAM_V2), &cmd,
+        sizeof(cmd), &rsp, sizeof(rsp));
 
     if (rc != 0) {
         return rc;
@@ -3283,8 +3364,8 @@ ble_gap_ext_adv_params_tx_v2(uint8_t instance,
 
 static int
 ble_gap_ext_adv_params_tx(uint8_t instance,
-                          const struct ble_gap_ext_adv_params *params,
-                          int8_t *selected_tx_power)
+                          const struct ble_gap_ext_adv_params* params,
+                          int8_t* selected_tx_power)
 {
     struct ble_hs_hci_sup_cmd sup_cmd;
     int rc = 0;
@@ -3308,7 +3389,7 @@ ble_gap_ext_adv_params_tx(uint8_t instance,
 }
 
 static int
-ble_gap_ext_adv_params_validate(const struct ble_gap_ext_adv_params *params)
+ble_gap_ext_adv_params_validate(const struct ble_gap_ext_adv_params* params)
 {
     if (!params) {
         return BLE_HS_EINVAL;
@@ -3355,9 +3436,9 @@ ble_gap_ext_adv_params_validate(const struct ble_gap_ext_adv_params *params)
 
 int
 ble_gap_ext_adv_configure(uint8_t instance,
-                          const struct ble_gap_ext_adv_params *params,
-                          int8_t *selected_tx_power,
-                          ble_gap_event_fn *cb, void *cb_arg)
+                          const struct ble_gap_ext_adv_params* params,
+                          int8_t* selected_tx_power, ble_gap_event_fn* cb,
+                          void* cb_arg)
 {
     int rc;
 
@@ -3403,7 +3484,7 @@ ble_gap_ext_adv_configure(uint8_t instance,
 }
 
 static int
-ble_gap_ext_adv_set_addr_no_lock(uint8_t instance, const uint8_t *addr)
+ble_gap_ext_adv_set_addr_no_lock(uint8_t instance, const uint8_t* addr)
 {
     struct ble_hci_le_set_adv_set_rnd_addr_cp cmd;
     int rc;
@@ -3411,9 +3492,9 @@ ble_gap_ext_adv_set_addr_no_lock(uint8_t instance, const uint8_t *addr)
     cmd.adv_handle = instance;
     memcpy(cmd.addr, addr, BLE_DEV_ADDR_LEN);
 
-    rc = ble_hs_hci_cmd_tx(BLE_HCI_OP(BLE_HCI_OGF_LE,
-                                      BLE_HCI_OCF_LE_SET_ADV_SET_RND_ADDR),
-                           &cmd, sizeof(cmd), NULL, 0);
+    rc = ble_hs_hci_cmd_tx(
+        BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_SET_ADV_SET_RND_ADDR), &cmd,
+        sizeof(cmd), NULL, 0);
     if (rc != 0) {
         return rc;
     }
@@ -3425,7 +3506,7 @@ ble_gap_ext_adv_set_addr_no_lock(uint8_t instance, const uint8_t *addr)
 }
 
 int
-ble_gap_ext_adv_set_addr(uint8_t instance, const ble_addr_t *addr)
+ble_gap_ext_adv_set_addr(uint8_t instance, const ble_addr_t* addr)
 {
     int rc;
 
@@ -3447,9 +3528,9 @@ ble_gap_ext_adv_set_addr(uint8_t instance, const ble_addr_t *addr)
 int
 ble_gap_ext_adv_start(uint8_t instance, int duration, int max_events)
 {
-    struct ble_hci_le_set_ext_adv_enable_cp *cmd;
+    struct ble_hci_le_set_ext_adv_enable_cp* cmd;
     uint8_t buf[sizeof(*cmd) + sizeof(cmd->sets[0])];
-    const uint8_t *rnd_addr;
+    const uint8_t* rnd_addr;
     uint16_t opcode;
     int rc;
 
@@ -3469,12 +3550,12 @@ ble_gap_ext_adv_start(uint8_t instance, int duration, int max_events)
 
     if (ble_gap_slave[instance].op != BLE_GAP_OP_NULL) {
         ble_hs_unlock();
-        return  BLE_HS_EALREADY;
+        return BLE_HS_EALREADY;
     }
 
     /* HD directed duration shall not be 0 or larger than >1.28s */
     if (ble_gap_slave[instance].high_duty_directed &&
-            ((duration == 0) || (duration > 128)) ) {
+        ((duration == 0) || (duration > 128))) {
         ble_hs_unlock();
         return BLE_HS_EINVAL;
     }
@@ -3526,7 +3607,7 @@ ble_gap_ext_adv_start(uint8_t instance, int duration, int max_events)
 
     opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_SET_EXT_ADV_ENABLE);
 
-    cmd = (void *) buf;
+    cmd = (void*)buf;
 
     cmd->enable = 0x01;
     cmd->num_sets = 1;
@@ -3550,7 +3631,7 @@ ble_gap_ext_adv_start(uint8_t instance, int duration, int max_events)
 static int
 ble_gap_ext_adv_stop_no_lock(uint8_t instance)
 {
-    struct ble_hci_le_set_ext_adv_enable_cp *cmd;
+    struct ble_hci_le_set_ext_adv_enable_cp* cmd;
     uint8_t buf[sizeof(*cmd) + sizeof(cmd->sets[0])];
     uint16_t opcode;
     bool active;
@@ -3562,7 +3643,7 @@ ble_gap_ext_adv_stop_no_lock(uint8_t instance)
 
     active = ble_gap_adv_active_instance(instance);
 
-    cmd = (void *) buf;
+    cmd = (void*)buf;
 
     cmd->enable = 0x00;
     cmd->num_sets = 1;
@@ -3581,7 +3662,8 @@ ble_gap_ext_adv_stop_no_lock(uint8_t instance)
 
     if (!active) {
         return BLE_HS_EALREADY;
-    } else {
+    }
+    else {
         return 0;
     }
 }
@@ -3602,9 +3684,8 @@ ble_gap_ext_adv_stop(uint8_t instance)
     return rc;
 }
 
-
 static int
-ble_gap_ext_adv_set_data_validate(uint8_t instance, struct os_mbuf *data)
+ble_gap_ext_adv_set_data_validate(uint8_t instance, struct os_mbuf* data)
 {
     uint16_t len = OS_MBUF_PKTLEN(data);
 
@@ -3613,7 +3694,8 @@ ble_gap_ext_adv_set_data_validate(uint8_t instance, struct os_mbuf *data)
     }
 
     /* not allowed with directed advertising for legacy*/
-    if (ble_gap_slave[instance].legacy_pdu && ble_gap_slave[instance].directed) {
+    if (ble_gap_slave[instance].legacy_pdu &&
+        ble_gap_slave[instance].directed) {
         return BLE_HS_EINVAL;
     }
 
@@ -3645,13 +3727,13 @@ ble_gap_ext_adv_set_data_validate(uint8_t instance, struct os_mbuf *data)
 }
 
 static int
-ble_gap_ext_adv_set(uint8_t instance, uint16_t opcode, struct os_mbuf **data)
+ble_gap_ext_adv_set(uint8_t instance, uint16_t opcode, struct os_mbuf** data)
 {
     /* in that case we always fit all data in single HCI command */
 #if MYNEWT_VAL(BLE_EXT_ADV_MAX_SIZE) <= BLE_HCI_MAX_EXT_ADV_DATA_LEN
-    static uint8_t buf[sizeof(struct ble_hci_le_set_ext_adv_data_cp) + \
+    static uint8_t buf[sizeof(struct ble_hci_le_set_ext_adv_data_cp) +
                        MYNEWT_VAL(BLE_EXT_ADV_MAX_SIZE)];
-    struct ble_hci_le_set_ext_adv_data_cp *cmd = (void *)buf;
+    struct ble_hci_le_set_ext_adv_data_cp* cmd = (void*)buf;
     uint16_t len = OS_MBUF_PKTLEN(*data);
 
     opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, opcode);
@@ -3667,14 +3749,14 @@ ble_gap_ext_adv_set(uint8_t instance, uint16_t opcode, struct os_mbuf **data)
     return ble_hs_hci_cmd_tx(opcode, cmd, sizeof(*cmd) + cmd->adv_data_len,
                              NULL, 0);
 #else
-    static uint8_t buf[sizeof(struct ble_hci_le_set_ext_adv_data_cp) + \
+    static uint8_t buf[sizeof(struct ble_hci_le_set_ext_adv_data_cp) +
                        BLE_HCI_MAX_EXT_ADV_DATA_LEN];
-    struct ble_hci_le_set_ext_adv_data_cp *cmd = (void *)buf;
+    struct ble_hci_le_set_ext_adv_data_cp* cmd = (void*)buf;
     uint16_t len = OS_MBUF_PKTLEN(*data);
     uint8_t op;
     int rc;
 
-    opcode =  BLE_HCI_OP(BLE_HCI_OGF_LE, opcode);
+    opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, opcode);
 
     cmd->adv_handle = instance;
 
@@ -3729,7 +3811,7 @@ ble_gap_ext_adv_set(uint8_t instance, uint16_t opcode, struct os_mbuf **data)
 }
 
 int
-ble_gap_ext_adv_set_data(uint8_t instance, struct os_mbuf *data)
+ble_gap_ext_adv_set_data(uint8_t instance, struct os_mbuf* data)
 {
     int rc;
 
@@ -3760,7 +3842,7 @@ done:
 }
 
 static int
-ble_gap_ext_adv_rsp_set_validate(uint8_t instance,  struct os_mbuf *data)
+ble_gap_ext_adv_rsp_set_validate(uint8_t instance, struct os_mbuf* data)
 {
     uint16_t len = OS_MBUF_PKTLEN(data);
 
@@ -3769,7 +3851,8 @@ ble_gap_ext_adv_rsp_set_validate(uint8_t instance,  struct os_mbuf *data)
     }
 
     /* not allowed with directed advertising */
-    if (ble_gap_slave[instance].directed && ble_gap_slave[instance].connectable) {
+    if (ble_gap_slave[instance].directed &&
+        ble_gap_slave[instance].connectable) {
         return BLE_HS_EINVAL;
     }
 
@@ -3801,7 +3884,7 @@ ble_gap_ext_adv_rsp_set_validate(uint8_t instance,  struct os_mbuf *data)
 }
 
 int
-ble_gap_ext_adv_rsp_set_data(uint8_t instance, struct os_mbuf *data)
+ble_gap_ext_adv_rsp_set_data(uint8_t instance, struct os_mbuf* data)
 {
     int rc;
 
@@ -3920,7 +4003,7 @@ ble_gap_ext_adv_clear(void)
 #if MYNEWT_VAL(BLE_PERIODIC_ADV)
 static int
 ble_gap_periodic_adv_params_tx(uint8_t instance,
-                               const struct ble_gap_periodic_adv_params *params)
+                               const struct ble_gap_periodic_adv_params* params)
 
 {
     struct ble_hci_le_set_periodic_adv_params_cp cmd;
@@ -3932,15 +4015,16 @@ ble_gap_periodic_adv_params_tx(uint8_t instance,
     if (params->itvl_min == 0 && params->itvl_max == 0) {
         cmd.min_itvl = BLE_GAP_PERIODIC_ITVL_MS(30);
         cmd.max_itvl = BLE_GAP_PERIODIC_ITVL_MS(60);
-
-    } else {
+    }
+    else {
         cmd.min_itvl = htole16(params->itvl_min);
         cmd.max_itvl = htole16(params->itvl_max);
     }
 
     if (params->include_tx_power) {
         cmd.props = BLE_HCI_LE_SET_PERIODIC_ADV_PROP_INC_TX_PWR;
-    } else {
+    }
+    else {
         cmd.props = 0;
     }
 
@@ -3951,7 +4035,7 @@ ble_gap_periodic_adv_params_tx(uint8_t instance,
 
 static int
 ble_gap_periodic_adv_params_validate(
-        const struct ble_gap_periodic_adv_params *params)
+    const struct ble_gap_periodic_adv_params* params)
 {
     if (!params) {
         return BLE_HS_EINVAL;
@@ -3961,14 +4045,14 @@ ble_gap_periodic_adv_params_validate(
         return BLE_HS_EINVAL;
     }
     if (params->itvl_max && params->itvl_max < 6) {
-            return BLE_HS_EINVAL;
+        return BLE_HS_EINVAL;
     }
     return 0;
 }
 
 int
 ble_gap_periodic_adv_configure(uint8_t instance,
-        const struct ble_gap_periodic_adv_params *params)
+                               const struct ble_gap_periodic_adv_params* params)
 {
     int rc;
 
@@ -4016,7 +4100,8 @@ ble_gap_periodic_adv_configure(uint8_t instance,
 }
 
 int
-ble_gap_periodic_adv_start(uint8_t instance, const struct ble_gap_periodic_adv_start_params *params)
+ble_gap_periodic_adv_start(
+    uint8_t instance, const struct ble_gap_periodic_adv_start_params* params)
 {
     struct ble_hci_le_set_periodic_adv_enable_cp cmd;
     uint16_t opcode;
@@ -4066,7 +4151,7 @@ static int
 ble_gap_periodic_adv_update_did(uint8_t instance)
 {
     static uint8_t buf[sizeof(struct ble_hci_le_set_periodic_adv_data_cp)];
-    struct ble_hci_le_set_periodic_adv_data_cp *cmd = (void *) buf;
+    struct ble_hci_le_set_periodic_adv_data_cp* cmd = (void*)buf;
     uint16_t opcode;
 
     memset(buf, 0, sizeof(buf));
@@ -4083,13 +4168,13 @@ ble_gap_periodic_adv_update_did(uint8_t instance)
 #endif
 
 static int
-ble_gap_periodic_adv_set(uint8_t instance, struct os_mbuf **data)
+ble_gap_periodic_adv_set(uint8_t instance, struct os_mbuf** data)
 {
     /* In that case we always fit all data in single HCI command */
 #if MYNEWT_VAL(BLE_EXT_ADV_MAX_SIZE) <= BLE_HCI_MAX_PERIODIC_ADV_DATA_LEN
     static uint8_t buf[sizeof(struct ble_hci_le_set_periodic_adv_data_cp) +
                        MYNEWT_VAL(BLE_EXT_ADV_MAX_SIZE)];
-    struct ble_hci_le_set_periodic_adv_data_cp *cmd = (void *) buf;
+    struct ble_hci_le_set_periodic_adv_data_cp* cmd = (void*)buf;
     uint16_t len = 0;
     uint16_t opcode;
 
@@ -4115,7 +4200,7 @@ ble_gap_periodic_adv_set(uint8_t instance, struct os_mbuf **data)
 #else
     static uint8_t buf[sizeof(struct ble_hci_le_set_periodic_adv_data_cp) +
                        BLE_HCI_MAX_PERIODIC_ADV_DATA_LEN];
-    struct ble_hci_le_set_periodic_adv_data_cp *cmd = (void *) buf;
+    struct ble_hci_le_set_periodic_adv_data_cp* cmd = (void*)buf;
     uint16_t len = 0;
     uint16_t opcode;
     uint8_t op;
@@ -4155,7 +4240,7 @@ ble_gap_periodic_adv_set(uint8_t instance, struct os_mbuf **data)
     /* First fragment  */
     op = BLE_HCI_LE_SET_DATA_OPER_FIRST;
 
-    do{
+    do {
         cmd->operation = op;
         cmd->adv_data_len = BLE_HCI_MAX_PERIODIC_ADV_DATA_LEN;
         os_mbuf_copydata(*data, 0, BLE_HCI_MAX_PERIODIC_ADV_DATA_LEN,
@@ -4188,8 +4273,7 @@ ble_gap_periodic_adv_set(uint8_t instance, struct os_mbuf **data)
 }
 
 static int
-ble_gap_periodic_adv_set_data_validate(uint8_t instance,
-                                       struct os_mbuf *data)
+ble_gap_periodic_adv_set_data_validate(uint8_t instance, struct os_mbuf* data)
 {
     /* The corresponding extended advertising instance should be configured */
     if (!ble_gap_slave[instance].configured) {
@@ -4210,9 +4294,9 @@ ble_gap_periodic_adv_set_data_validate(uint8_t instance,
 }
 
 int
-ble_gap_periodic_adv_set_data(uint8_t instance,
-                              struct os_mbuf *data,
-                              const struct ble_gap_periodic_adv_set_data_params *params)
+ble_gap_periodic_adv_set_data(
+    uint8_t instance, struct os_mbuf* data,
+    const struct ble_gap_periodic_adv_set_data_params* params)
 {
     int rc;
     if (instance >= BLE_ADV_INSTANCES) {
@@ -4244,7 +4328,8 @@ ble_gap_periodic_adv_set_data(uint8_t instance,
 #if MYNEWT_VAL(BLE_VERSION) >= 53
     if (params && params->update_did) {
         rc = ble_gap_periodic_adv_update_did(instance);
-    } else {
+    }
+    else {
         rc = ble_gap_periodic_adv_set(instance, &data);
     }
 #else
@@ -4301,12 +4386,12 @@ ble_gap_periodic_adv_stop(uint8_t instance)
 }
 
 static void
-ble_gap_npl_sync_lost(struct ble_npl_event *ev)
+ble_gap_npl_sync_lost(struct ble_npl_event* ev)
 {
-    struct ble_hs_periodic_sync *psync;
+    struct ble_hs_periodic_sync* psync;
     struct ble_gap_event event;
-    ble_gap_event_fn *cb;
-    void *cb_arg;
+    ble_gap_event_fn* cb;
+    void* cb_arg;
 
     /* this psync is no longer on list so no lock needed */
     psync = ble_npl_event_get_arg(ev);
@@ -4329,12 +4414,13 @@ ble_gap_npl_sync_lost(struct ble_npl_event *ev)
 }
 
 int
-ble_gap_periodic_adv_sync_create(const ble_addr_t *addr, uint8_t adv_sid,
-                                 const struct ble_gap_periodic_sync_params *params,
-                                 ble_gap_event_fn *cb, void *cb_arg)
+ble_gap_periodic_adv_sync_create(
+    const ble_addr_t* addr, uint8_t adv_sid,
+    const struct ble_gap_periodic_sync_params* params, ble_gap_event_fn* cb,
+    void* cb_arg)
 {
     struct ble_hci_le_periodic_adv_create_sync_cp cmd;
-    struct ble_hs_periodic_sync *psync;
+    struct ble_hs_periodic_sync* psync;
     uint16_t opcode;
     int rc;
 
@@ -4345,7 +4431,7 @@ ble_gap_periodic_adv_sync_create(const ble_addr_t *addr, uint8_t adv_sid,
         return BLE_HS_EINVAL;
     }
     if ((params->skip > 0x1f3) || (params->sync_timeout > 0x4000) ||
-            (params->sync_timeout < 0x0A)) {
+        (params->sync_timeout < 0x0A)) {
         return BLE_HS_EINVAL;
     }
 
@@ -4380,7 +4466,8 @@ ble_gap_periodic_adv_sync_create(const ble_addr_t *addr, uint8_t adv_sid,
         cmd.options = 0x00;
         cmd.peer_addr_type = addr->type;
         memcpy(cmd.peer_addr, addr->val, BLE_DEV_ADDR_LEN);
-    } else {
+    }
+    else {
         cmd.options = 0x01;
         cmd.peer_addr_type = BLE_ADDR_ANY->type;
         memcpy(cmd.peer_addr, BLE_ADDR_ANY->val, BLE_DEV_ADDR_LEN);
@@ -4400,7 +4487,8 @@ ble_gap_periodic_adv_sync_create(const ble_addr_t *addr, uint8_t adv_sid,
     cmd.sync_timeout = htole16(params->sync_timeout);
     cmd.sync_cte_type = 0x00;
 
-    opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_PERIODIC_ADV_CREATE_SYNC);
+    opcode =
+        BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_PERIODIC_ADV_CREATE_SYNC);
     rc = ble_hs_hci_cmd_tx(opcode, &cmd, sizeof(cmd), NULL, 0);
     if (!rc) {
         /* This shall be reset upon receiving sync_established event,
@@ -4410,7 +4498,8 @@ ble_gap_periodic_adv_sync_create(const ble_addr_t *addr, uint8_t adv_sid,
         ble_gap_sync.cb = cb;
         ble_gap_sync.cb_arg = cb_arg;
         ble_gap_sync.psync = psync;
-    } else {
+    }
+    else {
         ble_hs_periodic_sync_free(psync);
     }
 
@@ -4446,7 +4535,7 @@ int
 ble_gap_periodic_adv_sync_terminate(uint16_t sync_handle)
 {
     struct ble_hci_le_periodic_adv_term_sync_cp cmd;
-    struct ble_hs_periodic_sync *psync;
+    struct ble_hs_periodic_sync* psync;
     uint16_t opcode;
     int rc;
 
@@ -4494,12 +4583,12 @@ ble_gap_periodic_adv_sync_terminate(uint16_t sync_handle)
 #if MYNEWT_VAL(BLE_PERIODIC_ADV_SYNC_TRANSFER)
 /* LE Set Periodic Advertising Receive Enable command */
 int
-ble_gap_periodic_adv_sync_reporting(uint16_t sync_handle,
-                                    bool enable,
-                                    const struct ble_gap_periodic_adv_sync_reporting_params *params)
+ble_gap_periodic_adv_sync_reporting(
+    uint16_t sync_handle, bool enable,
+    const struct ble_gap_periodic_adv_sync_reporting_params* params)
 {
     struct ble_hci_le_periodic_adv_receive_enable_cp cmd;
-    struct ble_hs_periodic_sync *psync;
+    struct ble_hs_periodic_sync* psync;
     uint16_t opcode;
     int rc;
 
@@ -4520,7 +4609,8 @@ ble_gap_periodic_adv_sync_reporting(uint16_t sync_handle,
         return BLE_HS_ENOTCONN;
     }
 
-    opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_PERIODIC_ADV_RECEIVE_ENABLE);
+    opcode =
+        BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_PERIODIC_ADV_RECEIVE_ENABLE);
 
     cmd.sync_handle = htole16(sync_handle);
     cmd.enable = enable ? 0x01 : 0x00;
@@ -4543,8 +4633,8 @@ ble_gap_periodic_adv_sync_transfer(uint16_t sync_handle, uint16_t conn_handle,
 {
     struct ble_hci_le_periodic_adv_sync_transfer_cp cmd;
     struct ble_hci_le_periodic_adv_sync_transfer_rp rsp;
-    struct ble_hs_periodic_sync *psync;
-    struct ble_hs_conn *conn;
+    struct ble_hs_periodic_sync* psync;
+    struct ble_hs_conn* conn;
     uint16_t opcode;
     int rc;
 
@@ -4566,7 +4656,8 @@ ble_gap_periodic_adv_sync_transfer(uint16_t sync_handle, uint16_t conn_handle,
         return BLE_HS_ENOTCONN;
     }
 
-    opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_PERIODIC_ADV_SYNC_TRANSFER);
+    opcode =
+        BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_PERIODIC_ADV_SYNC_TRANSFER);
 
     cmd.conn_handle = htole16(conn_handle);
     cmd.sync_handle = htole16(sync_handle);
@@ -4588,7 +4679,7 @@ ble_gap_periodic_adv_sync_set_info(uint8_t instance, uint16_t conn_handle,
 {
     struct ble_hci_le_periodic_adv_set_info_transfer_cp cmd;
     struct ble_hci_le_periodic_adv_set_info_transfer_rp rsp;
-    struct ble_hs_conn *conn;
+    struct ble_hs_conn* conn;
     uint16_t opcode;
     int rc;
 
@@ -4613,7 +4704,8 @@ ble_gap_periodic_adv_sync_set_info(uint8_t instance, uint16_t conn_handle,
         return BLE_HS_ENOTCONN;
     }
 
-    opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_PERIODIC_ADV_SET_INFO_TRANSFER);
+    opcode = BLE_HCI_OP(BLE_HCI_OGF_LE,
+                        BLE_HCI_OCF_LE_PERIODIC_ADV_SET_INFO_TRANSFER);
 
     cmd.conn_handle = htole16(conn_handle);
     cmd.adv_handle = instance;
@@ -4631,14 +4723,15 @@ ble_gap_periodic_adv_sync_set_info(uint8_t instance, uint16_t conn_handle,
 
 static int
 periodic_adv_transfer_enable(uint16_t conn_handle,
-                             const struct ble_gap_periodic_sync_params *params)
+                             const struct ble_gap_periodic_sync_params* params)
 {
     struct ble_hci_le_periodic_adv_sync_transfer_params_cp cmd;
     struct ble_hci_le_periodic_adv_sync_transfer_params_rp rsp;
     uint16_t opcode;
     int rc;
 
-    opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_PERIODIC_ADV_SYNC_TRANSFER_PARAMS);
+    opcode = BLE_HCI_OP(BLE_HCI_OGF_LE,
+                        BLE_HCI_OCF_LE_PERIODIC_ADV_SYNC_TRANSFER_PARAMS);
 
     memset(&cmd, 0, sizeof(cmd));
     cmd.conn_handle = htole16(conn_handle);
@@ -4666,7 +4759,8 @@ periodic_adv_transfer_enable(uint16_t conn_handle,
 }
 
 int
-periodic_adv_set_default_sync_params(const struct ble_gap_periodic_sync_params *params)
+periodic_adv_set_default_sync_params(
+    const struct ble_gap_periodic_sync_params* params)
 {
     struct ble_hci_le_set_default_periodic_sync_transfer_params_cp cmd;
     uint16_t opcode;
@@ -4675,7 +4769,8 @@ periodic_adv_set_default_sync_params(const struct ble_gap_periodic_sync_params *
         return BLE_HS_EDISABLED;
     }
 
-    opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_SET_DEFAULT_SYNC_TRANSFER_PARAMS);
+    opcode = BLE_HCI_OP(BLE_HCI_OGF_LE,
+                        BLE_HCI_OCF_LE_SET_DEFAULT_SYNC_TRANSFER_PARAMS);
 
     memset(&cmd, 0, sizeof(cmd));
 
@@ -4697,11 +4792,11 @@ periodic_adv_set_default_sync_params(const struct ble_gap_periodic_sync_params *
 }
 
 int
-ble_gap_periodic_adv_sync_receive(uint16_t conn_handle,
-                                  const struct ble_gap_periodic_sync_params *params,
-                                  ble_gap_event_fn *cb, void *cb_arg)
+ble_gap_periodic_adv_sync_receive(
+    uint16_t conn_handle, const struct ble_gap_periodic_sync_params* params,
+    ble_gap_event_fn* cb, void* cb_arg)
 {
-    struct ble_hs_conn *conn;
+    struct ble_hs_conn* conn;
     int rc;
 
     if (!ble_hs_is_enabled()) {
@@ -4732,13 +4827,15 @@ ble_gap_periodic_adv_sync_receive(uint16_t conn_handle,
         if (rc) {
             ble_hs_periodic_sync_free(conn->psync);
             conn->psync = NULL;
-        } else {
+        }
+        else {
             conn->psync->cb = cb;
             conn->psync->cb_arg = cb_arg;
             ble_npl_event_init(&conn->psync->lost_ev, ble_gap_npl_sync_lost,
                                conn->psync);
         }
-    } else {
+    }
+    else {
         if (!conn->psync) {
             ble_hs_unlock();
             return BLE_HS_EALREADY;
@@ -4758,7 +4855,7 @@ ble_gap_periodic_adv_sync_receive(uint16_t conn_handle,
 #endif
 
 int
-ble_gap_add_dev_to_periodic_adv_list(const ble_addr_t *peer_addr,
+ble_gap_add_dev_to_periodic_adv_list(const ble_addr_t* peer_addr,
                                      uint8_t adv_sid)
 {
     struct ble_hci_le_add_dev_to_periodic_adv_list_cp cmd;
@@ -4776,14 +4873,15 @@ ble_gap_add_dev_to_periodic_adv_list(const ble_addr_t *peer_addr,
     memcpy(cmd.peer_addr, peer_addr->val, BLE_DEV_ADDR_LEN);
     cmd.sid = adv_sid;
 
-    opcode = BLE_HCI_OP(BLE_HCI_OGF_LE,
-                        BLE_HCI_OCF_LE_ADD_DEV_TO_PERIODIC_ADV_LIST);
+    opcode =
+        BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_ADD_DEV_TO_PERIODIC_ADV_LIST);
 
     return ble_hs_hci_cmd_tx(opcode, &cmd, sizeof(cmd), NULL, 0);
 }
 
 int
-ble_gap_rem_dev_from_periodic_adv_list(const ble_addr_t *peer_addr, uint8_t adv_sid)
+ble_gap_rem_dev_from_periodic_adv_list(const ble_addr_t* peer_addr,
+                                       uint8_t adv_sid)
 {
     struct ble_hci_le_rem_dev_from_periodic_adv_list_cp cmd;
     uint16_t opcode;
@@ -4820,13 +4918,14 @@ ble_gap_clear_periodic_adv_list(void)
 }
 
 int
-ble_gap_read_periodic_adv_list_size(uint8_t *per_adv_list_size)
+ble_gap_read_periodic_adv_list_size(uint8_t* per_adv_list_size)
 {
     struct ble_hci_le_rd_periodic_adv_list_size_rp rsp;
     uint16_t opcode;
     int rc = 0;
 
-    opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_RD_PERIODIC_ADV_LIST_SIZE);
+    opcode =
+        BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_RD_PERIODIC_ADV_LIST_SIZE);
 
     rc = ble_hs_hci_cmd_tx(opcode, NULL, 0, &rsp, sizeof(rsp));
     if (rc != 0) {
@@ -4845,12 +4944,13 @@ ble_gap_read_periodic_adv_list_size(uint8_t *per_adv_list_size)
 
 #if MYNEWT_VAL(BLE_EXT_ADV) && NIMBLE_BLE_SCAN
 static int
-ble_gap_ext_disc_tx_params(uint8_t own_addr_type, uint8_t filter_policy,
-                       const struct ble_hs_hci_ext_scan_param *uncoded_params,
-                       const struct ble_hs_hci_ext_scan_param *coded_params)
+ble_gap_ext_disc_tx_params(
+    uint8_t own_addr_type, uint8_t filter_policy,
+    const struct ble_hs_hci_ext_scan_param* uncoded_params,
+    const struct ble_hs_hci_ext_scan_param* coded_params)
 {
-    struct ble_hci_le_set_ext_scan_params_cp *cmd;
-    struct scan_params *params;
+    struct ble_hci_le_set_ext_scan_params_cp* cmd;
+    struct scan_params* params;
     uint8_t buf[sizeof(*cmd) + 2 * sizeof(*params)];
     uint8_t len = sizeof(*cmd);
 
@@ -4864,7 +4964,7 @@ ble_gap_ext_disc_tx_params(uint8_t own_addr_type, uint8_t filter_policy,
         return BLE_ERR_INV_HCI_CMD_PARMS;
     }
 
-    cmd = (void *) buf;
+    cmd = (void*)buf;
     params = cmd->scans;
 
     cmd->filter_policy = filter_policy;
@@ -4897,9 +4997,9 @@ ble_gap_ext_disc_tx_params(uint8_t own_addr_type, uint8_t filter_policy,
         return BLE_ERR_INV_HCI_CMD_PARMS;
     }
 
-    return ble_hs_hci_cmd_tx(BLE_HCI_OP(BLE_HCI_OGF_LE,
-                                        BLE_HCI_OCF_LE_SET_EXT_SCAN_PARAM),
-                             cmd, len, NULL, 0);
+    return ble_hs_hci_cmd_tx(
+        BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_SET_EXT_SCAN_PARAM), cmd, len,
+        NULL, 0);
 }
 
 static int
@@ -4913,9 +5013,9 @@ ble_gap_ext_disc_enable_tx(uint8_t enable, uint8_t filter_duplicates,
     cmd.duration = htole16(duration);
     cmd.period = htole16(period);
 
-    return ble_hs_hci_cmd_tx(BLE_HCI_OP(BLE_HCI_OGF_LE,
-                                        BLE_HCI_OCF_LE_SET_EXT_SCAN_ENABLE),
-                             &cmd, sizeof(cmd), NULL, 0);
+    return ble_hs_hci_cmd_tx(
+        BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_SET_EXT_SCAN_ENABLE), &cmd,
+        sizeof(cmd), NULL, 0);
 }
 #endif
 #endif
@@ -4937,14 +5037,15 @@ ble_gap_disc_enable_tx(int enable, int filter_duplicates)
 
 static int
 ble_gap_disc_tx_params(uint8_t own_addr_type,
-                       const struct ble_gap_disc_params *disc_params)
+                       const struct ble_gap_disc_params* disc_params)
 {
     struct ble_hci_le_set_scan_params_cp cmd;
     uint16_t opcode;
 
     if (disc_params->passive) {
         cmd.scan_type = BLE_HCI_SCAN_TYPE_PASSIVE;
-    } else {
+    }
+    else {
         cmd.scan_type = BLE_HCI_SCAN_TYPE_ACTIVE;
     }
 
@@ -5048,12 +5149,13 @@ ble_gap_disc_ext_validate(uint8_t own_addr_type)
 #if MYNEWT_VAL(BLE_EXT_ADV) && NIMBLE_BLE_SCAN
 static void
 ble_gap_ext_disc_fill_dflts(uint8_t limited,
-                            struct ble_hs_hci_ext_scan_param *disc_params)
+                            struct ble_hs_hci_ext_scan_param* disc_params)
 {
-   if (disc_params->scan_itvl == 0) {
+    if (disc_params->scan_itvl == 0) {
         if (limited) {
             disc_params->scan_itvl = BLE_GAP_LIM_DISC_SCAN_INT;
-        } else {
+        }
+        else {
             disc_params->scan_itvl = BLE_GAP_SCAN_FAST_INTERVAL_MIN;
         }
     }
@@ -5061,22 +5163,24 @@ ble_gap_ext_disc_fill_dflts(uint8_t limited,
     if (disc_params->scan_window == 0) {
         if (limited) {
             disc_params->scan_window = BLE_GAP_LIM_DISC_SCAN_WINDOW;
-        } else {
+        }
+        else {
             disc_params->scan_window = BLE_GAP_SCAN_FAST_WINDOW;
         }
     }
 }
 
 static void
-ble_gap_ext_scan_params_to_hci(const struct ble_gap_ext_disc_params *params,
-                               struct ble_hs_hci_ext_scan_param *hci_params)
+ble_gap_ext_scan_params_to_hci(const struct ble_gap_ext_disc_params* params,
+                               struct ble_hs_hci_ext_scan_param* hci_params)
 {
 
     memset(hci_params, 0, sizeof(*hci_params));
 
     if (params->passive) {
-        hci_params->scan_type =  BLE_HCI_SCAN_TYPE_PASSIVE;
-    } else {
+        hci_params->scan_type = BLE_HCI_SCAN_TYPE_PASSIVE;
+    }
+    else {
         hci_params->scan_type = BLE_HCI_SCAN_TYPE_ACTIVE;
     }
 
@@ -5089,9 +5193,9 @@ int
 ble_gap_ext_disc(uint8_t own_addr_type, uint16_t duration, uint16_t period,
                  uint8_t filter_duplicates, uint8_t filter_policy,
                  uint8_t limited,
-                 const struct ble_gap_ext_disc_params *uncoded_params,
-                 const struct ble_gap_ext_disc_params *coded_params,
-                 ble_gap_event_fn *cb, void *cb_arg)
+                 const struct ble_gap_ext_disc_params* uncoded_params,
+                 const struct ble_gap_ext_disc_params* coded_params,
+                 ble_gap_event_fn* cb, void* cb_arg)
 {
 #if NIMBLE_BLE_SCAN && MYNEWT_VAL(BLE_EXT_ADV)
     struct ble_hs_hci_ext_scan_param ucp;
@@ -5177,12 +5281,13 @@ done:
 
 #if NIMBLE_BLE_SCAN && !MYNEWT_VAL(BLE_EXT_ADV)
 static void
-ble_gap_disc_fill_dflts(struct ble_gap_disc_params *disc_params)
+ble_gap_disc_fill_dflts(struct ble_gap_disc_params* disc_params)
 {
-   if (disc_params->itvl == 0) {
+    if (disc_params->itvl == 0) {
         if (disc_params->limited) {
             disc_params->itvl = BLE_GAP_LIM_DISC_SCAN_INT;
-        } else {
+        }
+        else {
             disc_params->itvl = BLE_GAP_SCAN_FAST_INTERVAL_MIN;
         }
     }
@@ -5190,7 +5295,8 @@ ble_gap_disc_fill_dflts(struct ble_gap_disc_params *disc_params)
     if (disc_params->window == 0) {
         if (disc_params->limited) {
             disc_params->window = BLE_GAP_LIM_DISC_SCAN_WINDOW;
-        } else {
+        }
+        else {
             disc_params->window = BLE_GAP_SCAN_FAST_WINDOW;
         }
     }
@@ -5198,7 +5304,7 @@ ble_gap_disc_fill_dflts(struct ble_gap_disc_params *disc_params)
 
 static int
 ble_gap_disc_validate(uint8_t own_addr_type,
-                      const struct ble_gap_disc_params *disc_params)
+                      const struct ble_gap_disc_params* disc_params)
 {
     if (disc_params == NULL) {
         return BLE_HS_EINVAL;
@@ -5224,8 +5330,8 @@ ble_gap_disc_validate(uint8_t own_addr_type,
 
 int
 ble_gap_disc(uint8_t own_addr_type, int32_t duration_ms,
-             const struct ble_gap_disc_params *disc_params,
-             ble_gap_event_fn *cb, void *cb_arg)
+             const struct ble_gap_disc_params* disc_params,
+             ble_gap_event_fn* cb, void* cb_arg)
 {
 #if NIMBLE_BLE_SCAN
 #if MYNEWT_VAL(BLE_EXT_ADV)
@@ -5242,14 +5348,14 @@ ble_gap_disc(uint8_t own_addr_type, int32_t duration_ms,
 
     if (duration_ms == BLE_HS_FOREVER) {
         duration_ms = 0;
-    } else if (duration_ms == 0) {
+    }
+    else if (duration_ms == 0) {
         duration_ms = BLE_GAP_DISC_DUR_DFLT;
     }
 
-    rc = ble_gap_ext_disc(own_addr_type, duration_ms/10, 0,
-                          disc_params->filter_duplicates,
-                          disc_params->filter_policy, disc_params->limited,
-                          &p, NULL, cb, cb_arg);
+    rc = ble_gap_ext_disc(
+        own_addr_type, duration_ms / 10, 0, disc_params->filter_duplicates,
+        disc_params->filter_policy, disc_params->limited, &p, NULL, cb, cb_arg);
 
     ble_gap_master.legacy_discovery = 1;
 
@@ -5355,8 +5461,8 @@ ble_gap_disc_active(void)
  *****************************************************************************/
 
 static int
-ble_gap_conn_create_tx(uint8_t own_addr_type, const ble_addr_t *peer_addr,
-                       const struct ble_gap_conn_params *params)
+ble_gap_conn_create_tx(uint8_t own_addr_type, const ble_addr_t* peer_addr,
+                       const struct ble_gap_conn_params* params)
 {
     struct ble_hci_le_create_conn_cp cmd;
     uint16_t opcode;
@@ -5371,7 +5477,8 @@ ble_gap_conn_create_tx(uint8_t own_addr_type, const ble_addr_t *peer_addr,
         cmd.filter_policy = BLE_HCI_CONN_FILT_USE_WL;
         cmd.peer_addr_type = 0;
         memset(cmd.peer_addr, 0, sizeof(cmd.peer_addr));
-    } else {
+    }
+    else {
         cmd.filter_policy = BLE_HCI_CONN_FILT_NO_WL;
         cmd.peer_addr_type = peer_addr->type;
         memcpy(cmd.peer_addr, peer_addr->val, sizeof(cmd.peer_addr));
@@ -5393,8 +5500,9 @@ ble_gap_conn_create_tx(uint8_t own_addr_type, const ble_addr_t *peer_addr,
 
 #if MYNEWT_VAL(BLE_CONN_SUBRATING)
 int
-ble_gap_set_default_subrate(uint16_t subrate_min, uint16_t subrate_max, uint16_t max_latency,
-                            uint16_t cont_num, uint16_t supervision_tmo)
+ble_gap_set_default_subrate(uint16_t subrate_min, uint16_t subrate_max,
+                            uint16_t max_latency, uint16_t cont_num,
+                            uint16_t supervision_tmo)
 {
     struct ble_hci_le_set_default_subrate_cp cmd;
     uint16_t opcode;
@@ -5411,9 +5519,9 @@ ble_gap_set_default_subrate(uint16_t subrate_min, uint16_t subrate_max, uint16_t
 }
 
 int
-ble_gap_subrate_req(uint16_t conn_handle, uint16_t subrate_min, uint16_t subrate_max,
-                    uint16_t max_latency, uint16_t cont_num,
-                    uint16_t supervision_tmo)
+ble_gap_subrate_req(uint16_t conn_handle, uint16_t subrate_min,
+                    uint16_t subrate_max, uint16_t max_latency,
+                    uint16_t cont_num, uint16_t supervision_tmo)
 {
     struct ble_hci_le_subrate_req_cp cmd;
     uint16_t opcode;
@@ -5434,7 +5542,7 @@ ble_gap_subrate_req(uint16_t conn_handle, uint16_t subrate_min, uint16_t subrate
 #if MYNEWT_VAL(BLE_EXT_ADV)
 #if MYNEWT_VAL(BLE_ROLE_CENTRAL)
 static int
-ble_gap_check_conn_params(uint8_t phy, const struct ble_gap_conn_params *params)
+ble_gap_check_conn_params(uint8_t phy, const struct ble_gap_conn_params* params)
 {
     if (phy != BLE_HCI_LE_PHY_2M) {
         /* Check scan interval and window */
@@ -5446,7 +5554,7 @@ ble_gap_check_conn_params(uint8_t phy, const struct ble_gap_conn_params *params)
             return BLE_ERR_INV_HCI_CMD_PARMS;
         }
     }
-        /* Check connection interval min */
+    /* Check connection interval min */
     if ((params->itvl_min < BLE_HCI_CONN_ITVL_MIN) ||
         (params->itvl_min > BLE_HCI_CONN_ITVL_MAX)) {
         return BLE_ERR_INV_HCI_CMD_PARMS;
@@ -5479,13 +5587,13 @@ ble_gap_check_conn_params(uint8_t phy, const struct ble_gap_conn_params *params)
 
 static int
 ble_gap_ext_conn_create_tx(
-    uint8_t own_addr_type, const ble_addr_t *peer_addr, uint8_t phy_mask,
-    const struct ble_gap_conn_params *phy_1m_conn_params,
-    const struct ble_gap_conn_params *phy_2m_conn_params,
-    const struct ble_gap_conn_params *phy_coded_conn_params)
+    uint8_t own_addr_type, const ble_addr_t* peer_addr, uint8_t phy_mask,
+    const struct ble_gap_conn_params* phy_1m_conn_params,
+    const struct ble_gap_conn_params* phy_2m_conn_params,
+    const struct ble_gap_conn_params* phy_coded_conn_params)
 {
-    struct ble_hci_le_ext_create_conn_cp *cmd;
-    struct conn_params *params;
+    struct ble_hci_le_ext_create_conn_cp* cmd;
+    struct conn_params* params;
     uint8_t buf[sizeof(*cmd) + 3 * sizeof(*params)];
     uint8_t len = sizeof(*cmd);
     int rc;
@@ -5495,13 +5603,12 @@ ble_gap_ext_conn_create_tx(
         return BLE_ERR_INV_HCI_CMD_PARMS;
     }
 
-    if (phy_mask > (BLE_HCI_LE_PHY_1M_PREF_MASK |
-                    BLE_HCI_LE_PHY_2M_PREF_MASK |
+    if (phy_mask > (BLE_HCI_LE_PHY_1M_PREF_MASK | BLE_HCI_LE_PHY_2M_PREF_MASK |
                     BLE_HCI_LE_PHY_CODED_PREF_MASK)) {
         return BLE_ERR_INV_HCI_CMD_PARMS;
     }
 
-    cmd = (void *) buf;
+    cmd = (void*)buf;
     params = cmd->conn_params;
 
     if (peer_addr == NULL) {
@@ -5512,7 +5619,8 @@ ble_gap_ext_conn_create_tx(
         cmd->filter_policy = BLE_HCI_CONN_FILT_USE_WL;
         cmd->peer_addr_type = 0;
         memset(cmd->peer_addr, 0, sizeof(cmd->peer_addr));
-    } else {
+    }
+    else {
         /* Check peer addr type */
         if (peer_addr->type > BLE_HCI_CONN_PEER_ADDR_MAX) {
             return BLE_ERR_INV_HCI_CMD_PARMS;
@@ -5537,7 +5645,8 @@ ble_gap_ext_conn_create_tx(
         params->conn_min_itvl = htole16(phy_1m_conn_params->itvl_min);
         params->conn_max_itvl = htole16(phy_1m_conn_params->itvl_max);
         params->conn_latency = htole16(phy_1m_conn_params->latency);
-        params->supervision_timeout = htole16(phy_1m_conn_params->supervision_timeout);
+        params->supervision_timeout =
+            htole16(phy_1m_conn_params->supervision_timeout);
         params->min_ce = htole16(phy_1m_conn_params->min_ce_len);
         params->max_ce = htole16(phy_1m_conn_params->max_ce_len);
 
@@ -5556,7 +5665,8 @@ ble_gap_ext_conn_create_tx(
         params->conn_min_itvl = htole16(phy_2m_conn_params->itvl_min);
         params->conn_max_itvl = htole16(phy_2m_conn_params->itvl_max);
         params->conn_latency = htole16(phy_2m_conn_params->latency);
-        params->supervision_timeout = htole16(phy_2m_conn_params->supervision_timeout);
+        params->supervision_timeout =
+            htole16(phy_2m_conn_params->supervision_timeout);
         params->min_ce = htole16(phy_2m_conn_params->min_ce_len);
         params->max_ce = htole16(phy_2m_conn_params->max_ce_len);
 
@@ -5565,7 +5675,8 @@ ble_gap_ext_conn_create_tx(
     }
 
     if (phy_mask & BLE_GAP_LE_PHY_CODED_MASK) {
-        rc = ble_gap_check_conn_params(BLE_HCI_LE_PHY_CODED, phy_coded_conn_params);
+        rc = ble_gap_check_conn_params(BLE_HCI_LE_PHY_CODED,
+                                       phy_coded_conn_params);
         if (rc) {
             return rc;
         }
@@ -5575,7 +5686,8 @@ ble_gap_ext_conn_create_tx(
         params->conn_min_itvl = htole16(phy_coded_conn_params->itvl_min);
         params->conn_max_itvl = htole16(phy_coded_conn_params->itvl_max);
         params->conn_latency = htole16(phy_coded_conn_params->latency);
-        params->supervision_timeout = htole16(phy_coded_conn_params->supervision_timeout);
+        params->supervision_timeout =
+            htole16(phy_coded_conn_params->supervision_timeout);
         params->min_ce = htole16(phy_coded_conn_params->min_ce_len);
         params->max_ce = htole16(phy_coded_conn_params->max_ce_len);
 
@@ -5583,9 +5695,9 @@ ble_gap_ext_conn_create_tx(
         len += sizeof(*params);
     }
 
-    return ble_hs_hci_cmd_tx(BLE_HCI_OP(BLE_HCI_OGF_LE,
-                                        BLE_HCI_OCF_LE_EXT_CREATE_CONN),
-                                       cmd, len, NULL, 0);
+    return ble_hs_hci_cmd_tx(
+        BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_EXT_CREATE_CONN), cmd, len,
+        NULL, 0);
 }
 #endif
 
@@ -5641,12 +5753,12 @@ ble_gap_ext_conn_create_tx(
  *                              Other nonzero on error.
  */
 int
-ble_gap_ext_connect(uint8_t own_addr_type, const ble_addr_t *peer_addr,
-                int32_t duration_ms, uint8_t phy_mask,
-                const struct ble_gap_conn_params *phy_1m_conn_params,
-                const struct ble_gap_conn_params *phy_2m_conn_params,
-                const struct ble_gap_conn_params *phy_coded_conn_params,
-                ble_gap_event_fn *cb, void *cb_arg)
+ble_gap_ext_connect(uint8_t own_addr_type, const ble_addr_t* peer_addr,
+                    int32_t duration_ms, uint8_t phy_mask,
+                    const struct ble_gap_conn_params* phy_1m_conn_params,
+                    const struct ble_gap_conn_params* phy_2m_conn_params,
+                    const struct ble_gap_conn_params* phy_coded_conn_params,
+                    ble_gap_event_fn* cb, void* cb_arg)
 {
 #if MYNEWT_VAL(BLE_ROLE_CENTRAL)
     ble_npl_time_t duration_ticks;
@@ -5681,8 +5793,7 @@ ble_gap_ext_connect(uint8_t own_addr_type, const ble_addr_t *peer_addr,
         goto done;
     }
 
-    if (peer_addr &&
-        peer_addr->type != BLE_ADDR_PUBLIC &&
+    if (peer_addr && peer_addr->type != BLE_ADDR_PUBLIC &&
         peer_addr->type != BLE_ADDR_RANDOM &&
         peer_addr->type != BLE_ADDR_PUBLIC_ID &&
         peer_addr->type != BLE_ADDR_RANDOM_ID) {
@@ -5762,21 +5873,20 @@ done:
 #else
     return BLE_HS_ENOTSUP;
 #endif
-
 }
 #endif
 
 int
-ble_gap_connect(uint8_t own_addr_type, const ble_addr_t *peer_addr,
+ble_gap_connect(uint8_t own_addr_type, const ble_addr_t* peer_addr,
                 int32_t duration_ms,
-                const struct ble_gap_conn_params *conn_params,
-                ble_gap_event_fn *cb, void *cb_arg)
+                const struct ble_gap_conn_params* conn_params,
+                ble_gap_event_fn* cb, void* cb_arg)
 {
 #if MYNEWT_VAL(BLE_ROLE_CENTRAL)
 #if MYNEWT_VAL(BLE_EXT_ADV)
     return ble_gap_ext_connect(own_addr_type, peer_addr, duration_ms,
-                               BLE_GAP_LE_PHY_1M_MASK,
-                               conn_params, NULL, NULL, cb, cb_arg);
+                               BLE_GAP_LE_PHY_1M_MASK, conn_params, NULL, NULL,
+                               cb, cb_arg);
 #else
     uint32_t duration_ticks;
     int rc;
@@ -5810,8 +5920,7 @@ ble_gap_connect(uint8_t own_addr_type, const ble_addr_t *peer_addr,
         goto done;
     }
 
-    if (peer_addr &&
-        peer_addr->type != BLE_ADDR_PUBLIC &&
+    if (peer_addr && peer_addr->type != BLE_ADDR_PUBLIC &&
         peer_addr->type != BLE_ADDR_RANDOM &&
         peer_addr->type != BLE_ADDR_PUBLIC_ID &&
         peer_addr->type != BLE_ADDR_RANDOM_ID) {
@@ -5861,8 +5970,7 @@ ble_gap_connect(uint8_t own_addr_type, const ble_addr_t *peer_addr,
 
     ble_gap_master.op = BLE_GAP_OP_M_CONN;
 
-    rc = ble_gap_conn_create_tx(own_addr_type, peer_addr,
-                                conn_params);
+    rc = ble_gap_conn_create_tx(own_addr_type, peer_addr, conn_params);
     if (rc != 0) {
         ble_gap_master_reset_state();
         goto done;
@@ -5885,7 +5993,6 @@ done:
 #else
     return BLE_HS_ENOTSUP;
 #endif
-
 }
 
 int
@@ -5903,7 +6010,7 @@ ble_gap_conn_active(void)
  * $terminate connection procedure                                           *
  *****************************************************************************/
 int
-ble_gap_terminate_with_conn(struct ble_hs_conn *conn, uint8_t hci_reason)
+ble_gap_terminate_with_conn(struct ble_hs_conn* conn, uint8_t hci_reason)
 {
 #if NIMBLE_BLE_CONNECT
     struct ble_hci_lc_disconnect_cp cmd;
@@ -5914,16 +6021,17 @@ ble_gap_terminate_with_conn(struct ble_hs_conn *conn, uint8_t hci_reason)
         return BLE_HS_EALREADY;
     }
 
-    BLE_HS_LOG(INFO, "GAP procedure initiated: terminate connection; "
-                     "conn_handle=%d hci_reason=%d\n",
-                     conn->bhc_handle, hci_reason);
+    BLE_HS_LOG(INFO,
+               "GAP procedure initiated: terminate connection; "
+               "conn_handle=%d hci_reason=%d\n",
+               conn->bhc_handle, hci_reason);
 
     cmd.conn_handle = htole16(conn->bhc_handle);
     cmd.reason = hci_reason;
 
-    rc = ble_hs_hci_cmd_tx(BLE_HCI_OP(BLE_HCI_OGF_LINK_CTRL,
-                                      BLE_HCI_OCF_DISCONNECT_CMD),
-                                      &cmd, sizeof(cmd), NULL, 0);
+    rc = ble_hs_hci_cmd_tx(
+        BLE_HCI_OP(BLE_HCI_OGF_LINK_CTRL, BLE_HCI_OCF_DISCONNECT_CMD), &cmd,
+        sizeof(cmd), NULL, 0);
     if (rc != 0) {
         return rc;
     }
@@ -5939,7 +6047,7 @@ int
 ble_gap_terminate(uint16_t conn_handle, uint8_t hci_reason)
 {
 #if NIMBLE_BLE_CONNECT
-    struct ble_hs_conn *conn;
+    struct ble_hs_conn* conn;
     int rc;
 
     STATS_INC(ble_gap_stats, terminate);
@@ -5980,9 +6088,9 @@ ble_gap_conn_cancel_tx(void)
 {
     int rc;
 
-    rc = ble_hs_hci_cmd_tx(BLE_HCI_OP(BLE_HCI_OGF_LE,
-                                      BLE_HCI_OCF_LE_CREATE_CONN_CANCEL),
-                           NULL, 0, NULL, 0);
+    rc = ble_hs_hci_cmd_tx(
+        BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_CREATE_CONN_CANCEL), NULL, 0,
+        NULL, 0);
     if (rc != 0) {
         return rc;
     }
@@ -6039,7 +6147,6 @@ ble_gap_conn_cancel(void)
 #else
     return BLE_HS_ENOTSUP;
 #endif
-
 }
 
 /*****************************************************************************
@@ -6047,10 +6154,10 @@ ble_gap_conn_cancel(void)
  *****************************************************************************/
 
 #if NIMBLE_BLE_CONNECT
-static struct ble_gap_update_entry *
+static struct ble_gap_update_entry*
 ble_gap_update_entry_alloc(void)
 {
-    struct ble_gap_update_entry *entry;
+    struct ble_gap_update_entry* entry;
 
     entry = os_memblock_get(&ble_gap_update_entry_pool);
     if (entry != NULL) {
@@ -6062,7 +6169,7 @@ ble_gap_update_entry_alloc(void)
 #endif
 
 static void
-ble_gap_update_entry_free(struct ble_gap_update_entry *entry)
+ble_gap_update_entry_free(struct ble_gap_update_entry* entry)
 {
     int rc;
 
@@ -6075,17 +6182,18 @@ ble_gap_update_entry_free(struct ble_gap_update_entry *entry)
     }
 }
 
-static struct ble_gap_update_entry *
+static struct ble_gap_update_entry*
 ble_gap_update_entry_find(uint16_t conn_handle,
-                          struct ble_gap_update_entry **out_prev)
+                          struct ble_gap_update_entry** out_prev)
 {
-    struct ble_gap_update_entry *entry;
-    struct ble_gap_update_entry *prev;
+    struct ble_gap_update_entry* entry;
+    struct ble_gap_update_entry* prev;
 
     BLE_HS_DBG_ASSERT(ble_hs_locked_by_cur_task());
 
     prev = NULL;
-    SLIST_FOREACH(entry, &ble_gap_update_entries, next) {
+    SLIST_FOREACH(entry, &ble_gap_update_entries, next)
+    {
         if (entry->conn_handle == conn_handle) {
             break;
         }
@@ -6100,17 +6208,18 @@ ble_gap_update_entry_find(uint16_t conn_handle,
     return entry;
 }
 
-static struct ble_gap_update_entry *
+static struct ble_gap_update_entry*
 ble_gap_update_entry_remove(uint16_t conn_handle)
 {
-    struct ble_gap_update_entry *entry;
-    struct ble_gap_update_entry *prev;
+    struct ble_gap_update_entry* entry;
+    struct ble_gap_update_entry* prev;
 
     entry = ble_gap_update_entry_find(conn_handle, &prev);
     if (entry != NULL) {
         if (prev == NULL) {
             SLIST_REMOVE_HEAD(&ble_gap_update_entries, next);
-        } else {
+        }
+        else {
             SLIST_NEXT(prev, next) = SLIST_NEXT(entry, next);
         }
         ble_hs_timer_resched();
@@ -6121,9 +6230,9 @@ ble_gap_update_entry_remove(uint16_t conn_handle)
 
 #if NIMBLE_BLE_CONNECT
 static void
-ble_gap_update_l2cap_cb(uint16_t conn_handle, int status, void *arg)
+ble_gap_update_l2cap_cb(uint16_t conn_handle, int status, void* arg)
 {
-    struct ble_gap_update_entry *entry;
+    struct ble_gap_update_entry* entry;
 
     /* Report failures and rejections.  Success gets reported when the
      * controller sends the connection update complete event.
@@ -6144,7 +6253,7 @@ ble_gap_update_l2cap_cb(uint16_t conn_handle, int status, void *arg)
 
 static int
 ble_gap_tx_param_pos_reply(uint16_t conn_handle,
-                           struct ble_gap_upd_params *params)
+                           struct ble_gap_upd_params* params)
 {
     struct ble_hci_le_rem_conn_param_rr_cp cmd;
 
@@ -6156,9 +6265,9 @@ ble_gap_tx_param_pos_reply(uint16_t conn_handle,
     cmd.min_ce = htole16(params->min_ce_len);
     cmd.max_ce = htole16(params->max_ce_len);
 
-    return ble_hs_hci_cmd_tx(BLE_HCI_OP(BLE_HCI_OGF_LE,
-                                        BLE_HCI_OCF_LE_REM_CONN_PARAM_RR),
-                             &cmd, sizeof(cmd), NULL, 0);
+    return ble_hs_hci_cmd_tx(
+        BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_REM_CONN_PARAM_RR), &cmd,
+        sizeof(cmd), NULL, 0);
 }
 
 static int
@@ -6169,14 +6278,14 @@ ble_gap_tx_param_neg_reply(uint16_t conn_handle, uint8_t reject_reason)
     cmd.conn_handle = htole16(conn_handle);
     cmd.reason = reject_reason;
 
-    return ble_hs_hci_cmd_tx(BLE_HCI_OP(BLE_HCI_OGF_LE,
-                                        BLE_HCI_OCF_LE_REM_CONN_PARAM_NRR),
-                                     &cmd, sizeof(cmd), NULL, 0);
+    return ble_hs_hci_cmd_tx(
+        BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_REM_CONN_PARAM_NRR), &cmd,
+        sizeof(cmd), NULL, 0);
 }
 #endif
 
 void
-ble_gap_rx_param_req(const struct ble_hci_ev_le_subev_rem_conn_param_req *ev)
+ble_gap_rx_param_req(const struct ble_hci_ev_le_subev_rem_conn_param_req* ev)
 {
 #if NIMBLE_BLE_CONNECT
     struct ble_gap_upd_params peer_params;
@@ -6213,7 +6322,8 @@ ble_gap_rx_param_req(const struct ble_hci_ev_le_subev_rem_conn_param_req *ev)
         if (rc != 0) {
             ble_gap_update_failed(conn_handle, rc);
         }
-    } else {
+    }
+    else {
         ble_gap_tx_param_neg_reply(conn_handle, rc);
     }
 #endif
@@ -6221,8 +6331,7 @@ ble_gap_rx_param_req(const struct ble_hci_ev_le_subev_rem_conn_param_req *ev)
 
 #if NIMBLE_BLE_CONNECT
 static int
-ble_gap_update_tx(uint16_t conn_handle,
-                  const struct ble_gap_upd_params *params)
+ble_gap_update_tx(uint16_t conn_handle, const struct ble_gap_upd_params* params)
 {
     struct ble_hci_le_conn_update_cp cmd;
 
@@ -6234,13 +6343,13 @@ ble_gap_update_tx(uint16_t conn_handle,
     cmd.min_ce_len = htole16(params->min_ce_len);
     cmd.max_ce_len = htole16(params->max_ce_len);
 
-    return ble_hs_hci_cmd_tx(BLE_HCI_OP(BLE_HCI_OGF_LE,
-                                        BLE_HCI_OCF_LE_CONN_UPDATE),
-                                        &cmd, sizeof(cmd), NULL, 0);
+    return ble_hs_hci_cmd_tx(
+        BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_CONN_UPDATE), &cmd,
+        sizeof(cmd), NULL, 0);
 }
 
 static bool
-ble_gap_validate_conn_params(const struct ble_gap_upd_params *params)
+ble_gap_validate_conn_params(const struct ble_gap_upd_params* params)
 {
 
     /* Requirements from Bluetooth spec. v4.2 [Vol 2, Part E], 7.8.18 */
@@ -6262,7 +6371,7 @@ ble_gap_validate_conn_params(const struct ble_gap_upd_params *params)
      * supervision_timeout * 10 ms > (1 + latency) * 2 * itvl_max * 1.25ms
      */
     if (params->supervision_timeout <=
-                   (((1 + params->latency) * params->itvl_max) / 4)) {
+        (((1 + params->latency) * params->itvl_max) / 4)) {
         return false;
     }
 
@@ -6272,13 +6381,13 @@ ble_gap_validate_conn_params(const struct ble_gap_upd_params *params)
 
 int
 ble_gap_update_params(uint16_t conn_handle,
-                      const struct ble_gap_upd_params *params)
+                      const struct ble_gap_upd_params* params)
 {
 #if NIMBLE_BLE_CONNECT
     struct ble_l2cap_sig_update_params l2cap_params;
-    struct ble_gap_update_entry *entry;
-    struct ble_gap_update_entry *dup;
-    struct ble_hs_conn *conn;
+    struct ble_gap_update_entry* entry;
+    struct ble_gap_update_entry* dup;
+    struct ble_hs_conn* conn;
     int l2cap_update;
     int rc;
 
@@ -6333,10 +6442,11 @@ ble_gap_update_params(uint16_t conn_handle,
      * the slave, fail over to the L2CAP update procedure.
      */
     if ((conn->supported_feat & BLE_HS_HCI_LE_FEAT_CONN_PARAM_REQUEST) == 0 &&
-            !(conn->bhc_flags & BLE_HS_CONN_F_MASTER)) {
+        !(conn->bhc_flags & BLE_HS_CONN_F_MASTER)) {
         l2cap_update = 1;
         rc = 0;
-    } else {
+    }
+    else {
         rc = ble_gap_update_tx(conn_handle, params);
     }
 
@@ -6345,17 +6455,19 @@ done:
 
     if (!l2cap_update) {
         ble_hs_timer_resched();
-    } else {
+    }
+    else {
         ble_gap_update_to_l2cap(params, &l2cap_params);
 
         rc = ble_l2cap_sig_update(conn_handle, &l2cap_params,
-                                              ble_gap_update_l2cap_cb, NULL);
+                                  ble_gap_update_l2cap_cb, NULL);
     }
 
     ble_hs_lock();
     if (rc == 0) {
         SLIST_INSERT_HEAD(&ble_gap_update_entries, entry, next);
-    } else {
+    }
+    else {
         ble_gap_update_entry_free(entry);
         STATS_INC(ble_gap_stats, update_fail);
     }
@@ -6368,15 +6480,14 @@ done:
 }
 
 int
-ble_gap_set_data_len(uint16_t conn_handle, uint16_t tx_octets,
-                     uint16_t tx_time)
+ble_gap_set_data_len(uint16_t conn_handle, uint16_t tx_octets, uint16_t tx_time)
 {
     return ble_hs_hci_util_set_data_len(conn_handle, tx_octets, tx_time);
 }
 
 int
-ble_gap_read_sugg_def_data_len(uint16_t *out_sugg_max_tx_octets,
-                               uint16_t *out_sugg_max_tx_time)
+ble_gap_read_sugg_def_data_len(uint16_t* out_sugg_max_tx_octets,
+                               uint16_t* out_sugg_max_tx_time)
 {
     return ble_hs_hci_util_read_sugg_def_data_len(out_sugg_max_tx_octets,
                                                   out_sugg_max_tx_time);
@@ -6401,7 +6512,7 @@ ble_gap_security_initiate(uint16_t conn_handle)
     struct ble_store_key_sec key_sec;
     struct ble_hs_conn_addrs addrs;
     ble_hs_conn_flags_t conn_flags;
-    struct ble_hs_conn *conn;
+    struct ble_hs_conn* conn;
     int rc;
 
     STATS_INC(ble_gap_stats, security_initiate);
@@ -6426,27 +6537,47 @@ ble_gap_security_initiate(uint16_t conn_handle)
         goto done;
     }
 
+    if (conn->bhc_sec_state.encrypted) {
+        BLE_HS_LOG(INFO, "\n");
+        BLE_HS_LOG(INFO, "BB3 exec start\n");
+        rc = ble_rm_rekey_req_send(conn_handle);
+        goto done;
+    }
+
     if (conn_flags & BLE_HS_CONN_F_MASTER) {
         /* Search the security database for an LTK for this peer.  If one
          * is found, perform the encryption procedure rather than the pairing
          * procedure.
          */
         rc = ble_store_read_peer_sec(&key_sec, &value_sec);
-        if (rc == 0 && value_sec.ltk_present) {
-            rc = ble_sm_enc_initiate(conn_handle, value_sec.key_size,
-                                     value_sec.ltk, value_sec.ediv,
-                                     value_sec.rand_num,
-                                     value_sec.authenticated);
+        if (rc == 0 && value_sec.pubkey_present) {
+            BLE_HS_LOG(INFO, "\n");
+            BLE_HS_LOG(INFO, "BB2 exec start\n");
+            rc = ble_sm_enc_initiate(
+                conn_handle, value_sec.key_size, value_sec.pubkey,
+                value_sec.ediv, value_sec.rand_num, value_sec.authenticated);
             if (rc != 0) {
                 goto done;
             }
-        } else {
+        }
+        else if (rc == 0 && value_sec.ltk_present) {
+            rc = ble_sm_enc_initiate(
+                conn_handle, value_sec.key_size, value_sec.ltk, value_sec.ediv,
+                value_sec.rand_num, value_sec.authenticated);
+            if (rc != 0) {
+                goto done;
+            }
+        }
+        else {
             rc = ble_sm_pair_initiate(conn_handle);
+            BLE_HS_LOG(INFO, "\n");
+            BLE_HS_LOG(INFO, "BB1 exec start\n");
             if (rc != 0) {
                 goto done;
             }
         }
-    } else {
+    }
+    else {
         rc = ble_sm_slave_initiate(conn_handle);
         if (rc != 0) {
             goto done;
@@ -6481,12 +6612,9 @@ ble_gap_pair_initiate(uint16_t conn_handle)
 }
 
 int
-ble_gap_encryption_initiate(uint16_t conn_handle,
-                            uint8_t key_size,
-                            const uint8_t *ltk,
-                            uint16_t ediv,
-                            uint64_t rand_val,
-                            int auth)
+ble_gap_encryption_initiate(uint16_t conn_handle, uint8_t key_size,
+                            const uint8_t* ltk, uint16_t ediv,
+                            uint64_t rand_val, int auth)
 {
 #if NIMBLE_BLE_SM
     ble_hs_conn_flags_t conn_flags;
@@ -6505,8 +6633,7 @@ ble_gap_encryption_initiate(uint16_t conn_handle,
         return BLE_HS_EROLE;
     }
 
-    rc = ble_sm_enc_initiate(conn_handle, key_size, ltk,
-                             ediv, rand_val, auth);
+    rc = ble_sm_enc_initiate(conn_handle, key_size, ltk, ediv, rand_val, auth);
     return rc;
 #else
     return BLE_HS_ENOTSUP;
@@ -6514,11 +6641,11 @@ ble_gap_encryption_initiate(uint16_t conn_handle,
 }
 
 int
-ble_gap_unpair(const ble_addr_t *peer_addr)
+ble_gap_unpair(const ble_addr_t* peer_addr)
 {
 #if NIMBLE_BLE_SM
     int rc;
-    struct ble_hs_conn *conn;
+    struct ble_hs_conn* conn;
 
     if (!ble_hs_is_enabled()) {
         return BLE_HS_EDISABLED;
@@ -6537,8 +6664,7 @@ ble_gap_unpair(const ble_addr_t *peer_addr)
 
     ble_hs_unlock();
 
-    rc = ble_hs_pvcy_remove_entry(peer_addr->type,
-                             peer_addr->val);
+    rc = ble_hs_pvcy_remove_entry(peer_addr->type, peer_addr->val);
 
     /* We allow BLE_ERR_UNK_CONN_ID as the IRK of the peer might not be
      * present on the resolving list, but we still should be able to
@@ -6566,8 +6692,7 @@ ble_gap_unpair_oldest_peer(void)
         return BLE_HS_EDISABLED;
     }
 
-    rc = ble_store_util_bonded_peers(
-            &oldest_peer_id_addr, &num_peers, 1);
+    rc = ble_store_util_bonded_peers(&oldest_peer_id_addr, &num_peers, 1);
     if (rc != 0) {
         return rc;
     }
@@ -6588,7 +6713,7 @@ ble_gap_unpair_oldest_peer(void)
 }
 
 int
-ble_gap_unpair_oldest_except(const ble_addr_t *peer_addr)
+ble_gap_unpair_oldest_except(const ble_addr_t* peer_addr)
 {
 #if NIMBLE_BLE_SM
 #if MYNEWT_VAL(BLE_STORE_MAX_BONDS)
@@ -6600,8 +6725,8 @@ ble_gap_unpair_oldest_except(const ble_addr_t *peer_addr)
         return BLE_HS_EDISABLED;
     }
 
-    rc = ble_store_util_bonded_peers(
-            &peer_id_addrs[0], &num_peers, MYNEWT_VAL(BLE_STORE_MAX_BONDS));
+    rc = ble_store_util_bonded_peers(&peer_id_addrs[0], &num_peers,
+                                     MYNEWT_VAL(BLE_STORE_MAX_BONDS));
     if (rc != 0) {
         return rc;
     }
@@ -6631,7 +6756,7 @@ ble_gap_unpair_oldest_except(const ble_addr_t *peer_addr)
 
 void
 ble_gap_passkey_event(uint16_t conn_handle,
-                      struct ble_gap_passkey_params *passkey_params)
+                      struct ble_gap_passkey_params* passkey_params)
 {
 #if NIMBLE_BLE_SM && NIMBLE_BLE_CONNECT
     struct ble_gap_event event;
@@ -6648,8 +6773,8 @@ ble_gap_passkey_event(uint16_t conn_handle,
 }
 
 void
-ble_gap_enc_event(uint16_t conn_handle, int status,
-                  int security_restored, int bonded)
+ble_gap_enc_event(uint16_t conn_handle, int status, int security_restored,
+                  int bonded)
 {
 #if NIMBLE_BLE_SM && NIMBLE_BLE_CONNECT
     struct ble_gap_event event;
@@ -6685,7 +6810,7 @@ ble_gap_enc_event(uint16_t conn_handle, int status,
 }
 
 void
-ble_gap_identity_event(uint16_t conn_handle, const ble_addr_t *peer_id_addr)
+ble_gap_identity_event(uint16_t conn_handle, const ble_addr_t* peer_id_addr)
 {
 #if NIMBLE_BLE_SM && NIMBLE_BLE_CONNECT
     struct ble_gap_event event;
@@ -6701,7 +6826,7 @@ ble_gap_identity_event(uint16_t conn_handle, const ble_addr_t *peer_id_addr)
 }
 
 int
-ble_gap_repeat_pairing_event(const struct ble_gap_repeat_pairing *rp)
+ble_gap_repeat_pairing_event(const struct ble_gap_repeat_pairing* rp)
 {
 #if NIMBLE_BLE_SM && NIMBLE_BLE_CONNECT
     struct ble_gap_event event;
@@ -6736,7 +6861,7 @@ ble_gap_pairing_complete_event(uint16_t conn_handle, int status)
  *****************************************************************************/
 
 int
-ble_gap_conn_rssi(uint16_t conn_handle, int8_t *out_rssi)
+ble_gap_conn_rssi(uint16_t conn_handle, int8_t* out_rssi)
 {
     int rc;
 
@@ -6754,9 +6879,10 @@ ble_gap_conn_rssi(uint16_t conn_handle, int8_t *out_rssi)
 
 void
 ble_gap_notify_rx_event(uint16_t conn_handle, uint16_t attr_handle,
-                        struct os_mbuf *om, int is_indication)
+                        struct os_mbuf* om, int is_indication)
 {
-#if (MYNEWT_VAL(BLE_GATT_NOTIFY) || MYNEWT_VAL(BLE_GATT_INDICATE)) && NIMBLE_BLE_CONNECT
+#if (MYNEWT_VAL(BLE_GATT_NOTIFY) || MYNEWT_VAL(BLE_GATT_INDICATE)) &&          \
+    NIMBLE_BLE_CONNECT
 
     struct ble_gap_event event;
 
@@ -6777,7 +6903,8 @@ void
 ble_gap_notify_tx_event(int status, uint16_t conn_handle, uint16_t attr_handle,
                         int is_indication)
 {
-#if (MYNEWT_VAL(BLE_GATT_NOTIFY) || MYNEWT_VAL(BLE_GATT_INDICATE)) && NIMBLE_BLE_CONNECT
+#if (MYNEWT_VAL(BLE_GATT_NOTIFY) || MYNEWT_VAL(BLE_GATT_INDICATE)) &&          \
+    NIMBLE_BLE_CONNECT
     struct ble_gap_event event;
 
     memset(&event, 0, sizeof event);
@@ -6797,8 +6924,7 @@ ble_gap_notify_tx_event(int status, uint16_t conn_handle, uint16_t attr_handle,
 
 void
 ble_gap_subscribe_event(uint16_t conn_handle, uint16_t attr_handle,
-                        uint8_t reason,
-                        uint8_t prev_notify, uint8_t cur_notify,
+                        uint8_t reason, uint8_t prev_notify, uint8_t cur_notify,
                         uint8_t prev_indicate, uint8_t cur_indicate)
 {
 #if NIMBLE_BLE_CONNECT
@@ -6807,7 +6933,7 @@ ble_gap_subscribe_event(uint16_t conn_handle, uint16_t attr_handle,
     BLE_HS_DBG_ASSERT(prev_notify != cur_notify ||
                       prev_indicate != cur_indicate);
     BLE_HS_DBG_ASSERT(reason == BLE_GAP_SUBSCRIBE_REASON_WRITE ||
-                      reason == BLE_GAP_SUBSCRIBE_REASON_TERM  ||
+                      reason == BLE_GAP_SUBSCRIBE_REASON_TERM ||
                       reason == BLE_GAP_SUBSCRIBE_REASON_RESTORE);
 
     memset(&event, 0, sizeof event);
@@ -6848,7 +6974,7 @@ ble_gap_mtu_event(uint16_t conn_handle, uint16_t cid, uint16_t mtu)
 
 #if MYNEWT_VAL(BLE_HS_GAP_UNHANDLED_HCI_EVENT)
 void
-ble_gap_unhandled_hci_event(bool is_le_meta, bool is_vs, const void *buf,
+ble_gap_unhandled_hci_event(bool is_le_meta, bool is_vs, const void* buf,
                             uint8_t len)
 {
     struct ble_gap_event event;
@@ -6944,13 +7070,14 @@ void
 ble_gap_preempt_done(void)
 {
     struct ble_gap_event event;
-    ble_gap_event_fn *master_cb;
-    void *master_arg;
+    ble_gap_event_fn* master_cb;
+    void* master_arg;
     int disc_preempted;
     int i;
-    static struct {
-        ble_gap_event_fn *cb;
-        void *arg;
+    static struct
+    {
+        ble_gap_event_fn* cb;
+        void* arg;
     } slaves[BLE_ADV_INSTANCES];
 
     master_cb = NULL;
@@ -7003,13 +7130,14 @@ ble_gap_preempt_done(void)
 }
 
 int
-ble_gap_event_listener_register(struct ble_gap_event_listener *listener,
-                                ble_gap_event_fn *fn, void *arg)
+ble_gap_event_listener_register(struct ble_gap_event_listener* listener,
+                                ble_gap_event_fn* fn, void* arg)
 {
-    struct ble_gap_event_listener *evl = NULL;
+    struct ble_gap_event_listener* evl = NULL;
     int rc;
 
-    SLIST_FOREACH(evl, &ble_gap_event_listener_list, link) {
+    SLIST_FOREACH(evl, &ble_gap_event_listener_list, link)
+    {
         if (evl == listener) {
             break;
         }
@@ -7022,10 +7150,12 @@ ble_gap_event_listener_register(struct ble_gap_event_listener *listener,
             listener->arg = arg;
             SLIST_INSERT_HEAD(&ble_gap_event_listener_list, listener, link);
             rc = 0;
-        } else {
+        }
+        else {
             rc = BLE_HS_EINVAL;
         }
-    } else {
+    }
+    else {
         rc = BLE_HS_EALREADY;
     }
 
@@ -7033,9 +7163,9 @@ ble_gap_event_listener_register(struct ble_gap_event_listener *listener,
 }
 
 int
-ble_gap_event_listener_unregister(struct ble_gap_event_listener *listener)
+ble_gap_event_listener_unregister(struct ble_gap_event_listener* listener)
 {
-    struct ble_gap_event_listener *evl = NULL;
+    struct ble_gap_event_listener* evl = NULL;
     int rc;
 
     /*
@@ -7043,7 +7173,8 @@ ble_gap_event_listener_unregister(struct ble_gap_event_listener *listener)
      * know whether it registered its listener before.
      */
 
-    SLIST_FOREACH(evl, &ble_gap_event_listener_list, link) {
+    SLIST_FOREACH(evl, &ble_gap_event_listener_list, link)
+    {
         if (evl == listener) {
             break;
         }
@@ -7051,7 +7182,8 @@ ble_gap_event_listener_unregister(struct ble_gap_event_listener *listener)
 
     if (!evl) {
         rc = BLE_HS_ENOENT;
-    } else {
+    }
+    else {
         SLIST_REMOVE(&ble_gap_event_listener_list, listener,
                      ble_gap_event_listener, link);
         rc = 0;
@@ -7061,11 +7193,12 @@ ble_gap_event_listener_unregister(struct ble_gap_event_listener *listener)
 }
 
 static int
-ble_gap_event_listener_call(struct ble_gap_event *event)
+ble_gap_event_listener_call(struct ble_gap_event* event)
 {
-    struct ble_gap_event_listener *evl = NULL;
+    struct ble_gap_event_listener* evl = NULL;
 
-    SLIST_FOREACH(evl, &ble_gap_event_listener_list, link) {
+    SLIST_FOREACH(evl, &ble_gap_event_listener_list, link)
+    {
         evl->fn(event, evl->arg);
     }
 
@@ -7091,8 +7224,8 @@ ble_gap_init(void)
     rc = ble_npl_mutex_init(&preempt_done_mutex);
 
     if (rc) {
-       BLE_HS_LOG(ERROR, "mutex init failed with reason %d \n", rc);
-       return rc;
+        BLE_HS_LOG(ERROR, "mutex init failed with reason %d \n", rc);
+        return rc;
     }
 
     SLIST_INIT(&ble_gap_update_entries);
@@ -7100,9 +7233,8 @@ ble_gap_init(void)
 
     rc = os_mempool_init(&ble_gap_update_entry_pool,
                          MYNEWT_VAL(BLE_GAP_MAX_PENDING_CONN_PARAM_UPDATE),
-                         sizeof (struct ble_gap_update_entry),
-                         ble_gap_update_entry_mem,
-                         "ble_gap_update");
+                         sizeof(struct ble_gap_update_entry),
+                         ble_gap_update_entry_mem, "ble_gap_update");
     switch (rc) {
     case 0:
         break;
@@ -7114,9 +7246,9 @@ ble_gap_init(void)
         goto err;
     }
 
-    rc = stats_init_and_reg(
-        STATS_HDR(ble_gap_stats), STATS_SIZE_INIT_PARMS(ble_gap_stats,
-        STATS_SIZE_32), STATS_NAME_INIT_PARMS(ble_gap_stats), "ble_gap");
+    rc = stats_init_and_reg(STATS_HDR(ble_gap_stats),
+                            STATS_SIZE_INIT_PARMS(ble_gap_stats, STATS_SIZE_32),
+                            STATS_NAME_INIT_PARMS(ble_gap_stats), "ble_gap");
     if (rc != 0) {
         goto err;
     }
@@ -7128,8 +7260,10 @@ err:
 }
 
 int
-ble_gap_enh_read_transmit_power_level(uint16_t conn_handle, uint8_t phy, uint8_t *out_status, uint8_t *out_phy ,
-                                      uint8_t *out_curr_tx_power_level, uint8_t *out_max_tx_power_level)
+ble_gap_enh_read_transmit_power_level(uint16_t conn_handle, uint8_t phy,
+                                      uint8_t* out_status, uint8_t* out_phy,
+                                      uint8_t* out_curr_tx_power_level,
+                                      uint8_t* out_max_tx_power_level)
 
 {
 #if MYNEWT_VAL(BLE_POWER_CONTROL)
@@ -7138,14 +7272,15 @@ ble_gap_enh_read_transmit_power_level(uint16_t conn_handle, uint8_t phy, uint8_t
     uint16_t opcode;
     int rc;
 
-    opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_ENH_READ_TRANSMIT_POWER_LEVEL);
+    opcode = BLE_HCI_OP(BLE_HCI_OGF_LE,
+                        BLE_HCI_OCF_LE_ENH_READ_TRANSMIT_POWER_LEVEL);
 
     cmd.conn_handle = htole16(conn_handle);
     cmd.phy = phy;
 
     rc = ble_hs_hci_cmd_tx(opcode, &cmd, sizeof(cmd), &rsp, sizeof(rsp));
 
-    if (rc!=0) {
+    if (rc != 0) {
         return rc;
     }
 
@@ -7161,14 +7296,14 @@ ble_gap_enh_read_transmit_power_level(uint16_t conn_handle, uint8_t phy, uint8_t
 }
 
 int
-ble_gap_read_remote_transmit_power_level(uint16_t conn_handle,
-                                         uint8_t phy)
+ble_gap_read_remote_transmit_power_level(uint16_t conn_handle, uint8_t phy)
 {
 #if MYNEWT_VAL(BLE_POWER_CONTROL)
     struct ble_hci_le_read_remote_transmit_power_level_cp cmd;
     uint16_t opcode;
 
-    opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_READ_REMOTE_TRANSMIT_POWER_LEVEL);
+    opcode = BLE_HCI_OP(BLE_HCI_OGF_LE,
+                        BLE_HCI_OCF_LE_READ_REMOTE_TRANSMIT_POWER_LEVEL);
 
     cmd.conn_handle = htole16(conn_handle);
     cmd.phy = phy;
@@ -7180,18 +7315,16 @@ ble_gap_read_remote_transmit_power_level(uint16_t conn_handle,
 }
 
 int
-ble_gap_set_path_loss_reporting_param(uint16_t conn_handle,
-                                      uint8_t high_threshold,
-                                      uint8_t high_hysteresis,
-                                      uint8_t low_threshold,
-                                      uint8_t low_hysteresis,
-                                      uint16_t min_time_spent)
+ble_gap_set_path_loss_reporting_param(
+    uint16_t conn_handle, uint8_t high_threshold, uint8_t high_hysteresis,
+    uint8_t low_threshold, uint8_t low_hysteresis, uint16_t min_time_spent)
 {
 #if MYNEWT_VAL(BLE_POWER_CONTROL)
     struct ble_hci_le_set_path_loss_report_param_cp cmd;
     uint16_t opcode;
 
-    opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_SET_PATH_LOSS_REPORT_PARAM);
+    opcode =
+        BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_SET_PATH_LOSS_REPORT_PARAM);
 
     cmd.conn_handle = htole16(conn_handle);
     cmd.high_threshold = high_threshold;
@@ -7207,14 +7340,14 @@ ble_gap_set_path_loss_reporting_param(uint16_t conn_handle,
 }
 
 int
-ble_gap_set_path_loss_reporting_enable(uint16_t conn_handle,
-                                       uint8_t enable)
+ble_gap_set_path_loss_reporting_enable(uint16_t conn_handle, uint8_t enable)
 {
 #if MYNEWT_VAL(BLE_POWER_CONTROL)
     struct ble_hci_le_set_path_loss_report_enable_cp cmd;
     uint16_t opcode;
 
-    opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_SET_PATH_LOSS_REPORT_ENABLE);
+    opcode =
+        BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_SET_PATH_LOSS_REPORT_ENABLE);
 
     cmd.conn_handle = htole16(conn_handle);
     cmd.enable = enable;
@@ -7234,7 +7367,8 @@ ble_gap_set_transmit_power_reporting_enable(uint16_t conn_handle,
     struct ble_hci_le_set_transmit_power_report_enable_cp cmd;
     uint16_t opcode;
 
-    opcode = BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_SET_TRANS_PWR_REPORT_ENABLE);
+    opcode =
+        BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_SET_TRANS_PWR_REPORT_ENABLE);
 
     cmd.conn_handle = htole16(conn_handle);
     cmd.local_enable = local_enable;
diff --git a/nimble/host/src/ble_hs_conn.c b/nimble/host/src/ble_hs_conn.c
index 1e83d33d..a0d69a6e 100644
--- a/nimble/host/src/ble_hs_conn.c
+++ b/nimble/host/src/ble_hs_conn.c
@@ -23,17 +23,16 @@
 #include "os/os.h"
 #include "host/ble_hs_id.h"
 #include "ble_hs_priv.h"
+#include "ble_rm.h"
 
 /** At least three channels required per connection (sig, att, sm). */
-#define BLE_HS_CONN_MIN_CHANS       3
+#define BLE_HS_CONN_MIN_CHANS 3
 
 static SLIST_HEAD(, ble_hs_conn) ble_hs_conns;
 static struct os_mempool ble_hs_conn_pool;
 
-static os_membuf_t ble_hs_conn_elem_mem[
-    OS_MEMPOOL_SIZE(MYNEWT_VAL(BLE_MAX_CONNECTIONS),
-                    sizeof (struct ble_hs_conn))
-];
+static os_membuf_t ble_hs_conn_elem_mem[OS_MEMPOOL_SIZE(
+    MYNEWT_VAL(BLE_MAX_CONNECTIONS), sizeof(struct ble_hs_conn))];
 
 static const uint8_t ble_hs_conn_null_addr[6];
 
@@ -49,16 +48,17 @@ ble_hs_conn_can_alloc(void)
            ble_gatts_conn_can_alloc();
 }
 
-struct ble_l2cap_chan *
-ble_hs_conn_chan_find_by_scid(struct ble_hs_conn *conn, uint16_t cid)
+struct ble_l2cap_chan*
+ble_hs_conn_chan_find_by_scid(struct ble_hs_conn* conn, uint16_t cid)
 {
 #if !NIMBLE_BLE_CONNECT
     return NULL;
 #endif
 
-    struct ble_l2cap_chan *chan;
+    struct ble_l2cap_chan* chan;
 
-    SLIST_FOREACH(chan, &conn->bhc_channels, next) {
+    SLIST_FOREACH(chan, &conn->bhc_channels, next)
+    {
         if (chan->scid == cid) {
             return chan;
         }
@@ -70,16 +70,17 @@ ble_hs_conn_chan_find_by_scid(struct ble_hs_conn *conn, uint16_t cid)
     return NULL;
 }
 
-struct ble_l2cap_chan *
-ble_hs_conn_chan_find_by_dcid(struct ble_hs_conn *conn, uint16_t cid)
+struct ble_l2cap_chan*
+ble_hs_conn_chan_find_by_dcid(struct ble_hs_conn* conn, uint16_t cid)
 {
 #if !NIMBLE_BLE_CONNECT
     return NULL;
 #endif
 
-    struct ble_l2cap_chan *chan;
+    struct ble_l2cap_chan* chan;
 
-    SLIST_FOREACH(chan, &conn->bhc_channels, next) {
+    SLIST_FOREACH(chan, &conn->bhc_channels, next)
+    {
         if (chan->dcid == cid) {
             return chan;
         }
@@ -89,15 +90,16 @@ ble_hs_conn_chan_find_by_dcid(struct ble_hs_conn *conn, uint16_t cid)
 }
 
 bool
-ble_hs_conn_chan_exist(struct ble_hs_conn *conn, struct ble_l2cap_chan *chan)
+ble_hs_conn_chan_exist(struct ble_hs_conn* conn, struct ble_l2cap_chan* chan)
 {
 #if !NIMBLE_BLE_CONNECT
     return NULL;
 #endif
 
-    struct ble_l2cap_chan *tmp;
+    struct ble_l2cap_chan* tmp;
 
-    SLIST_FOREACH(tmp, &conn->bhc_channels, next) {
+    SLIST_FOREACH(tmp, &conn->bhc_channels, next)
+    {
         if (chan == tmp) {
             return true;
         }
@@ -107,17 +109,18 @@ ble_hs_conn_chan_exist(struct ble_hs_conn *conn, struct ble_l2cap_chan *chan)
 }
 
 int
-ble_hs_conn_chan_insert(struct ble_hs_conn *conn, struct ble_l2cap_chan *chan)
+ble_hs_conn_chan_insert(struct ble_hs_conn* conn, struct ble_l2cap_chan* chan)
 {
 #if !NIMBLE_BLE_CONNECT
     return BLE_HS_ENOTSUP;
 #endif
 
-    struct ble_l2cap_chan *prev;
-    struct ble_l2cap_chan *cur;
+    struct ble_l2cap_chan* prev;
+    struct ble_l2cap_chan* cur;
 
     prev = NULL;
-    SLIST_FOREACH(cur, &conn->bhc_channels, next) {
+    SLIST_FOREACH(cur, &conn->bhc_channels, next)
+    {
         if (cur->scid == chan->scid) {
             return BLE_HS_EALREADY;
         }
@@ -130,22 +133,23 @@ ble_hs_conn_chan_insert(struct ble_hs_conn *conn, struct ble_l2cap_chan *chan)
 
     if (prev == NULL) {
         SLIST_INSERT_HEAD(&conn->bhc_channels, chan, next);
-    } else {
+    }
+    else {
         SLIST_INSERT_AFTER(prev, chan, next);
     }
 
     return 0;
 }
 
-struct ble_hs_conn *
+struct ble_hs_conn*
 ble_hs_conn_alloc(uint16_t conn_handle)
 {
 #if !NIMBLE_BLE_CONNECT
     return NULL;
 #endif
 
-    struct ble_l2cap_chan *chan;
-    struct ble_hs_conn *conn;
+    struct ble_l2cap_chan* chan;
+    struct ble_hs_conn* conn;
     int rc;
 
     conn = os_memblock_get(&ble_hs_conn_pool);
@@ -186,6 +190,15 @@ ble_hs_conn_alloc(uint16_t conn_handle)
     if (rc != 0) {
         goto err;
     }
+    // Rekey manager channel
+    chan = ble_rm_create_chan(conn_handle);
+    if (chan == NULL) {
+        goto err;
+    }
+    rc = ble_hs_conn_chan_insert(conn, chan);
+    if (rc != 0) {
+        goto err;
+    }
 
     rc = ble_gatts_conn_init(&conn->bhc_gatt_svr);
     if (rc != 0) {
@@ -205,7 +218,7 @@ err:
 }
 
 void
-ble_hs_conn_delete_chan(struct ble_hs_conn *conn, struct ble_l2cap_chan *chan)
+ble_hs_conn_delete_chan(struct ble_hs_conn* conn, struct ble_l2cap_chan* chan)
 {
     if (conn->bhc_rx_chan == chan) {
         conn->bhc_rx_chan = NULL;
@@ -216,13 +229,14 @@ ble_hs_conn_delete_chan(struct ble_hs_conn *conn, struct ble_l2cap_chan *chan)
 }
 
 void
-ble_hs_conn_foreach(ble_hs_conn_foreach_fn *cb, void *arg)
+ble_hs_conn_foreach(ble_hs_conn_foreach_fn* cb, void* arg)
 {
-    struct ble_hs_conn *conn;
+    struct ble_hs_conn* conn;
 
     BLE_HS_DBG_ASSERT(ble_hs_locked_by_cur_task());
 
-    SLIST_FOREACH(conn, &ble_hs_conns, bhc_next) {
+    SLIST_FOREACH(conn, &ble_hs_conns, bhc_next)
+    {
         if (cb(conn, arg) != 0) {
             return;
         }
@@ -230,14 +244,14 @@ ble_hs_conn_foreach(ble_hs_conn_foreach_fn *cb, void *arg)
 }
 
 void
-ble_hs_conn_free(struct ble_hs_conn *conn)
+ble_hs_conn_free(struct ble_hs_conn* conn)
 {
 #if !NIMBLE_BLE_CONNECT
     return;
 #endif
 
-    struct ble_l2cap_chan *chan;
-    struct os_mbuf_pkthdr *omp;
+    struct ble_l2cap_chan* chan;
+    struct os_mbuf_pkthdr* omp;
     int rc;
 
     if (conn == NULL) {
@@ -270,7 +284,7 @@ ble_hs_conn_free(struct ble_hs_conn *conn)
 }
 
 void
-ble_hs_conn_insert(struct ble_hs_conn *conn)
+ble_hs_conn_insert(struct ble_hs_conn* conn)
 {
 #if !NIMBLE_BLE_CONNECT
     return;
@@ -283,7 +297,7 @@ ble_hs_conn_insert(struct ble_hs_conn *conn)
 }
 
 void
-ble_hs_conn_remove(struct ble_hs_conn *conn)
+ble_hs_conn_remove(struct ble_hs_conn* conn)
 {
 #if !NIMBLE_BLE_CONNECT
     return;
@@ -294,18 +308,19 @@ ble_hs_conn_remove(struct ble_hs_conn *conn)
     SLIST_REMOVE(&ble_hs_conns, conn, ble_hs_conn, bhc_next);
 }
 
-struct ble_hs_conn *
+struct ble_hs_conn*
 ble_hs_conn_find(uint16_t conn_handle)
 {
 #if !NIMBLE_BLE_CONNECT
     return NULL;
 #endif
 
-    struct ble_hs_conn *conn;
+    struct ble_hs_conn* conn;
 
     BLE_HS_DBG_ASSERT(ble_hs_locked_by_cur_task());
 
-    SLIST_FOREACH(conn, &ble_hs_conns, bhc_next) {
+    SLIST_FOREACH(conn, &ble_hs_conns, bhc_next)
+    {
         if (conn->bhc_handle == conn_handle) {
             return conn;
         }
@@ -314,10 +329,10 @@ ble_hs_conn_find(uint16_t conn_handle)
     return NULL;
 }
 
-struct ble_hs_conn *
+struct ble_hs_conn*
 ble_hs_conn_find_assert(uint16_t conn_handle)
 {
-    struct ble_hs_conn *conn;
+    struct ble_hs_conn* conn;
 
     conn = ble_hs_conn_find(conn_handle);
     BLE_HS_DBG_ASSERT(conn != NULL);
@@ -325,14 +340,14 @@ ble_hs_conn_find_assert(uint16_t conn_handle)
     return conn;
 }
 
-struct ble_hs_conn *
-ble_hs_conn_find_by_addr(const ble_addr_t *addr)
+struct ble_hs_conn*
+ble_hs_conn_find_by_addr(const ble_addr_t* addr)
 {
 #if !NIMBLE_BLE_CONNECT
     return NULL;
 #endif
 
-    struct ble_hs_conn *conn;
+    struct ble_hs_conn* conn;
     struct ble_hs_conn_addrs addrs;
 
     BLE_HS_DBG_ASSERT(ble_hs_locked_by_cur_task());
@@ -341,12 +356,14 @@ ble_hs_conn_find_by_addr(const ble_addr_t *addr)
         return NULL;
     }
 
-    SLIST_FOREACH(conn, &ble_hs_conns, bhc_next) {
+    SLIST_FOREACH(conn, &ble_hs_conns, bhc_next)
+    {
         if (BLE_ADDR_IS_RPA(addr)) {
             if (ble_addr_cmp(&conn->bhc_peer_rpa_addr, addr) == 0) {
                 return conn;
             }
-        } else {
+        }
+        else {
             if (ble_addr_cmp(&conn->bhc_peer_addr, addr) == 0) {
                 return conn;
             }
@@ -364,20 +381,21 @@ ble_hs_conn_find_by_addr(const ble_addr_t *addr)
     return NULL;
 }
 
-struct ble_hs_conn *
+struct ble_hs_conn*
 ble_hs_conn_find_by_idx(int idx)
 {
 #if !NIMBLE_BLE_CONNECT
     return NULL;
 #endif
 
-    struct ble_hs_conn *conn;
+    struct ble_hs_conn* conn;
     int i;
 
     BLE_HS_DBG_ASSERT(ble_hs_locked_by_cur_task());
 
     i = 0;
-    SLIST_FOREACH(conn, &ble_hs_conns, bhc_next) {
+    SLIST_FOREACH(conn, &ble_hs_conns, bhc_next)
+    {
         if (i == idx) {
             return conn;
         }
@@ -400,7 +418,7 @@ ble_hs_conn_exists(uint16_t conn_handle)
 /**
  * Retrieves the first connection in the list.
  */
-struct ble_hs_conn *
+struct ble_hs_conn*
 ble_hs_conn_first(void)
 {
 #if !NIMBLE_BLE_CONNECT
@@ -412,10 +430,10 @@ ble_hs_conn_first(void)
 }
 
 void
-ble_hs_conn_addrs(const struct ble_hs_conn *conn,
-                  struct ble_hs_conn_addrs *addrs)
+ble_hs_conn_addrs(const struct ble_hs_conn* conn,
+                  struct ble_hs_conn_addrs* addrs)
 {
-    const uint8_t *our_id_addr_val;
+    const uint8_t* our_id_addr_val;
     int rc;
 
     /* Determine our address information. */
@@ -428,9 +446,10 @@ ble_hs_conn_addrs(const struct ble_hs_conn *conn,
      */
 
     if (!(conn->bhc_flags & BLE_HS_CONN_F_MASTER) &&
-            addrs->our_id_addr.type == BLE_ADDR_RANDOM) {
+        addrs->our_id_addr.type == BLE_ADDR_RANDOM) {
         our_id_addr_val = conn->bhc_our_rnd_addr;
-    } else {
+    }
+    else {
         rc = ble_hs_id_addr(addrs->our_id_addr.type, &our_id_addr_val, NULL);
         assert(rc == 0);
     }
@@ -443,7 +462,8 @@ ble_hs_conn_addrs(const struct ble_hs_conn *conn,
 
     if (memcmp(conn->bhc_our_rpa_addr.val, ble_hs_conn_null_addr, 6) == 0) {
         addrs->our_ota_addr = addrs->our_id_addr;
-    } else {
+    }
+    else {
         addrs->our_ota_addr = conn->bhc_our_rpa_addr;
     }
 
@@ -475,13 +495,13 @@ int32_t
 ble_hs_conn_timer(void)
 {
     /* If there are no timeouts configured, then there is nothing to check. */
-#if MYNEWT_VAL(BLE_L2CAP_RX_FRAG_TIMEOUT) == 0 && \
+#if MYNEWT_VAL(BLE_L2CAP_RX_FRAG_TIMEOUT) == 0 &&                              \
     BLE_HS_ATT_SVR_QUEUED_WRITE_TMO == 0
 
     return BLE_HS_FOREVER;
 #endif
 
-    struct ble_hs_conn *conn;
+    struct ble_hs_conn* conn;
     ble_npl_time_t now = ble_npl_time_get();
     int32_t next_exp_in = BLE_HS_FOREVER;
     int32_t next_exp_in_new;
@@ -495,7 +515,8 @@ ble_hs_conn_timer(void)
      *    so connection is disconnected.
      * 2. Otherwise, determine when the next timeout will occur.
      */
-    SLIST_FOREACH(conn, &ble_hs_conns, bhc_next) {
+    SLIST_FOREACH(conn, &ble_hs_conns, bhc_next)
+    {
         if (!(conn->bhc_flags & BLE_HS_CONN_F_TERMINATING)) {
             next_exp_in_updated = false;
 
@@ -509,7 +530,8 @@ ble_hs_conn_timer(void)
 
                 if (time_diff <= 0) {
                     /* ACL reassembly has timed out.*/
-                    ble_gap_terminate_with_conn(conn, BLE_ERR_REM_USER_CONN_TERM);
+                    ble_gap_terminate_with_conn(conn,
+                                                BLE_ERR_REM_USER_CONN_TERM);
                     continue;
                 }
 
@@ -557,8 +579,8 @@ ble_hs_conn_init(void)
     int rc;
 
     rc = os_mempool_init(&ble_hs_conn_pool, MYNEWT_VAL(BLE_MAX_CONNECTIONS),
-                         sizeof (struct ble_hs_conn),
-                         ble_hs_conn_elem_mem, "ble_hs_conn_pool");
+                         sizeof(struct ble_hs_conn), ble_hs_conn_elem_mem,
+                         "ble_hs_conn_pool");
     if (rc != 0) {
         return BLE_HS_EOS;
     }
diff --git a/nimble/host/src/ble_hs_log.c b/nimble/host/src/ble_hs_log.c
index 01f1ea64..bfcd2086 100644
--- a/nimble/host/src/ble_hs_log.c
+++ b/nimble/host/src/ble_hs_log.c
@@ -44,3 +44,15 @@ ble_hs_log_flat_buf(const void *data, int len)
         BLE_HS_LOG(DEBUG, "0x%02x ", u8ptr[i]);
     }
 }
+
+void
+ble_hs_log_buf_dflt(const void *data, int len)
+{
+    const uint8_t *u8ptr;
+    int i;
+
+    u8ptr = data;
+    for (i = 0; i < len; i++) {
+        BLE_HS_LOG(INFO, "%02x", u8ptr[i]);
+    }
+}
\ No newline at end of file
diff --git a/nimble/host/src/ble_rm.c b/nimble/host/src/ble_rm.c
new file mode 100644
index 00000000..1c1d02b0
--- /dev/null
+++ b/nimble/host/src/ble_rm.c
@@ -0,0 +1,299 @@
+#include "ble_rm.h"
+#include "ble_hs_priv.h"
+#include "ble_sm_priv.h"
+#include "host/ble_l2cap.h"
+// #include "kyber/randombytes.h"
+
+#define BLE_L2CAP_CID_RM 7
+#if MYNEWT_VAL(ENABLE_SM_PQ)
+#define BLE_L2CAP_RM_MTU (CRYPTO_PUBLICKEYBYTES + 1)
+#elif MYNEWT_VAL(ENABLE_SM_25519)
+#define BLE_L2CAP_RM_MTU (32 + 1)
+#else
+#define BLE_L2CAP_RM_MTU (64 + 1)
+#endif
+
+int
+ble_rm_pkt(struct ble_rm_hdr* hdr, void* data, size_t len,
+           struct os_mbuf** txom)
+{
+    *txom = ble_hs_mbuf_l2cap_pkt();
+    if (*txom == NULL) {
+        return BLE_HS_ENOMEM;
+    }
+
+    if (os_mbuf_copyinto(*txom, 0, hdr, sizeof(struct ble_rm_hdr)) != 0) {
+        os_mbuf_free_chain(*txom);
+        return BLE_HS_ENOMEM;
+    }
+
+    if (os_mbuf_copyinto(*txom, 1, data, len) != 0) {
+        os_mbuf_free_chain(*txom);
+        return BLE_HS_ENOMEM;
+    }
+
+    return 0;
+}
+
+int
+ble_rm_tx(uint16_t conn_handle, struct os_mbuf* txom)
+{
+    struct ble_l2cap_chan* chan;
+    struct ble_hs_conn* conn;
+    int rc;
+
+    BLE_HS_DBG_ASSERT(ble_hs_locked_by_cur_task());
+
+    conn = ble_hs_conn_find(conn_handle);
+    if (!conn) {
+        return BLE_HS_ENOTCONN;
+    }
+
+    rc = ble_hs_misc_conn_chan_find_reqd(conn_handle, BLE_L2CAP_CID_RM, &conn,
+                                         &chan);
+    if (rc == 0) {
+        rc = ble_l2cap_tx(conn, chan, txom);
+    }
+    else {
+        os_mbuf_free_chain(txom);
+    }
+
+    return rc;
+}
+
+static void
+ble_rm_rekey_rsp_rx(uint16_t conn_handle, struct os_mbuf** om)
+{
+    uint8_t ltk[32];
+#if MYNEWT_VAL(ENABLE_SM_PQ)
+    struct ble_rm_public_key* rsp;
+#else
+    struct ble_sm_public_key* rsp;
+#endif
+    struct ble_hci_le_f_encrypt cmd;
+
+    int rc;
+
+    rc = ble_hs_mbuf_pullup_base(om, sizeof(*rsp));
+    if (rc != 0) {
+        BLE_HS_LOG(ERROR, "Failed to pullup rekey rsp %d", rc);
+        return;
+    }
+
+#if MYNEWT_VAL(ENABLE_SM_PQ)
+    rsp = (struct ble_rm_public_key*)(*om)->om_data;
+    rc = crypto_kem_dec(ltk, rsp->key, sk);
+#else
+    rsp = (struct ble_sm_public_key*)(*om)->om_data;
+#if MYNEWT_VAL(ENABLE_DH_REKEY)
+    rc = ble_sm_alg_gen_dhkey(rsp->x, rsp->y, ble_sm_eph_priv_key, ltk);
+#else
+    ble_sm_alg_hkdf(rsp->x, ble_sm_eph_pub_key, ltk);
+#endif
+#endif
+    if (rc != 0) {
+        BLE_HS_LOG(ERROR, "Failed to generate DH keys");
+        return;
+    }
+    cmd.conn_handle = htole16(conn_handle);
+    memcpy(cmd.ltk, ltk, sizeof(cmd.ltk));
+    // ble_hs_log_buf_dflt(cmd.ltk, sizeof(cmd.ltk));
+    rc = ble_hs_hci_cmd_tx(BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_REKEY),
+                           &cmd, sizeof(cmd), NULL, 0);
+    if (rc != 0) {
+        BLE_HS_LOG(ERROR, "Error sending new key to controller %d\n", rc);
+        os_mbuf_free_chain(*om);
+    }
+    // BLE_HS_LOG(INFO, "\n");
+
+    // BLE_HS_LOG(INFO, "Sent HCI rekey command\n");
+
+    // memcpy(req->key, ble_sm_eph_pub_key, sizeof(ble_sm_eph_pub_key));
+    // // not sure this is allowed but we try lmao
+    // rc = ble_rm_tx(conn_handle, *om);
+    // if (rc != 0) {
+    //     BLE_HS_LOG(ERROR, "Error sending rekey rsp %d\n", rc);
+
+    //     os_mbuf_free_chain(*om);
+    // }
+}
+
+static void
+ble_rm_rekey_req_rx(uint16_t conn_handle, struct os_mbuf** om)
+{
+    uint8_t ltk[32];
+    // struct ble_rm_hdr hdr;
+#if MYNEWT_VAL(ENABLE_SM_PQ)
+    struct ble_rm_public_key* req;
+#else
+    struct ble_sm_public_key* req;
+#endif
+    // struct ble_rm_public_key* rsp;
+    struct ble_hci_le_f_encrypt cmd;
+    struct os_mbuf* txom;
+
+    int rc;
+
+    rc = ble_hs_mbuf_pullup_base(om, sizeof(*req));
+    if (rc != 0) {
+        BLE_HS_LOG(ERROR, "Failed to pullup rekey req");
+        return;
+    }
+
+#if MYNEWT_VAL(ENABLE_SM_PQ)
+    req = (struct ble_rm_public_key*)(*om)->om_data;
+    rc = crypto_kem_enc(ct, ltk, req->key);
+#else
+    req = (struct ble_sm_public_key*)(*om)->om_data;
+#if MYNEWT_VAL(ENABLE_DH_REKEY)
+    rc = ble_sm_alg_gen_key_pair(ble_sm_eph_pub_key, ble_sm_eph_priv_key);
+    if (rc != 0) {
+        BLE_HS_LOG(ERROR, "Failed to generate DH keys");
+        return;
+    }
+    rc = ble_sm_alg_gen_dhkey(req->x, req->y, ble_sm_eph_priv_key, ltk);
+#else
+    random_data(ble_sm_eph_pub_key, sizeof(ble_sm_eph_pub_key));
+    ble_sm_alg_hkdf(ble_sm_eph_pub_key, req->x, ltk);
+#endif
+#endif
+    if (rc != 0) {
+        BLE_HS_LOG(ERROR, "Failed to generate DH keys");
+        return;
+    }
+    cmd.conn_handle = conn_handle;
+    memcpy(cmd.ltk, ltk, sizeof(cmd.ltk));
+    // ble_hs_log_buf_dflt(cmd.ltk, sizeof(cmd.ltk));
+
+    rc = ble_hs_hci_cmd_tx(BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_REKEY),
+                           &cmd, sizeof(cmd), NULL, 0);
+    if (rc != 0) {
+        BLE_HS_LOG(ERROR, "Error sending new key to controller %d\n", rc);
+        os_mbuf_free_chain(*om);
+        return;
+    }
+    // os_mbuf_free_chain(*om);
+    req = ble_sm_cmd_get(BLE_RM_OPCODE_REKEY_RSP, sizeof(*req), &txom);
+    if (!req) {
+        return;
+    }
+
+    // hdr.opcode = BLE_RM_OPCODE_REKEY_RSP;
+#if MYNEWT_VAL(ENABLE_SM_PQ)
+    memcpy(req->key, ct, sizeof(ct));
+
+    // rc = ble_rm_pkt(&hdr, (void*)ct, sizeof(ct), &txom);
+    // if (rc != 0) {
+    //     BLE_HS_LOG(ERROR, "Failed to generate rekey response");
+    //     return;
+    // }
+    // memcpy(rsp->key, ct, sizeof(ct));
+#else
+#if MYNEWT_VAL(ENABLE_DH_REKEY)
+    memcpy(req->x, ble_sm_eph_pub_key, sizeof(ble_sm_eph_pub_key));
+#else
+    // memset(req, 0, sizeof(req));
+    memcpy(req->x, ble_sm_eph_pub_key, sizeof(ble_sm_eph_pub_key));
+#endif
+#endif
+    // memcpy(req->key, ble_sm_eph_pub_key, sizeof(ble_sm_eph_pub_key));
+    // not sure this is allowed but we try lmao
+    rc = ble_rm_tx(conn_handle, txom);
+    if (rc != 0) {
+        BLE_HS_LOG(ERROR, "Error sending rekey rsp %d\n", rc);
+    }
+}
+
+int
+ble_rm_rekey_req_send(uint16_t conn_handle)
+{
+    struct ble_rm_public_key* cmd;
+    struct os_mbuf* txom;
+    int rc;
+
+    // We can reuse functions from ble_sm
+    cmd = ble_sm_cmd_get(BLE_RM_OPCODE_REKEY_REQ, sizeof(*cmd), &txom);
+    if (!cmd) {
+        return 1;
+    }
+
+    // Generate key pair
+#if MYNEWT_VAL(ENABLE_SM_PQ)
+    rc = crypto_kem_keypair(pk, sk);
+    memcpy(cmd->key, pk, sizeof(pk));
+#else
+#if MYNEWT_VAL(ENABLE_DH_REKEY)
+    rc = ble_sm_alg_gen_key_pair(ble_sm_eph_pub_key, ble_sm_eph_priv_key);
+    memcpy(cmd->key, ble_sm_eph_pub_key, sizeof(ble_sm_eph_pub_key));
+#else
+    random_data(ble_sm_eph_pub_key, sizeof(ble_sm_eph_pub_key));
+    memcpy(cmd->key, ble_sm_eph_pub_key, sizeof(ble_sm_eph_pub_key));
+#endif
+#endif
+    if (rc != 0) {
+        BLE_HS_LOG(ERROR, "Failed to generate DH keys");
+        os_mbuf_free_chain(txom);
+        return rc;
+    }
+    rc = ble_rm_tx(conn_handle, txom);
+    if (rc != 0) {
+        BLE_HS_LOG(ERROR, "Error sending rekey req %d\n", rc);
+        os_mbuf_free_chain(txom);
+    }
+
+    return rc;
+}
+
+static int
+ble_rm_rx(struct ble_l2cap_chan* chan)
+{
+    struct os_mbuf** om;
+    uint16_t handle;
+    uint8_t op;
+    struct ble_rm_public_key* cmd;
+    int rc;
+
+    handle = ble_l2cap_get_conn_handle(chan);
+    if (handle == BLE_HS_CONN_HANDLE_NONE) {
+        return BLE_HS_ENOTCONN;
+    }
+
+    om = &chan->rx_buf;
+    BLE_HS_DBG_ASSERT(*om != NULL);
+
+    rc = os_mbuf_copydata(*om, 0, 1, &op);
+    if (rc != 0) {
+        return BLE_HS_EBADDATA;
+    }
+    os_mbuf_adj(*om, 1);
+
+    switch (op) {
+    case BLE_RM_OPCODE_REKEY_REQ:
+        // BLE_HS_LOG(INFO, "Rekey request received\n");
+        ble_rm_rekey_req_rx(handle, om);
+        break;
+    case BLE_RM_OPCODE_REKEY_RSP:
+        // BLE_HS_LOG(INFO, "Rekey response received\n");
+        ble_rm_rekey_rsp_rx(handle, om);
+        break;
+    default:
+        return BLE_HS_ENOTSUP;
+    }
+    return 0;
+}
+struct ble_l2cap_chan*
+ble_rm_create_chan(uint16_t conn_handle)
+{
+    struct ble_l2cap_chan* chan;
+
+    chan = ble_l2cap_chan_alloc(conn_handle);
+    if (chan == NULL) {
+        return NULL;
+    }
+
+    chan->scid = BLE_L2CAP_CID_RM;
+    chan->dcid = BLE_L2CAP_CID_RM;
+    chan->my_mtu = BLE_SM_MTU;
+    chan->rx_fn = ble_rm_rx;
+    return chan;
+}
\ No newline at end of file
diff --git a/nimble/host/src/ble_rm.h b/nimble/host/src/ble_rm.h
new file mode 100644
index 00000000..105e1f2d
--- /dev/null
+++ b/nimble/host/src/ble_rm.h
@@ -0,0 +1,28 @@
+#include <inttypes.h>
+#include "syscfg/syscfg.h"
+#include "kyber/kem.h"
+
+#define BLE_RM_OPCODE_REKEY_REQ 0x0e
+#define BLE_RM_OPCODE_REKEY_RSP 0x0f
+
+struct ble_rm_hdr
+{
+    uint8_t opcode;
+    uint8_t data[0];
+} __attribute__((packed));
+
+struct ble_rm_public_key
+{
+#if MYNEWT_VAL(ENABLE_SM_PQ)
+    uint8_t key[CRYPTO_PUBLICKEYBYTES];
+#elif MYNEWT_VAL(ENABLE_SM_25519)
+    uint8_t key[32];
+#else
+    uint8_t key[64];
+#endif
+} __attribute__((packed));
+
+int
+ble_rm_rekey_req_send(uint16_t conn_handle);
+struct ble_l2cap_chan*
+ble_rm_create_chan(uint16_t conn_handle);
\ No newline at end of file
diff --git a/nimble/host/src/ble_sm.c b/nimble/host/src/ble_sm.c
index eed5e363..f0499ad7 100644
--- a/nimble/host/src/ble_sm.c
+++ b/nimble/host/src/ble_sm.c
@@ -47,6 +47,7 @@
 #include "nimble/nimble_opt.h"
 #include "host/ble_sm.h"
 #include "ble_hs_priv.h"
+#include "kyber/kem.h"
 
 #if NIMBLE_BLE_CONNECT
 
@@ -61,12 +62,13 @@
 #if NIMBLE_BLE_SM
 
 /** Procedure timeout; 30 seconds. */
-#define BLE_SM_TIMEOUT_MS             (30000)
+#define BLE_SM_TIMEOUT_MS (30000)
 
 STAILQ_HEAD(ble_sm_proc_list, ble_sm_proc);
 
-typedef void ble_sm_rx_fn(uint16_t conn_handle, struct os_mbuf **om,
-                          struct ble_sm_result *res);
+typedef void
+ble_sm_rx_fn(uint16_t conn_handle, struct os_mbuf** om,
+             struct ble_sm_result* res);
 
 static ble_sm_rx_fn ble_sm_rx_noop;
 static ble_sm_rx_fn ble_sm_pair_req_rx;
@@ -81,25 +83,25 @@ static ble_sm_rx_fn ble_sm_id_addr_info_rx;
 static ble_sm_rx_fn ble_sm_sign_info_rx;
 static ble_sm_rx_fn ble_sm_sec_req_rx;
 
-static ble_sm_rx_fn * const ble_sm_dispatch[] = {
-   [BLE_SM_OP_PAIR_REQ] = ble_sm_pair_req_rx,
-   [BLE_SM_OP_PAIR_RSP] = ble_sm_pair_rsp_rx,
-   [BLE_SM_OP_PAIR_CONFIRM] = ble_sm_confirm_rx,
-   [BLE_SM_OP_PAIR_RANDOM] = ble_sm_random_rx,
-   [BLE_SM_OP_PAIR_FAIL] = ble_sm_fail_rx,
-   [BLE_SM_OP_ENC_INFO] = ble_sm_enc_info_rx,
-   [BLE_SM_OP_MASTER_ID] = ble_sm_master_id_rx,
-   [BLE_SM_OP_IDENTITY_INFO] = ble_sm_id_info_rx,
-   [BLE_SM_OP_IDENTITY_ADDR_INFO] = ble_sm_id_addr_info_rx,
-   [BLE_SM_OP_SIGN_INFO] = ble_sm_sign_info_rx,
-   [BLE_SM_OP_SEC_REQ] = ble_sm_sec_req_rx,
-   [BLE_SM_OP_PAIR_KEYPRESS_NOTIFY] = ble_sm_rx_noop,
+static ble_sm_rx_fn* const ble_sm_dispatch[] = {
+    [BLE_SM_OP_PAIR_REQ] = ble_sm_pair_req_rx,
+    [BLE_SM_OP_PAIR_RSP] = ble_sm_pair_rsp_rx,
+    [BLE_SM_OP_PAIR_CONFIRM] = ble_sm_confirm_rx,
+    [BLE_SM_OP_PAIR_RANDOM] = ble_sm_random_rx,
+    [BLE_SM_OP_PAIR_FAIL] = ble_sm_fail_rx,
+    [BLE_SM_OP_ENC_INFO] = ble_sm_enc_info_rx,
+    [BLE_SM_OP_MASTER_ID] = ble_sm_master_id_rx,
+    [BLE_SM_OP_IDENTITY_INFO] = ble_sm_id_info_rx,
+    [BLE_SM_OP_IDENTITY_ADDR_INFO] = ble_sm_id_addr_info_rx,
+    [BLE_SM_OP_SIGN_INFO] = ble_sm_sign_info_rx,
+    [BLE_SM_OP_SEC_REQ] = ble_sm_sec_req_rx,
+    [BLE_SM_OP_PAIR_KEYPRESS_NOTIFY] = ble_sm_rx_noop,
 #if MYNEWT_VAL(BLE_SM_SC)
-   [BLE_SM_OP_PAIR_PUBLIC_KEY] = ble_sm_sc_public_key_rx,
-   [BLE_SM_OP_PAIR_DHKEY_CHECK] = ble_sm_sc_dhkey_check_rx,
+    [BLE_SM_OP_PAIR_PUBLIC_KEY] = ble_sm_sc_public_key_rx,
+    [BLE_SM_OP_PAIR_DHKEY_CHECK] = ble_sm_sc_dhkey_check_rx,
 #else
-   [BLE_SM_OP_PAIR_PUBLIC_KEY] = ble_sm_rx_noop,
-   [BLE_SM_OP_PAIR_DHKEY_CHECK] = ble_sm_rx_noop,
+    [BLE_SM_OP_PAIR_PUBLIC_KEY] = ble_sm_rx_noop,
+    [BLE_SM_OP_PAIR_DHKEY_CHECK] = ble_sm_rx_noop,
 #endif
 };
 
@@ -111,8 +113,8 @@ struct hci_start_encrypt
     uint8_t long_term_key[16];
 };
 
-typedef void ble_sm_state_fn(struct ble_sm_proc *proc,
-                             struct ble_sm_result *res, void *arg);
+typedef void
+ble_sm_state_fn(struct ble_sm_proc* proc, struct ble_sm_result* res, void* arg);
 
 static ble_sm_state_fn ble_sm_pair_exec;
 static ble_sm_state_fn ble_sm_confirm_exec;
@@ -124,38 +126,54 @@ static ble_sm_state_fn ble_sm_enc_restore_exec;
 static ble_sm_state_fn ble_sm_key_exch_exec;
 static ble_sm_state_fn ble_sm_sec_req_exec;
 
-static ble_sm_state_fn * const
-ble_sm_state_dispatch[BLE_SM_PROC_STATE_CNT] = {
-    [BLE_SM_PROC_STATE_PAIR]          = ble_sm_pair_exec,
-    [BLE_SM_PROC_STATE_CONFIRM]       = ble_sm_confirm_exec,
-    [BLE_SM_PROC_STATE_RANDOM]        = ble_sm_random_exec,
-    [BLE_SM_PROC_STATE_LTK_START]     = ble_sm_ltk_start_exec,
-    [BLE_SM_PROC_STATE_LTK_RESTORE]   = ble_sm_ltk_restore_exec,
-    [BLE_SM_PROC_STATE_ENC_START]     = ble_sm_enc_start_exec,
-    [BLE_SM_PROC_STATE_ENC_RESTORE]   = ble_sm_enc_restore_exec,
-    [BLE_SM_PROC_STATE_KEY_EXCH]      = ble_sm_key_exch_exec,
-    [BLE_SM_PROC_STATE_SEC_REQ]       = ble_sm_sec_req_exec,
+static ble_sm_state_fn* const ble_sm_state_dispatch[BLE_SM_PROC_STATE_CNT] = {
+    [BLE_SM_PROC_STATE_PAIR] = ble_sm_pair_exec,
+    [BLE_SM_PROC_STATE_CONFIRM] = ble_sm_confirm_exec,
+    [BLE_SM_PROC_STATE_RANDOM] = ble_sm_random_exec,
+    [BLE_SM_PROC_STATE_LTK_START] = ble_sm_ltk_start_exec,
+    [BLE_SM_PROC_STATE_LTK_RESTORE] = ble_sm_ltk_restore_exec,
+    [BLE_SM_PROC_STATE_ENC_START] = ble_sm_enc_start_exec,
+    [BLE_SM_PROC_STATE_ENC_RESTORE] = ble_sm_enc_restore_exec,
+    [BLE_SM_PROC_STATE_KEY_EXCH] = ble_sm_key_exch_exec,
+    [BLE_SM_PROC_STATE_SEC_REQ] = ble_sm_sec_req_exec,
 #if MYNEWT_VAL(BLE_SM_SC)
-    [BLE_SM_PROC_STATE_PUBLIC_KEY]    = ble_sm_sc_public_key_exec,
-    [BLE_SM_PROC_STATE_DHKEY_CHECK]   = ble_sm_sc_dhkey_check_exec,
+    [BLE_SM_PROC_STATE_PUBLIC_KEY] = ble_sm_sc_public_key_exec,
+    [BLE_SM_PROC_STATE_DHKEY_CHECK] = ble_sm_sc_dhkey_check_exec,
 #else
-    [BLE_SM_PROC_STATE_PUBLIC_KEY]    = NULL,
-    [BLE_SM_PROC_STATE_DHKEY_CHECK]   = NULL,
+    [BLE_SM_PROC_STATE_PUBLIC_KEY] = NULL,
+    [BLE_SM_PROC_STATE_DHKEY_CHECK] = NULL,
 #endif
 };
 
-static os_membuf_t ble_sm_proc_mem[
-    OS_MEMPOOL_SIZE(MYNEWT_VAL(BLE_SM_MAX_PROCS),
-                    sizeof (struct ble_sm_proc))
-];
+static os_membuf_t ble_sm_proc_mem[OS_MEMPOOL_SIZE(MYNEWT_VAL(BLE_SM_MAX_PROCS),
+                                                   sizeof(struct ble_sm_proc))];
 
 static struct os_mempool ble_sm_proc_pool;
 
 /* Maintains the list of active security manager procedures. */
 static struct ble_sm_proc_list ble_sm_procs;
 
-static void ble_sm_pair_cfg(struct ble_sm_proc *proc);
+static void
+ble_sm_pair_cfg(struct ble_sm_proc* proc);
+
+#if MYNEWT_VAL(ENABLE_SM_25519)
+uint8_t ble_sm_eph_pub_key[32];
+#else
+uint8_t ble_sm_eph_pub_key[64];
+#endif
+uint8_t ble_sm_eph_priv_key[32];
+
+#if MYNEWT_VAL(ENABLE_SM_PQ)
+uint8_t pk[CRYPTO_PUBLICKEYBYTES];
+uint8_t sk[CRYPTO_SECRETKEYBYTES];
+uint8_t ct[CRYPTO_CIPHERTEXTBYTES];
+// uint8_t shared[CRYPTO_BYTES];
+#endif
 
+static uint8_t psk[32] = {0xA3, 0x7E, 0xD2, 0x4F, 0x89, 0x6C, 0x15, 0x92,
+                          0x38, 0xB4, 0xE7, 0x5A, 0xC1, 0x0D, 0xF8, 0x63,
+                          0x21, 0x9F, 0x4B, 0xED, 0x78, 0x34, 0xC6, 0x1A,
+                          0x8D, 0x52, 0x3F, 0xE2, 0x95, 0x47, 0x0B, 0xAC};
 
 /*****************************************************************************
  * $debug                                                                    *
@@ -175,7 +193,7 @@ static uint8_t ble_sm_dbg_next_csrk[16];
 static uint8_t ble_sm_dbg_next_csrk_set;
 
 void
-ble_sm_dbg_set_next_pair_rand(uint8_t *next_pair_rand)
+ble_sm_dbg_set_next_pair_rand(uint8_t* next_pair_rand)
 {
     memcpy(ble_sm_dbg_next_pair_rand, next_pair_rand,
            sizeof ble_sm_dbg_next_pair_rand);
@@ -197,18 +215,16 @@ ble_sm_dbg_set_next_master_id_rand(uint64_t next_master_id_rand)
 }
 
 void
-ble_sm_dbg_set_next_ltk(uint8_t *next_ltk)
+ble_sm_dbg_set_next_ltk(uint8_t* next_ltk)
 {
-    memcpy(ble_sm_dbg_next_ltk, next_ltk,
-           sizeof ble_sm_dbg_next_ltk);
+    memcpy(ble_sm_dbg_next_ltk, next_ltk, sizeof ble_sm_dbg_next_ltk);
     ble_sm_dbg_next_ltk_set = 1;
 }
 
 void
-ble_sm_dbg_set_next_csrk(uint8_t *next_csrk)
+ble_sm_dbg_set_next_csrk(uint8_t* next_csrk)
 {
-    memcpy(ble_sm_dbg_next_csrk, next_csrk,
-           sizeof ble_sm_dbg_next_csrk);
+    memcpy(ble_sm_dbg_next_csrk, next_csrk, sizeof ble_sm_dbg_next_csrk);
     ble_sm_dbg_next_csrk_set = 1;
 }
 
@@ -223,12 +239,13 @@ ble_sm_dbg_assert_no_cycles(void)
 }
 
 static void
-ble_sm_dbg_assert_not_inserted(struct ble_sm_proc *proc)
+ble_sm_dbg_assert_not_inserted(struct ble_sm_proc* proc)
 {
 #if MYNEWT_VAL(BLE_HS_DEBUG)
-    struct ble_sm_proc *cur;
+    struct ble_sm_proc* cur;
 
-    STAILQ_FOREACH(cur, &ble_sm_procs, next) {
+    STAILQ_FOREACH(cur, &ble_sm_procs, next)
+    {
         BLE_HS_DBG_ASSERT(cur != proc);
     }
 #endif
@@ -244,11 +261,12 @@ ble_sm_dbg_assert_not_inserted(struct ble_sm_proc *proc)
 int
 ble_sm_num_procs(void)
 {
-    struct ble_sm_proc *proc;
+    struct ble_sm_proc* proc;
     int cnt;
 
     cnt = 0;
-    STAILQ_FOREACH(proc, &ble_sm_procs, next) {
+    STAILQ_FOREACH(proc, &ble_sm_procs, next)
+    {
         BLE_HS_DBG_ASSERT(cnt < MYNEWT_VAL(BLE_SM_MAX_PROCS));
         cnt++;
     }
@@ -257,7 +275,7 @@ ble_sm_num_procs(void)
 }
 
 int
-ble_sm_gen_pair_rand(uint8_t *pair_rand)
+ble_sm_gen_pair_rand(uint8_t* pair_rand)
 {
     int rc;
 
@@ -279,7 +297,7 @@ ble_sm_gen_pair_rand(uint8_t *pair_rand)
 }
 
 static int
-ble_sm_gen_ediv(struct ble_sm_master_id *master_id)
+ble_sm_gen_ediv(struct ble_sm_master_id* master_id)
 {
     int rc;
 
@@ -300,7 +318,7 @@ ble_sm_gen_ediv(struct ble_sm_master_id *master_id)
 }
 
 static int
-ble_sm_gen_master_id_rand(struct ble_sm_master_id *master_id)
+ble_sm_gen_master_id_rand(struct ble_sm_master_id* master_id)
 {
     int rc;
 
@@ -321,15 +339,14 @@ ble_sm_gen_master_id_rand(struct ble_sm_master_id *master_id)
 }
 
 static int
-ble_sm_gen_ltk(struct ble_sm_proc *proc, uint8_t *ltk)
+ble_sm_gen_ltk(struct ble_sm_proc* proc, uint8_t* ltk)
 {
     int rc;
 
 #if MYNEWT_VAL(BLE_HS_DEBUG)
     if (ble_sm_dbg_next_ltk_set) {
         ble_sm_dbg_next_ltk_set = 0;
-        memcpy(ltk, ble_sm_dbg_next_ltk,
-               sizeof ble_sm_dbg_next_ltk);
+        memcpy(ltk, ble_sm_dbg_next_ltk, sizeof ble_sm_dbg_next_ltk);
         return 0;
     }
 #endif
@@ -346,15 +363,14 @@ ble_sm_gen_ltk(struct ble_sm_proc *proc, uint8_t *ltk)
 }
 
 static int
-ble_sm_gen_csrk(struct ble_sm_proc *proc, uint8_t *csrk)
+ble_sm_gen_csrk(struct ble_sm_proc* proc, uint8_t* csrk)
 {
     int rc;
 
 #if MYNEWT_VAL(BLE_HS_DEBUG)
     if (ble_sm_dbg_next_csrk_set) {
         ble_sm_dbg_next_csrk_set = 0;
-        memcpy(csrk, ble_sm_dbg_next_csrk,
-               sizeof ble_sm_dbg_next_csrk);
+        memcpy(csrk, ble_sm_dbg_next_csrk, sizeof ble_sm_dbg_next_csrk);
         return 0;
     }
 #endif
@@ -368,14 +384,14 @@ ble_sm_gen_csrk(struct ble_sm_proc *proc, uint8_t *csrk)
 }
 
 static void
-ble_sm_proc_set_timer(struct ble_sm_proc *proc)
+ble_sm_proc_set_timer(struct ble_sm_proc* proc)
 {
-    proc->exp_os_ticks = ble_npl_time_get() +
-                         ble_npl_time_ms_to_ticks32(BLE_SM_TIMEOUT_MS);
+    proc->exp_os_ticks =
+        ble_npl_time_get() + ble_npl_time_ms_to_ticks32(BLE_SM_TIMEOUT_MS);
     ble_hs_timer_resched();
 }
 
-static ble_sm_rx_fn *
+static ble_sm_rx_fn*
 ble_sm_dispatch_get(uint8_t op)
 {
     if (op >= sizeof ble_sm_dispatch / sizeof ble_sm_dispatch[0]) {
@@ -390,10 +406,10 @@ ble_sm_dispatch_get(uint8_t op)
  *
  * @return                      An entry on success; null on failure.
  */
-static struct ble_sm_proc *
+static struct ble_sm_proc*
 ble_sm_proc_alloc(void)
 {
-    struct ble_sm_proc *proc;
+    struct ble_sm_proc* proc;
 
     proc = os_memblock_get(&ble_sm_proc_pool);
     if (proc != NULL) {
@@ -407,7 +423,7 @@ ble_sm_proc_alloc(void)
  * Frees the specified proc entry.  No-state if passed a null pointer.
  */
 static void
-ble_sm_proc_free(struct ble_sm_proc *proc)
+ble_sm_proc_free(struct ble_sm_proc* proc)
 {
     int rc;
 
@@ -422,13 +438,13 @@ ble_sm_proc_free(struct ble_sm_proc *proc)
 }
 
 static void
-ble_sm_proc_remove(struct ble_sm_proc *proc,
-                         struct ble_sm_proc *prev)
+ble_sm_proc_remove(struct ble_sm_proc* proc, struct ble_sm_proc* prev)
 {
     if (prev == NULL) {
         BLE_HS_DBG_ASSERT(STAILQ_FIRST(&ble_sm_procs) == proc);
         STAILQ_REMOVE_HEAD(&ble_sm_procs, next);
-    } else {
+    }
+    else {
         BLE_HS_DBG_ASSERT(STAILQ_NEXT(prev, next) == proc);
         STAILQ_REMOVE_AFTER(&ble_sm_procs, prev, next);
     }
@@ -437,10 +453,10 @@ ble_sm_proc_remove(struct ble_sm_proc *proc,
 }
 
 static void
-ble_sm_update_sec_state(uint16_t conn_handle, int encrypted,
-                        int authenticated, int bonded, int key_size)
+ble_sm_update_sec_state(uint16_t conn_handle, int encrypted, int authenticated,
+                        int bonded, int key_size)
 {
-    struct ble_hs_conn *conn;
+    struct ble_hs_conn* conn;
 
     conn = ble_hs_conn_find(conn_handle);
     if (conn != NULL) {
@@ -461,11 +477,9 @@ ble_sm_update_sec_state(uint16_t conn_handle, int encrypted,
 }
 
 static void
-ble_sm_fill_store_value(const ble_addr_t *peer_addr,
-                        int authenticated,
-                        int sc,
-                        struct ble_sm_keys *keys,
-                        struct ble_store_value_sec *value_sec)
+ble_sm_fill_store_value(const ble_addr_t* peer_addr, int authenticated, int sc,
+                        struct ble_sm_keys* keys,
+                        struct ble_store_value_sec* value_sec)
 {
     memset(value_sec, 0, sizeof *value_sec);
 
@@ -483,6 +497,11 @@ ble_sm_fill_store_value(const ble_addr_t *peer_addr,
         value_sec->sc = !!sc;
     }
 
+    if (keys->pubkey_valid) {
+        memcpy(value_sec->pubkey, keys->pubkey, sizeof(value_sec->pubkey));
+        value_sec->pubkey_present = 1;
+    }
+
     if (keys->irk_valid) {
         memcpy(value_sec->irk, keys->irk, sizeof value_sec->irk);
         value_sec->irk_present = 1;
@@ -495,12 +514,11 @@ ble_sm_fill_store_value(const ble_addr_t *peer_addr,
 }
 
 void
-ble_sm_ia_ra(struct ble_sm_proc *proc,
-             uint8_t *out_iat, uint8_t *out_ia,
-             uint8_t *out_rat, uint8_t *out_ra)
+ble_sm_ia_ra(struct ble_sm_proc* proc, uint8_t* out_iat, uint8_t* out_ia,
+             uint8_t* out_rat, uint8_t* out_ra)
 {
     struct ble_hs_conn_addrs addrs;
-    struct ble_hs_conn *conn;
+    struct ble_hs_conn* conn;
 
     conn = ble_hs_conn_find_assert(proc->conn_handle);
 
@@ -512,7 +530,8 @@ ble_sm_ia_ra(struct ble_sm_proc *proc,
 
         *out_rat = addrs.peer_ota_addr.type;
         memcpy(out_ra, addrs.peer_ota_addr.val, 6);
-    } else {
+    }
+    else {
         *out_iat = addrs.peer_ota_addr.type;
         memcpy(out_ia, addrs.peer_ota_addr.val, 6);
 
@@ -522,14 +541,15 @@ ble_sm_ia_ra(struct ble_sm_proc *proc,
 }
 
 static void
-ble_sm_persist_keys(struct ble_sm_proc *proc)
+ble_sm_persist_keys(struct ble_sm_proc* proc)
 {
     struct ble_store_value_sec value_sec;
-    struct ble_hs_conn *conn;
+    struct ble_hs_conn* conn;
     ble_addr_t peer_addr;
     int authenticated;
     int identity_ev = 0;
     int sc;
+    // BLE_HS_LOG(INFO, "\nPersisting keys\n");
 
     ble_hs_lock();
 
@@ -538,6 +558,7 @@ ble_sm_persist_keys(struct ble_sm_proc *proc)
 
     /* If we got an identity address, use that for key storage. */
     if (proc->peer_keys.addr_valid) {
+
         peer_addr.type = proc->peer_keys.addr_type;
         memcpy(peer_addr.val, proc->peer_keys.addr, sizeof peer_addr.val);
 
@@ -564,7 +585,9 @@ ble_sm_persist_keys(struct ble_sm_proc *proc)
 
             identity_ev = 1;
         }
-    } else {
+    }
+    else {
+
         peer_addr = conn->bhc_peer_addr;
         peer_addr.type =
             ble_hs_misc_peer_addr_type_to_id(conn->bhc_peer_addr.type);
@@ -573,6 +596,7 @@ ble_sm_persist_keys(struct ble_sm_proc *proc)
     ble_hs_unlock();
 
     if (identity_ev) {
+
         /* Use peer_addr since it does have proper addr type (i.e. 0/1, not 2/3) */
         ble_gap_identity_event(proc->conn_handle, &peer_addr);
     }
@@ -590,7 +614,7 @@ ble_sm_persist_keys(struct ble_sm_proc *proc)
 }
 
 static int
-ble_sm_proc_matches(struct ble_sm_proc *proc, uint16_t conn_handle,
+ble_sm_proc_matches(struct ble_sm_proc* proc, uint16_t conn_handle,
                     uint8_t state, int is_initiator)
 {
     int proc_is_initiator;
@@ -627,17 +651,18 @@ ble_sm_proc_matches(struct ble_sm_proc *proc, uint16_t conn_handle,
  * @return                      The matching proc entry on success;
  *                                  null on failure.
  */
-struct ble_sm_proc *
+struct ble_sm_proc*
 ble_sm_proc_find(uint16_t conn_handle, uint8_t state, int is_initiator,
-                 struct ble_sm_proc **out_prev)
+                 struct ble_sm_proc** out_prev)
 {
-    struct ble_sm_proc *proc;
-    struct ble_sm_proc *prev;
+    struct ble_sm_proc* proc;
+    struct ble_sm_proc* prev;
 
     BLE_HS_DBG_ASSERT(ble_hs_locked_by_cur_task());
 
     prev = NULL;
-    STAILQ_FOREACH(proc, &ble_sm_procs, next) {
+    STAILQ_FOREACH(proc, &ble_sm_procs, next)
+    {
         if (ble_sm_proc_matches(proc, conn_handle, state, is_initiator)) {
             if (out_prev != NULL) {
                 *out_prev = prev;
@@ -652,12 +677,13 @@ ble_sm_proc_find(uint16_t conn_handle, uint8_t state, int is_initiator,
 }
 
 static void
-ble_sm_insert(struct ble_sm_proc *proc)
+ble_sm_insert(struct ble_sm_proc* proc)
 {
 #if MYNEWT_VAL(BLE_HS_DEBUG)
-    struct ble_sm_proc *cur;
+    struct ble_sm_proc* cur;
 
-    STAILQ_FOREACH(cur, &ble_sm_procs, next) {
+    STAILQ_FOREACH(cur, &ble_sm_procs, next)
+    {
         BLE_HS_DBG_ASSERT(cur != proc);
     }
 #endif
@@ -666,11 +692,11 @@ ble_sm_insert(struct ble_sm_proc *proc)
 }
 
 static int32_t
-ble_sm_extract_expired(struct ble_sm_proc_list *dst_list)
+ble_sm_extract_expired(struct ble_sm_proc_list* dst_list)
 {
-    struct ble_sm_proc *proc;
-    struct ble_sm_proc *prev;
-    struct ble_sm_proc *next;
+    struct ble_sm_proc* proc;
+    struct ble_sm_proc* prev;
+    struct ble_sm_proc* next;
     ble_npl_time_t now;
     ble_npl_stime_t next_exp_in;
     ble_npl_stime_t time_diff;
@@ -693,11 +719,13 @@ ble_sm_extract_expired(struct ble_sm_proc_list *dst_list)
             /* Procedure has expired; move it to the destination list. */
             if (prev == NULL) {
                 STAILQ_REMOVE_HEAD(&ble_sm_procs, next);
-            } else {
+            }
+            else {
                 STAILQ_REMOVE_AFTER(&ble_sm_procs, prev, next);
             }
             STAILQ_INSERT_HEAD(dst_list, proc, next);
-        } else {
+        }
+        else {
             if (time_diff < next_exp_in) {
                 next_exp_in = time_diff;
             }
@@ -715,8 +743,8 @@ ble_sm_extract_expired(struct ble_sm_proc_list *dst_list)
 }
 
 static void
-ble_sm_rx_noop(uint16_t conn_handle, struct os_mbuf **om,
-               struct ble_sm_result *res)
+ble_sm_rx_noop(uint16_t conn_handle, struct os_mbuf** om,
+               struct ble_sm_result* res)
 {
     res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_CMD_NOT_SUPP);
     res->sm_err = BLE_SM_ERR_CMD_NOT_SUPP;
@@ -725,18 +753,17 @@ ble_sm_rx_noop(uint16_t conn_handle, struct os_mbuf **om,
 static uint8_t
 ble_sm_build_authreq(void)
 {
-    return ble_hs_cfg.sm_bonding << 0  |
-           ble_hs_cfg.sm_mitm << 2     |
-           ble_hs_cfg.sm_sc << 3       |
-           ble_hs_cfg.sm_keypress << 4;
+    return ble_hs_cfg.sm_bonding << 0 | ble_hs_cfg.sm_mitm << 2 |
+           ble_hs_cfg.sm_sc << 3 | ble_hs_cfg.sm_keypress << 4;
 }
 
 static int
-ble_sm_io_action(struct ble_sm_proc *proc, uint8_t *action)
+ble_sm_io_action(struct ble_sm_proc* proc, uint8_t* action)
 {
     if (proc->flags & BLE_SM_PROC_F_SC) {
         return ble_sm_sc_io_action(proc, action);
-    } else {
+    }
+    else {
         return ble_sm_lgcy_io_action(proc, action);
     }
 }
@@ -766,7 +793,7 @@ ble_sm_ioact_state(uint8_t action)
 }
 
 int
-ble_sm_proc_can_advance(struct ble_sm_proc *proc)
+ble_sm_proc_can_advance(struct ble_sm_proc* proc)
 {
     uint8_t ioact;
     int rc;
@@ -790,15 +817,16 @@ ble_sm_proc_can_advance(struct ble_sm_proc *proc)
 }
 
 static void
-ble_sm_exec(struct ble_sm_proc *proc, struct ble_sm_result *res, void *arg)
+ble_sm_exec(struct ble_sm_proc* proc, struct ble_sm_result* res, void* arg)
 {
-    ble_sm_state_fn *cb;
+    ble_sm_state_fn* cb;
 
     memset(res, 0, sizeof *res);
 
     if (!ble_hs_conn_exists(proc->conn_handle)) {
         res->app_status = BLE_HS_ENOTCONN;
-    } else {
+    }
+    else {
         BLE_HS_DBG_ASSERT(proc->state < BLE_SM_PROC_STATE_CNT);
         cb = ble_sm_state_dispatch[proc->state];
         BLE_HS_DBG_ASSERT(cb != NULL);
@@ -809,8 +837,8 @@ ble_sm_exec(struct ble_sm_proc *proc, struct ble_sm_result *res, void *arg)
 static void
 ble_sm_pair_fail_tx(uint16_t conn_handle, uint8_t reason)
 {
-    struct ble_sm_pair_fail *cmd;
-    struct os_mbuf *txom;
+    struct ble_sm_pair_fail* cmd;
+    struct os_mbuf* txom;
     int rc;
 
     BLE_HS_DBG_ASSERT(reason > 0 && reason < BLE_SM_ERR_MAX_PLUS_1);
@@ -829,7 +857,7 @@ ble_sm_pair_fail_tx(uint16_t conn_handle, uint8_t reason)
  * Reads a bond from storage.
  */
 static int
-ble_sm_read_bond(uint16_t conn_handle, struct ble_store_value_sec *out_bond)
+ble_sm_read_bond(uint16_t conn_handle, struct ble_store_value_sec* out_bond)
 {
     struct ble_store_key_sec key_sec;
     struct ble_gap_conn_desc desc;
@@ -862,8 +890,7 @@ ble_sm_read_bond(uint16_t conn_handle, struct ble_store_value_sec *out_bond)
  *                              nonzero if the request should be ignored.
  */
 static int
-ble_sm_chk_repeat_pairing(uint16_t conn_handle,
-                          ble_sm_proc_flags proc_flags,
+ble_sm_chk_repeat_pairing(uint16_t conn_handle, ble_sm_proc_flags proc_flags,
                           uint8_t key_size)
 {
     struct ble_gap_repeat_pairing rp;
@@ -904,19 +931,18 @@ ble_sm_chk_repeat_pairing(uint16_t conn_handle,
 }
 
 void
-ble_sm_process_result(uint16_t conn_handle, struct ble_sm_result *res,
+ble_sm_process_result(uint16_t conn_handle, struct ble_sm_result* res,
                       bool tx_fail)
 {
-    struct ble_sm_proc *prev;
-    struct ble_sm_proc *proc;
+    struct ble_sm_proc* prev;
+    struct ble_sm_proc* proc;
     int rm;
 
     rm = 0;
 
     while (1) {
         ble_hs_lock();
-        proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_NONE, -1,
-                                &prev);
+        proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_NONE, -1, &prev);
 
         if (proc != NULL) {
             if (res->execute) {
@@ -933,7 +959,8 @@ ble_sm_process_result(uint16_t conn_handle, struct ble_sm_result *res,
 
             if (rm) {
                 ble_sm_proc_remove(proc, prev);
-            } else {
+            }
+            else {
                 ble_sm_proc_set_timer(proc);
             }
         }
@@ -944,9 +971,10 @@ ble_sm_process_result(uint16_t conn_handle, struct ble_sm_result *res,
 
         ble_hs_unlock();
 
-        if (res->enc_cb &&
-            res->app_status != BLE_HS_ENOTCONN) {
+        if (res->enc_cb && res->app_status != BLE_HS_ENOTCONN) {
             /* Do not send this event on broken connection */
+            BLE_HS_LOG(INFO, "\n");
+            BLE_HS_LOG(INFO, "BBx execution completed\n");
             ble_gap_pairing_complete_event(conn_handle, res->sm_err);
         }
 
@@ -956,7 +984,8 @@ ble_sm_process_result(uint16_t conn_handle, struct ble_sm_result *res,
 
         if (res->enc_cb) {
             BLE_HS_DBG_ASSERT(proc == NULL || rm);
-            ble_gap_enc_event(conn_handle, res->app_status, res->restore, res->bonded);
+            ble_gap_enc_event(conn_handle, res->app_status, res->restore,
+                              res->bonded);
         }
 
         if (res->app_status == 0 &&
@@ -966,10 +995,7 @@ ble_sm_process_result(uint16_t conn_handle, struct ble_sm_result *res,
         }
 
         /* Persist keys if bonding has successfully completed. */
-        if (res->app_status == 0    &&
-            rm                      &&
-            proc->flags & BLE_SM_PROC_F_BONDING) {
-
+        if (res->app_status == 0 && rm && proc->flags & BLE_SM_PROC_F_BONDING) {
             ble_sm_persist_keys(proc);
         }
 
@@ -988,12 +1014,12 @@ ble_sm_process_result(uint16_t conn_handle, struct ble_sm_result *res,
 }
 
 static void
-ble_sm_key_dist(struct ble_sm_proc *proc,
-                uint8_t *out_init_key_dist, uint8_t *out_resp_key_dist)
+ble_sm_key_dist(struct ble_sm_proc* proc, uint8_t* out_init_key_dist,
+                uint8_t* out_resp_key_dist)
 {
-    struct ble_sm_pair_cmd *pair_rsp;
+    struct ble_sm_pair_cmd* pair_rsp;
 
-    pair_rsp = (struct ble_sm_pair_cmd *) &proc->pair_rsp[1];
+    pair_rsp = (struct ble_sm_pair_cmd*)&proc->pair_rsp[1];
 
     *out_init_key_dist = pair_rsp->init_key_dist;
     *out_resp_key_dist = pair_rsp->resp_key_dist;
@@ -1066,7 +1092,7 @@ ble_sm_chk_store_overflow(uint16_t conn_handle)
  *****************************************************************************/
 
 static int
-ble_sm_start_encrypt_tx(struct hci_start_encrypt *params)
+ble_sm_start_encrypt_tx(struct hci_start_encrypt* params)
 {
     struct ble_hci_le_start_encrypt_cp cmd;
 
@@ -1075,38 +1101,60 @@ ble_sm_start_encrypt_tx(struct hci_start_encrypt *params)
     cmd.rand = htole64(params->random_number);
     memcpy(cmd.ltk, params->long_term_key, sizeof(cmd.ltk));
 
-    return ble_hs_hci_cmd_tx(BLE_HCI_OP(BLE_HCI_OGF_LE,
-                                        BLE_HCI_OCF_LE_START_ENCRYPT),
-                             &cmd, sizeof(cmd), NULL, 0);
+    return ble_hs_hci_cmd_tx(
+        BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_START_ENCRYPT), &cmd,
+        sizeof(cmd), NULL, 0);
 }
 
 static void
-ble_sm_enc_start_exec(struct ble_sm_proc *proc, struct ble_sm_result *res,
-                      void *arg)
+ble_sm_enc_start_exec(struct ble_sm_proc* proc, struct ble_sm_result* res,
+                      void* arg)
 {
-    struct hci_start_encrypt cmd;
+    struct ble_hci_le_f_encrypt cmd;
+
+    // struct hci_start_encrypt cmd;
     int rc;
 
     BLE_HS_DBG_ASSERT(proc->flags & BLE_SM_PROC_F_INITIATOR);
 
-    cmd.connection_handle = proc->conn_handle;
-    cmd.encrypted_diversifier = 0;
-    cmd.random_number = 0;
-    memcpy(cmd.long_term_key, proc->ltk, sizeof cmd.long_term_key);
+    cmd.conn_handle = proc->conn_handle;
+
+    memcpy(cmd.ltk, proc->ltk, 16);
+    rc = ble_hs_hci_cmd_tx(BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_F_ENCRYPT),
+                           &cmd, sizeof(cmd), NULL, 0);
 
-    rc = ble_sm_start_encrypt_tx(&cmd);
     if (rc != 0) {
+        // BLE_HS_LOG(DEBUG, "Error ble_hs_hci_cmd_tx %d\n", rc);
         res->sm_err = BLE_SM_ERR_UNSPECIFIED;
         res->app_status = rc;
         res->enc_cb = 1;
     }
+    if (proc->flags & BLE_SM_PROC_F_BONDING) {
+        // Before starting encryption, we need to persist the keys and set bonding to true
+        memcpy(proc->peer_keys.pubkey, proc->pub_key_peer.x,
+               sizeof(proc->pub_key_peer));
+        proc->peer_keys.pubkey_valid = 1;
+        res->bonded = 1;
+    }
+
+    // cmd.connection_handle = proc->conn_handle;
+    // cmd.encrypted_diversifier = 0;
+    // cmd.random_number = 0;
+    // memcpy(cmd.long_term_key, proc->ltk, sizeof cmd.long_term_key);
+    // BLE_HS_LOG_INFO("\nStarting Encryption\n");
+    // rc = ble_sm_start_encrypt_tx(&cmd);
+    // if (rc != 0) {
+    //     res->sm_err = BLE_SM_ERR_UNSPECIFIED;
+    //     res->app_status = rc;
+    //     res->enc_cb = 1;
+    // }
 }
 
 static void
-ble_sm_enc_restore_exec(struct ble_sm_proc *proc, struct ble_sm_result *res,
-                        void *arg)
+ble_sm_enc_restore_exec(struct ble_sm_proc* proc, struct ble_sm_result* res,
+                        void* arg)
 {
-    struct hci_start_encrypt *cmd;
+    struct hci_start_encrypt* cmd;
 
     BLE_HS_DBG_ASSERT(proc->flags & BLE_SM_PROC_F_INITIATOR);
 
@@ -1120,7 +1168,7 @@ static void
 ble_sm_enc_event_rx(uint16_t conn_handle, uint8_t evt_status, int encrypted)
 {
     struct ble_sm_result res;
-    struct ble_sm_proc *proc;
+    struct ble_sm_proc* proc;
     int authenticated;
     int bonded;
     int key_size;
@@ -1145,18 +1193,21 @@ ble_sm_enc_event_rx(uint16_t conn_handle, uint8_t evt_status, int encrypted)
                 /* If the responder has any keys to send, it sends them
                  * first.
                  */
-                proc->state = BLE_SM_PROC_STATE_KEY_EXCH;
-                if (!(proc->flags & BLE_SM_PROC_F_INITIATOR) ||
-                    proc->rx_key_flags == 0) {
+                // printf("\nReceived enc change event from CTRL\n");
+                proc->state = BLE_SM_PROC_STATE_NONE;
+                // proc->state = BLE_SM_PROC_STATE_KEY_EXCH;
+                // if (!(proc->flags & BLE_SM_PROC_F_INITIATOR) ||
+                //     proc->rx_key_flags == 0) {
 
-                    res.execute = 1;
-                }
+                //     res.execute = 1;
+                // }
 
-                key_size = proc->key_size;
-            } else {
-                /* Failure or no keys to exchange; procedure is complete. */
-                proc->state = BLE_SM_PROC_STATE_NONE;
+                // key_size = proc->key_size;
             }
+            // else {
+            //     /* Failure or no keys to exchange; procedure is complete. */
+            //     proc->state = BLE_SM_PROC_STATE_NONE;
+            // }
             if (proc->flags & BLE_SM_PROC_F_AUTHENTICATED) {
                 authenticated = 1;
             }
@@ -1213,7 +1264,7 @@ ble_sm_enc_event_rx(uint16_t conn_handle, uint8_t evt_status, int encrypted)
 }
 
 void
-ble_sm_enc_change_rx(const struct ble_hci_ev_enrypt_chg *ev)
+ble_sm_enc_change_rx(const struct ble_hci_ev_enrypt_chg* ev)
 {
     /* For encrypted state: read LE-encryption bit; ignore BR/EDR and reserved
      * bits.
@@ -1223,7 +1274,7 @@ ble_sm_enc_change_rx(const struct ble_hci_ev_enrypt_chg *ev)
 }
 
 void
-ble_sm_enc_key_refresh_rx(const struct ble_hci_ev_enc_key_refresh *ev)
+ble_sm_enc_key_refresh_rx(const struct ble_hci_ev_enc_key_refresh* ev)
 {
     ble_sm_enc_event_rx(le16toh(ev->conn_handle), ev->status, 1);
 }
@@ -1234,7 +1285,7 @@ ble_sm_enc_key_refresh_rx(const struct ble_hci_ev_enc_key_refresh *ev)
 
 static int
 ble_sm_retrieve_ltk(uint16_t ediv, uint64_t rand, uint8_t peer_addr_type,
-                    uint8_t *peer_addr, struct ble_store_value_sec *value_sec)
+                    uint8_t* peer_addr, struct ble_store_value_sec* value_sec)
 {
     struct ble_store_key_sec key_sec;
     int rc;
@@ -1252,7 +1303,7 @@ ble_sm_retrieve_ltk(uint16_t ediv, uint64_t rand, uint8_t peer_addr_type,
 }
 
 static int
-ble_sm_ltk_req_reply_tx(uint16_t conn_handle, const uint8_t *ltk)
+ble_sm_ltk_req_reply_tx(uint16_t conn_handle, const uint8_t* ltk)
 {
     struct ble_hci_le_lt_key_req_reply_cp cmd;
     struct ble_hci_le_lt_key_req_reply_rp rsp;
@@ -1261,9 +1312,9 @@ ble_sm_ltk_req_reply_tx(uint16_t conn_handle, const uint8_t *ltk)
     cmd.conn_handle = htole16(conn_handle);
     memcpy(cmd.ltk, ltk, 16);
 
-    rc = ble_hs_hci_cmd_tx(BLE_HCI_OP(BLE_HCI_OGF_LE,
-                                      BLE_HCI_OCF_LE_LT_KEY_REQ_REPLY),
-                           &cmd, sizeof(cmd), &rsp, sizeof(rsp));
+    rc = ble_hs_hci_cmd_tx(
+        BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_LT_KEY_REQ_REPLY), &cmd,
+        sizeof(cmd), &rsp, sizeof(rsp));
     if (rc != 0) {
         return rc;
     }
@@ -1283,9 +1334,9 @@ ble_sm_ltk_req_neg_reply_tx(uint16_t conn_handle)
     int rc;
 
     cmd.conn_handle = htole16(conn_handle);
-    rc = ble_hs_hci_cmd_tx(BLE_HCI_OP(BLE_HCI_OGF_LE,
-                                      BLE_HCI_OCF_LE_LT_KEY_REQ_NEG_REPLY),
-                           &cmd, sizeof(cmd), &rsp, sizeof(rsp));
+    rc = ble_hs_hci_cmd_tx(
+        BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_LT_KEY_REQ_NEG_REPLY), &cmd,
+        sizeof(cmd), &rsp, sizeof(rsp));
     if (rc != 0) {
         return rc;
     }
@@ -1298,24 +1349,25 @@ ble_sm_ltk_req_neg_reply_tx(uint16_t conn_handle)
 }
 
 static void
-ble_sm_ltk_start_exec(struct ble_sm_proc *proc, struct ble_sm_result *res,
-                      void *arg)
+ble_sm_ltk_start_exec(struct ble_sm_proc* proc, struct ble_sm_result* res,
+                      void* arg)
 {
     BLE_HS_DBG_ASSERT(!(proc->flags & BLE_SM_PROC_F_INITIATOR));
 
     res->app_status = ble_sm_ltk_req_reply_tx(proc->conn_handle, proc->ltk);
     if (res->app_status == 0) {
         proc->state = BLE_SM_PROC_STATE_ENC_START;
-    } else {
+    }
+    else {
         res->enc_cb = 1;
     }
 }
 
 static void
-ble_sm_ltk_restore_exec(struct ble_sm_proc *proc, struct ble_sm_result *res,
-                        void *arg)
+ble_sm_ltk_restore_exec(struct ble_sm_proc* proc, struct ble_sm_result* res,
+                        void* arg)
 {
-    struct ble_store_value_sec *value_sec;
+    struct ble_store_value_sec* value_sec;
 
     BLE_HS_DBG_ASSERT(!(proc->flags & BLE_SM_PROC_F_INITIATOR));
 
@@ -1323,19 +1375,21 @@ ble_sm_ltk_restore_exec(struct ble_sm_proc *proc, struct ble_sm_result *res,
 
     if (value_sec != NULL) {
         /* Store provided a key; send it to the controller. */
-        res->app_status = ble_sm_ltk_req_reply_tx(
-            proc->conn_handle, value_sec->ltk);
+        res->app_status =
+            ble_sm_ltk_req_reply_tx(proc->conn_handle, value_sec->ltk);
 
         if (res->app_status == 0) {
             proc->key_size = value_sec->key_size;
             if (value_sec->authenticated) {
                 proc->flags |= BLE_SM_PROC_F_AUTHENTICATED;
             }
-        } else {
+        }
+        else {
             /* Notify the app if it provided a key and the procedure failed. */
             res->enc_cb = 1;
         }
-    } else {
+    }
+    else {
         /* Application does not have the requested key in its database.  Send a
          * negative reply to the controller.
          */
@@ -1349,13 +1403,13 @@ ble_sm_ltk_restore_exec(struct ble_sm_proc *proc, struct ble_sm_result *res,
 }
 
 int
-ble_sm_ltk_req_rx(const struct ble_hci_ev_le_subev_lt_key_req *ev)
+ble_sm_ltk_req_rx(const struct ble_hci_ev_le_subev_lt_key_req* ev)
 {
     struct ble_store_value_sec value_sec;
     struct ble_hs_conn_addrs addrs;
     struct ble_sm_result res;
-    struct ble_sm_proc *proc;
-    struct ble_hs_conn *conn;
+    struct ble_sm_proc* proc;
+    struct ble_hs_conn* conn;
     uint8_t peer_id_addr[6];
     int store_rc;
     int restore;
@@ -1376,27 +1430,31 @@ ble_sm_ltk_req_rx(const struct ble_hci_ev_le_subev_lt_key_req *ev)
         proc = ble_sm_proc_alloc();
         if (proc == NULL) {
             res.app_status = BLE_HS_ENOMEM;
-        } else {
+        }
+        else {
             proc->conn_handle = conn_handle;
             proc->state = BLE_SM_PROC_STATE_LTK_RESTORE;
             ble_sm_insert(proc);
 
             res.execute = 1;
         }
-    } else if (proc->state == BLE_SM_PROC_STATE_SEC_REQ) {
+    }
+    else if (proc->state == BLE_SM_PROC_STATE_SEC_REQ) {
         /* Same as above, except we solicited the encryption procedure by
          * sending a security request.
          */
         restore = 1;
         proc->state = BLE_SM_PROC_STATE_LTK_RESTORE;
         res.execute = 1;
-    } else if (proc->state == BLE_SM_PROC_STATE_LTK_START) {
+    }
+    else if (proc->state == BLE_SM_PROC_STATE_LTK_START) {
         /* Legacy pairing just completed.  Send the short term key to the
          * controller.
          */
         restore = 0;
         res.execute = 1;
-    } else {
+    }
+    else {
         /* The request is unexpected; nack and forget. */
         restore = 0;
         ble_sm_ltk_req_neg_reply_tx(conn_handle);
@@ -1418,12 +1476,13 @@ ble_sm_ltk_req_rx(const struct ble_hci_ev_le_subev_lt_key_req *ev)
     if (res.app_status == 0) {
         if (restore) {
             store_rc = ble_sm_retrieve_ltk(le16toh(ev->div), le64toh(ev->rand),
-                                            addrs.peer_id_addr.type,
+                                           addrs.peer_id_addr.type,
                                            peer_id_addr, &value_sec);
             if (store_rc == 0) {
                 /* Send the key to the controller. */
                 res.state_arg = &value_sec;
-            } else {
+            }
+            else {
                 /* Send a nack to the controller. */
                 res.state_arg = NULL;
             }
@@ -1439,43 +1498,46 @@ ble_sm_ltk_req_rx(const struct ble_hci_ev_le_subev_lt_key_req *ev)
  * $random                                                                   *
  *****************************************************************************/
 
-uint8_t *
-ble_sm_our_pair_rand(struct ble_sm_proc *proc)
+uint8_t*
+ble_sm_our_pair_rand(struct ble_sm_proc* proc)
 {
     if (proc->flags & BLE_SM_PROC_F_INITIATOR) {
         return proc->randm;
-    } else {
+    }
+    else {
         return proc->rands;
     }
 }
 
-uint8_t *
-ble_sm_peer_pair_rand(struct ble_sm_proc *proc)
+uint8_t*
+ble_sm_peer_pair_rand(struct ble_sm_proc* proc)
 {
     if (proc->flags & BLE_SM_PROC_F_INITIATOR) {
         return proc->rands;
-    } else {
+    }
+    else {
         return proc->randm;
     }
 }
 
 static void
-ble_sm_random_exec(struct ble_sm_proc *proc, struct ble_sm_result *res,
-                   void *arg)
+ble_sm_random_exec(struct ble_sm_proc* proc, struct ble_sm_result* res,
+                   void* arg)
 {
     if (proc->flags & BLE_SM_PROC_F_SC) {
         ble_sm_sc_random_exec(proc, res);
-    } else {
+    }
+    else {
         ble_sm_lgcy_random_exec(proc, res);
     }
 }
 
 static void
-ble_sm_random_rx(uint16_t conn_handle, struct os_mbuf **om,
-                 struct ble_sm_result *res)
+ble_sm_random_rx(uint16_t conn_handle, struct os_mbuf** om,
+                 struct ble_sm_result* res)
 {
-    struct ble_sm_pair_random *cmd;
-    struct ble_sm_proc *proc;
+    struct ble_sm_pair_random* cmd;
+    struct ble_sm_proc* proc;
 
     res->app_status = ble_hs_mbuf_pullup_base(om, sizeof(*cmd));
     if (res->app_status != 0) {
@@ -1484,18 +1546,20 @@ ble_sm_random_rx(uint16_t conn_handle, struct os_mbuf **om,
         return;
     }
 
-    cmd = (struct ble_sm_pair_random *)(*om)->om_data;
+    cmd = (struct ble_sm_pair_random*)(*om)->om_data;
 
     ble_hs_lock();
     proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_RANDOM, -1, NULL);
     if (proc == NULL) {
         res->app_status = BLE_HS_ENOENT;
-    } else {
+    }
+    else {
         memcpy(ble_sm_peer_pair_rand(proc), cmd->value, 16);
 
         if (proc->flags & BLE_SM_PROC_F_SC) {
             ble_sm_sc_random_rx(proc, res);
-        } else {
+        }
+        else {
             ble_sm_lgcy_random_rx(proc, res);
         }
     }
@@ -1507,24 +1571,25 @@ ble_sm_random_rx(uint16_t conn_handle, struct os_mbuf **om,
  *****************************************************************************/
 
 static void
-ble_sm_confirm_exec(struct ble_sm_proc *proc, struct ble_sm_result *res,
-                    void *arg)
+ble_sm_confirm_exec(struct ble_sm_proc* proc, struct ble_sm_result* res,
+                    void* arg)
 {
     if (!(proc->flags & BLE_SM_PROC_F_SC)) {
         ble_sm_lgcy_confirm_exec(proc, res);
-    } else {
+    }
+    else {
         ble_sm_sc_confirm_exec(proc, res);
     }
 }
 
 static void
-ble_sm_confirm_rx(uint16_t conn_handle, struct os_mbuf **om,
-                  struct ble_sm_result *res)
+ble_sm_confirm_rx(uint16_t conn_handle, struct os_mbuf** om,
+                  struct ble_sm_result* res)
 {
-    struct ble_sm_pair_confirm *cmd;
-    struct ble_sm_proc *proc;
-    uint8_t ioact;
-
+    struct ble_sm_pair_confirm* cmd;
+    struct ble_sm_proc* proc;
+    int rc;
+#if MYNEWT_VAL(ENABLE_PQ_SESSION)
     res->app_status = ble_hs_mbuf_pullup_base(om, sizeof(*cmd));
     if (res->app_status != 0) {
         res->sm_err = BLE_SM_ERR_UNSPECIFIED;
@@ -1532,35 +1597,73 @@ ble_sm_confirm_rx(uint16_t conn_handle, struct os_mbuf **om,
         return;
     }
 
-    cmd = (struct ble_sm_pair_confirm *)(*om)->om_data;
+    cmd = (struct ble_sm_pair_confirm*)(*om)->om_data;
 
     ble_hs_lock();
     proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_CONFIRM, -1, NULL);
     if (proc == NULL) {
         res->app_status = BLE_HS_ENOENT;
-    } else {
-        memcpy(proc->confirm_peer, cmd->value, 16);
+    }
+    else {
+        // We verify signature
+        ble_sm_alg_update_hash_transcript(proc->pair_hash, (uint8_t*)cmd,
+                                          sizeof(*cmd) - 16);
+        rc = ble_sm_alg_crypto_auth_verify(proc->ltk, proc->pair_hash, 32,
+                                           cmd->auth);
 
-        if (proc->flags & BLE_SM_PROC_F_INITIATOR) {
-            proc->state = BLE_SM_PROC_STATE_RANDOM;
-            res->execute = 1;
-        } else {
-            int rc;
+        if (rc != 0) {
+            BLE_HS_LOG(INFO, "Confirm signature verification failed\n");
+            res->sm_err = BLE_SM_ERR_CONFIRM_MISMATCH;
+            res->enc_cb = 1;
+            ble_sm_proc_remove(proc, NULL);
+            ble_hs_unlock();
+            return;
+        }
 
-            rc = ble_sm_io_action(proc, &ioact);
+        // Peripheral
+        if (!(proc->flags & BLE_SM_PROC_F_INITIATOR)) {
+            rc = crypto_kem_enc(ct, proc->dhkeye, cmd->key);
             if (rc != 0) {
-                BLE_HS_DBG_ASSERT(0);
-            }
-
-            if (ble_sm_ioact_state(ioact) == proc->state) {
-                proc->flags |= BLE_SM_PROC_F_ADVANCE_ON_IO;
+                memcpy(proc->dhkey, proc->ltk, sizeof(proc->ltk));
+                ble_sm_alg_hkdf(proc->dhkey, proc->dhkeye, proc->ltk);
             }
-            if (ble_sm_proc_can_advance(proc)) {
-                res->execute = 1;
+        }
+        else {
+            // Central
+            rc = crypto_kem_dec(proc->dhkeye, cmd->key, sk);
+            if (rc != 0) {
+                memcpy(proc->dhkey, proc->ltk, sizeof(proc->ltk));
+                ble_sm_alg_hkdf(proc->dhkey, proc->dhkeye, proc->ltk);
             }
         }
+        // We have derived final key now
+
+        // memcpy(proc->confirm_peer, cmd->value, 16);
+        // Central goes to enc start
+        if (proc->flags & BLE_SM_PROC_F_INITIATOR) {
+            proc->state = BLE_SM_PROC_STATE_ENC_START;
+            res->execute = 1;
+        }
+        else {
+            // Peripheral executes
+            res->execute = 1;
+            // int rc;
+
+            // rc = ble_sm_io_action(proc, &ioact);
+            // if (rc != 0) {
+            //     BLE_HS_DBG_ASSERT(0);
+            // }
+
+            // if (ble_sm_ioact_state(ioact) == proc->state) {
+            //     proc->flags |= BLE_SM_PROC_F_ADVANCE_ON_IO;
+            // }
+            // if (ble_sm_proc_can_advance(proc)) {
+            //     res->execute = 1;
+            // }
+        }
     }
     ble_hs_unlock();
+#endif
 }
 
 /*****************************************************************************
@@ -1568,17 +1671,26 @@ ble_sm_confirm_rx(uint16_t conn_handle, struct os_mbuf **om,
  *****************************************************************************/
 
 static uint8_t
-ble_sm_state_after_pair(struct ble_sm_proc *proc)
+ble_sm_state_after_pair(struct ble_sm_proc* proc)
 {
     if (proc->flags & BLE_SM_PROC_F_SC) {
-        return BLE_SM_PROC_STATE_PUBLIC_KEY;
-    } else {
+        if (proc->bonded) {
+#if MYNEWT_VAL(ENABLE_PQ_SESSION)
+            return BLE_SM_PROC_STATE_CONFIRM;
+#endif
+            return BLE_SM_PROC_STATE_ENC_START;
+        }
+        else {
+            return BLE_SM_PROC_STATE_PUBLIC_KEY;
+        }
+    }
+    else {
         return BLE_SM_PROC_STATE_CONFIRM;
     }
 }
 
 static void
-ble_sm_pair_cfg(struct ble_sm_proc *proc)
+ble_sm_pair_cfg(struct ble_sm_proc* proc)
 {
     struct ble_sm_pair_cmd *pair_req, *pair_rsp;
     uint8_t init_key_dist;
@@ -1587,8 +1699,8 @@ ble_sm_pair_cfg(struct ble_sm_proc *proc)
     uint8_t ioact;
     int rc;
 
-    pair_req = (struct ble_sm_pair_cmd *) &proc->pair_req[1];
-    pair_rsp = (struct ble_sm_pair_cmd *) &proc->pair_rsp[1];
+    pair_req = (struct ble_sm_pair_cmd*)&proc->pair_req[1];
+    pair_rsp = (struct ble_sm_pair_cmd*)&proc->pair_rsp[1];
 
     if (pair_req->authreq & BLE_SM_PAIR_AUTHREQ_SC &&
         pair_rsp->authreq & BLE_SM_PAIR_AUTHREQ_SC) {
@@ -1599,7 +1711,8 @@ ble_sm_pair_cfg(struct ble_sm_proc *proc)
     ble_sm_key_dist(proc, &init_key_dist, &resp_key_dist);
     if (proc->flags & BLE_SM_PROC_F_INITIATOR) {
         rx_key_dist = resp_key_dist;
-    } else {
+    }
+    else {
         rx_key_dist = init_key_dist;
     }
 
@@ -1621,73 +1734,114 @@ ble_sm_pair_cfg(struct ble_sm_proc *proc)
 
     proc->rx_key_flags = 0;
     if (rx_key_dist & BLE_SM_PAIR_KEY_DIST_ENC) {
-        proc->rx_key_flags |= BLE_SM_KE_F_ENC_INFO |
-                              BLE_SM_KE_F_MASTER_ID;
+        proc->rx_key_flags |= BLE_SM_KE_F_ENC_INFO | BLE_SM_KE_F_MASTER_ID;
     }
     if (rx_key_dist & BLE_SM_PAIR_KEY_DIST_ID) {
-        proc->rx_key_flags |= BLE_SM_KE_F_ID_INFO |
-                              BLE_SM_KE_F_ADDR_INFO;
+        proc->rx_key_flags |= BLE_SM_KE_F_ID_INFO | BLE_SM_KE_F_ADDR_INFO;
     }
     if (rx_key_dist & BLE_SM_PAIR_KEY_DIST_SIGN) {
         proc->rx_key_flags |= BLE_SM_KE_F_SIGN_INFO;
     }
 
-    proc->key_size = min(pair_req->max_enc_key_size,
-                         pair_rsp->max_enc_key_size);
+    proc->key_size =
+        min(pair_req->max_enc_key_size, pair_rsp->max_enc_key_size);
 
     rc = ble_sm_io_action(proc, &ioact);
     BLE_HS_DBG_ASSERT_EVAL(rc == 0);
 }
 
 static void
-ble_sm_pair_base_fill(struct ble_sm_pair_cmd *cmd)
+ble_sm_pair_base_fill(struct ble_sm_pair_cmd* cmd)
 {
     cmd->io_cap = ble_hs_cfg.sm_io_cap;
     cmd->oob_data_flag = ble_hs_cfg.sm_oob_data_flag;
     cmd->authreq = ble_sm_build_authreq();
     cmd->max_enc_key_size = BLE_SM_PAIR_KEY_SZ_MAX;
+#if !MYNEWT_VAL(ENABLE_SM_PQ)
+    memcpy(cmd->epub, ble_sm_eph_pub_key, DHKEYSIZE);
+#endif
 }
 
 static void
-ble_sm_pair_req_fill(struct ble_sm_proc *proc)
+ble_sm_pair_req_fill(struct ble_sm_proc* proc)
 {
-    struct ble_sm_pair_cmd *req;
+    struct ble_sm_pair_cmd* req;
 
-    req = (void *)(proc->pair_req + 1);
+    req = (void*)(proc->pair_req + 1);
 
     proc->pair_req[0] = BLE_SM_OP_PAIR_REQ;
     ble_sm_pair_base_fill(req);
+#if MYNEWT_VAL(ENABLE_SM_PQ)
+    memcpy(req->epub, pk, CRYPTO_PUBLICKEYBYTES);
+#endif
+    memset(req->auth, 0, 16);
     req->init_key_dist = ble_hs_cfg.sm_our_key_dist;
     req->resp_key_dist = ble_hs_cfg.sm_their_key_dist;
+
+    ble_sm_alg_update_hash_transcript(proc->pair_hash, (uint8_t*)req,
+                                      sizeof(*req) - 16);
+
+    if (proc->bonded) {
+        // If we are bonded we authenticate the first message
+        ble_sm_alg_gen_dhkey(proc->pub_key_peer.x, proc->pub_key_peer.y,
+                             ble_sm_eph_pub_key, proc->dhkeye);
+        ble_sm_alg_crypto_auth(proc->dhkeye, proc->pair_hash, 32, req->auth);
+    }
+
+    // Should work
+    // uint8_t tmp[sizeof(*req) - 16 + 32];
+    // memcpy(tmp, proc->pair_hash, 32);
+    // memcpy(tmp + 32, req, sizeof(*req)-16);
+
+    // ble_sm_alg_blake_hash(tmp, sizeof(tmp), proc->pair_hash);
 }
 
 static void
-ble_sm_pair_rsp_fill(struct ble_sm_proc *proc)
+ble_sm_pair_rsp_fill(struct ble_sm_proc* proc)
 {
-    const struct ble_sm_pair_cmd *req;
-    struct ble_sm_pair_cmd *rsp;
+    const struct ble_sm_pair_cmd* req;
+    struct ble_sm_pair_cmd* rsp;
 
-    req = (void *)(proc->pair_req + 1);
-    rsp = (void *)(proc->pair_rsp + 1);
+    req = (void*)(proc->pair_req + 1);
+    rsp = (void*)(proc->pair_rsp + 1);
 
     proc->pair_rsp[0] = BLE_SM_OP_PAIR_RSP;
     ble_sm_pair_base_fill(rsp);
 
+#if MYNEWT_VAL(ENABLE_SM_PQ)
+    // As responder we send the CT, which is 96 bytes shorter than the PK
+    memcpy(rsp->epub, ct, CRYPTO_CIPHERTEXTBYTES);
+#endif
+
     /* The response's key distribution flags field is the intersection of
      * the peer's preferences and our capabilities.
      */
-    rsp->init_key_dist = req->init_key_dist &
-                         ble_hs_cfg.sm_their_key_dist;
-    rsp->resp_key_dist = req->resp_key_dist &
-                         ble_hs_cfg.sm_our_key_dist;
+    rsp->init_key_dist = req->init_key_dist & ble_hs_cfg.sm_their_key_dist;
+    rsp->resp_key_dist = req->resp_key_dist & ble_hs_cfg.sm_our_key_dist;
+
+    ble_sm_alg_update_hash_transcript(proc->pair_hash, (uint8_t*)rsp,
+                                      sizeof(*rsp) - 16);
+
+    // uint8_t short_key[16];
+    // #if MYNEWT_VAL(ENABLE_SM_PQ) == 1
+    //     ble_sm_alg_aes_cmac(proc->dhkeye, proc->pair_hash, 32, rsp->auth);
+
+    //     // memcpy(short_key, shared, 16);
+    // #else
+    //     ble_sm_alg_aes_cmac(proc->dhkeye, proc->pair_hash, 32, rsp->auth);
+
+    //     // memcpy(short_key, proc->dhkeye, 16);
+    // #endif
+    // TODO: if does not work we have to cut dhkeye to 16 bytes using the temp val
+    // Authenticate message
+    ble_sm_alg_crypto_auth(proc->dhkeye, proc->pair_hash, 32, rsp->auth);
 }
 
 static void
-ble_sm_pair_exec(struct ble_sm_proc *proc, struct ble_sm_result *res,
-                 void *arg)
+ble_sm_pair_exec(struct ble_sm_proc* proc, struct ble_sm_result* res, void* arg)
 {
-    struct ble_sm_pair_cmd *cmd;
-    struct os_mbuf *txom;
+    struct ble_sm_pair_cmd* cmd;
+    struct os_mbuf* txom;
     uint8_t ioact;
     int is_req;
     int rc;
@@ -1701,36 +1855,57 @@ ble_sm_pair_exec(struct ble_sm_proc *proc, struct ble_sm_result *res,
         goto err;
     }
 
+    // Pairing request
     if (is_req) {
+#if MYNEWT_VAL(ENABLE_SM_PQ)
+        // BLE_HS_LOG(INFO, "\nGenerating PQ keys\n");
+        rc = crypto_kem_keypair(pk, sk);
+#else
+        rc = ble_sm_alg_gen_key_pair(ble_sm_eph_pub_key, ble_sm_eph_priv_key);
+#endif
+        // Generate ECDHE only if request, as response already have it
+        if (rc != 0) {
+            BLE_HS_LOG(ERROR, "Failed to generate DH keys");
+            goto err;
+        }
+        // TODO: modify packet structure to include (pk) only
         ble_sm_pair_req_fill(proc);
         memcpy(cmd, proc->pair_req + 1, sizeof(*cmd));
-    } else {
+    }
+    else {
         /* The response was already generated when we processed the incoming
          * request.
          */
         memcpy(cmd, proc->pair_rsp + 1, sizeof(*cmd));
 
         proc->state = ble_sm_state_after_pair(proc);
+        // Send key to controller, not sure timing is correct but let's see
+        if (proc->bonded) {
+#if !MYNEWT_VAL(ENABLE_PQ_SESSION)
+            res->execute = 1;
+#endif
+        }
 
         rc = ble_sm_io_action(proc, &ioact);
         BLE_HS_DBG_ASSERT(rc == 0);
 
-        if (ble_sm_ioact_state(ioact) == proc->state) {
-            res->passkey_params.action = ioact;
-        }
+        // if (ble_sm_ioact_state(ioact) == proc->state) {
+        //     res->passkey_params.action = ioact;
+        // }
     }
 
     rc = ble_sm_tx(proc->conn_handle, txom);
     if (rc != 0) {
         goto err;
     }
+    res->app_status = rc;
 
-    res->app_status = ble_sm_gen_pair_rand(ble_sm_our_pair_rand(proc));
-    if (res->app_status != 0) {
-        res->sm_err = BLE_SM_ERR_UNSPECIFIED;
-        res->enc_cb = 1;
-        return;
-    }
+    // res->app_status = ble_sm_gen_pair_rand(ble_sm_our_pair_rand(proc));
+    // if (res->app_status != 0) {
+    //     res->sm_err = BLE_SM_ERR_UNSPECIFIED;
+    //     res->enc_cb = 1;
+    //     return;
+    // }
 
     return;
 
@@ -1764,13 +1939,18 @@ ble_sm_verify_auth_requirements(uint8_t cmd)
 }
 
 static void
-ble_sm_pair_req_rx(uint16_t conn_handle, struct os_mbuf **om,
-                   struct ble_sm_result *res)
+ble_sm_pair_req_rx(uint16_t conn_handle, struct os_mbuf** om,
+                   struct ble_sm_result* res)
 {
-    struct ble_sm_pair_cmd *req;
-    struct ble_sm_proc *proc;
-    struct ble_sm_proc *prev;
-    struct ble_hs_conn *conn;
+    struct ble_sm_pair_cmd* req;
+    struct ble_sm_proc* proc;
+    struct ble_sm_proc* prev;
+    struct ble_hs_conn* conn;
+
+    struct ble_store_value_sec value_sec;
+    struct ble_store_key_sec key_sec;
+    struct ble_hs_conn_addrs addrs;
+
     ble_sm_proc_flags proc_flags;
     uint8_t key_size;
     int rc;
@@ -1784,8 +1964,7 @@ ble_sm_pair_req_rx(uint16_t conn_handle, struct os_mbuf **om,
         return;
     }
 
-    req = (struct ble_sm_pair_cmd *)(*om)->om_data;
-
+    req = (struct ble_sm_pair_cmd*)(*om)->om_data;
     ble_hs_lock();
 
     /* XXX: Check connection state; reject if not appropriate. */
@@ -1836,20 +2015,35 @@ ble_sm_pair_req_rx(uint16_t conn_handle, struct os_mbuf **om,
         proc->pair_req[0] = BLE_SM_OP_PAIR_REQ;
         memcpy(proc->pair_req + 1, req, sizeof(*req));
 
+        ble_sm_alg_update_hash_transcript(proc->pair_hash, (uint8_t*)req,
+                                          sizeof(*req) - 16);
+        // Should work
+        // uint8_t tmp[sizeof(*req) - 16 + 32];
+        // memcpy(tmp, proc->pair_hash, 32);
+        // memcpy(tmp + 32, req, sizeof(*req)-16);
+
+        // ble_sm_alg_sha256_digest(tmp, sizeof(tmp), proc->pair_hash);
+        // // Pair hash only PREQ
+        // // ble_sm_alg_sha256_digest(proc->pair_req + 1, sizeof(*req), proc->pair_hash);
+
         conn = ble_hs_conn_find_assert(proc->conn_handle);
         if (conn->bhc_flags & BLE_HS_CONN_F_MASTER) {
             res->sm_err = BLE_SM_ERR_CMD_NOT_SUPP;
             res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_CMD_NOT_SUPP);
-        } else if (MYNEWT_VAL(BLE_SM_LVL) == 1) {
+        }
+        else if (MYNEWT_VAL(BLE_SM_LVL) == 1) {
             res->sm_err = BLE_SM_ERR_CMD_NOT_SUPP;
             res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_CMD_NOT_SUPP);
-        } else if (req->max_enc_key_size < BLE_SM_PAIR_KEY_SZ_MIN) {
+        }
+        else if (req->max_enc_key_size < BLE_SM_PAIR_KEY_SZ_MIN) {
             res->sm_err = BLE_SM_ERR_ENC_KEY_SZ;
             res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_ENC_KEY_SZ);
-        } else if (req->max_enc_key_size > BLE_SM_PAIR_KEY_SZ_MAX) {
+        }
+        else if (req->max_enc_key_size > BLE_SM_PAIR_KEY_SZ_MAX) {
             res->sm_err = BLE_SM_ERR_INVAL;
             res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_INVAL);
-        } else if (MYNEWT_VAL(BLE_SM_SC_ONLY)) {
+        }
+        else if (MYNEWT_VAL(BLE_SM_SC_ONLY)) {
             /* Fail if Secure Connections Only mode is on and remote does not
              * meet key size requirements - MITM was checked in last step.
              * Fail if SC is not supported by peer or key size is too small
@@ -1857,21 +2051,118 @@ ble_sm_pair_req_rx(uint16_t conn_handle, struct os_mbuf **om,
             if (!(req->authreq & BLE_SM_PAIR_AUTHREQ_SC)) {
                 res->sm_err = BLE_SM_ERR_AUTHREQ;
                 res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_AUTHREQ);
-            } else if (req->max_enc_key_size != BLE_SM_PAIR_KEY_SZ_MAX) {
+            }
+            else if (req->max_enc_key_size != BLE_SM_PAIR_KEY_SZ_MAX) {
                 res->sm_err = BLE_SM_ERR_ENC_KEY_SZ;
                 res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_ENC_KEY_SZ);
             }
-        } else if (!ble_sm_verify_auth_requirements(req->authreq)) {
+        }
+        else if (!ble_sm_verify_auth_requirements(req->authreq)) {
             res->sm_err = BLE_SM_ERR_AUTHREQ;
             res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_AUTHREQ);
-        } else {
+        }
+        else {
+            // Get the address for store pubkey lookup
+            ble_hs_conn_addrs(conn, &addrs);
+            memset(&key_sec, 0, sizeof key_sec);
+            key_sec.peer_addr = addrs.peer_id_addr;
+
+            rc = ble_store_read_peer_sec(&key_sec, &value_sec);
+            if (rc == 0 && value_sec.pubkey_present) {
+                BLE_HS_LOG(INFO, "Found peer pubkey in store\n");
+                memcpy(&proc->pub_key_peer.x, value_sec.pubkey, DHKEYSIZE);
+                proc->bonded = 1;
+            }
             /* The request looks good.  Precalculate our pairing response and
              * determine some properties of the imminent link.  We need this
              * information in case this is a repeated pairing attempt (i.e., we
              * are already bonded to this peer).  In that case, we include the
              * information in a notification to the app.
              */
+
+            // Peripheral uses Central (pk) which is extracted from the packet, for now I leave it null
+            // &req->pk
+#if MYNEWT_VAL(ENABLE_SM_PQ)
+            // Here epub size is correct already
+            rc = crypto_kem_enc(ct, proc->dhkeye, req->epub);
+            // rc = ble_sm_alg_gen_shared_pq(ct, shared, NULL);
+#else
+            memcpy(&proc->eph_pub_key_peer, &req->epub, DHKEYSIZE);
+
+            // If device is bonded we verify message auth
+            if (proc->bonded) {
+                // Ec, Sp
+                rc = ble_sm_alg_gen_dhkey(proc->eph_pub_key_peer.x,
+                                          proc->eph_pub_key_peer.y,
+                                          ble_sm_sc_priv_key, proc->dhkeye);
+                if (ble_sm_alg_crypto_auth_verify(proc->dhkeye, proc->pair_hash,
+                                                  32, req->auth)) {
+                    BLE_HS_LOG(ERROR, "Failed to verify auth\n");
+                    res->sm_err = BLE_SM_ERR_AUTHREQ;
+                    res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_AUTHREQ);
+                    // TODO: abort session est.
+                }
+            }
+
+            // Generate ECDHE before doing anything else
+            rc = ble_sm_alg_gen_key_pair(ble_sm_eph_pub_key,
+                                         ble_sm_eph_priv_key);
+            // memcpy(&proc->eph_pub_key_peer, &req->epub, DHKEYSIZE);
+
+            if (proc->bonded) {
+                // Sc, Ep
+                rc = ble_sm_alg_gen_dhkey(proc->pub_key_peer.x,
+                                          proc->pub_key_peer.y,
+                                          ble_sm_eph_priv_key, proc->dhkey);
+                // Get the shared key
+                ble_sm_alg_hkdf(proc->dhkey, proc->dhkeye, proc->ltk);
+
+                memcpy(proc->dhkeye, proc->ltk, sizeof(proc->ltk));
+            }
+            else {
+                // Ec, Ep
+                rc = ble_sm_alg_gen_dhkey(proc->eph_pub_key_peer.x,
+                                          proc->eph_pub_key_peer.y,
+                                          ble_sm_eph_priv_key, proc->dhkeye);
+            }
+
+            // if (!proc->bonded) {
+            //     rc = ble_sm_alg_gen_dhkey(proc->eph_pub_key_peer.x,
+            //                               proc->eph_pub_key_peer.y,
+            //                               ble_sm_eph_priv_key, proc->dhkeye);
+            // }
+            // else {
+
+            //     // Sc, Ep
+            //     rc = ble_sm_alg_gen_dhkey(proc->pub_key_peer.x,
+            //                               proc->pub_key_peer.y,
+            //                               ble_sm_eph_priv_key, proc->dhkey);
+            //     // Get the shared key
+            //     ble_sm_alg_hkdf(proc->dhkey, proc->dhkeye, proc->ltk);
+
+            //     // printf("\ndhkey: ");
+            //     // for (int i = 0; i < 32; i++) {
+            //     //     printf("%02x", proc->ltk[i]);
+            //     // }
+            //     // printf("\n");
+            //     memcpy(proc->dhkeye, proc->ltk, sizeof(proc->ltk));
+            // }
+
+#endif
+            // if (rc != 0) {
+            //     return;
+            // }
+            // to do also adjust hash transcripts
+
+            if (rc != 0) {
+                BLE_HS_LOG(ERROR, "DH Computations Error");
+                res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_DHKEY);
+                res->sm_err = BLE_SM_ERR_DHKEY;
+                // res->enc_cb = 1;
+            }
+
             ble_sm_pair_rsp_fill(proc);
+
             ble_sm_pair_cfg(proc);
 
             proc_flags = proc->flags;
@@ -1886,21 +2177,24 @@ ble_sm_pair_req_rx(uint16_t conn_handle, struct os_mbuf **om,
      * application an opportunity to delete the old bond.
      */
     if (res->app_status == 0) {
-        rc = ble_sm_chk_repeat_pairing(conn_handle, proc_flags, key_size);
-        if (rc != 0) {
-            /* The app indicated that the pairing request should be ignored. */
-            res->app_status = rc;
-            res->execute = 0;
+        if (proc->bonded) {
+            // persist this bonding
         }
+        // rc = ble_sm_chk_repeat_pairing(conn_handle, proc_flags, key_size);
+        // if (rc != 0) {
+        //     /* The app indicated that the pairing request should be ignored. */
+        //     res->app_status = rc;
+        //     res->execute = 0;
+        // }
     }
 }
 
 static void
-ble_sm_pair_rsp_rx(uint16_t conn_handle, struct os_mbuf **om,
-                   struct ble_sm_result *res)
+ble_sm_pair_rsp_rx(uint16_t conn_handle, struct os_mbuf** om,
+                   struct ble_sm_result* res)
 {
-    struct ble_sm_pair_cmd *rsp;
-    struct ble_sm_proc *proc;
+    struct ble_sm_pair_cmd* rsp;
+    struct ble_sm_proc* proc;
     uint8_t ioact;
     int rc;
 
@@ -1910,7 +2204,7 @@ ble_sm_pair_rsp_rx(uint16_t conn_handle, struct os_mbuf **om,
         return;
     }
 
-    rsp = (struct ble_sm_pair_cmd *)(*om)->om_data;
+    rsp = (struct ble_sm_pair_cmd*)(*om)->om_data;
 
     ble_hs_lock();
     proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_PAIR, 1, NULL);
@@ -1918,22 +2212,135 @@ ble_sm_pair_rsp_rx(uint16_t conn_handle, struct os_mbuf **om,
         proc->pair_rsp[0] = BLE_SM_OP_PAIR_RSP;
         memcpy(proc->pair_rsp + 1, rsp, sizeof(*rsp));
 
+        ble_sm_alg_update_hash_transcript(proc->pair_hash, (uint8_t*)rsp,
+                                          sizeof(*rsp) - 16);
+
+        // uint8_t tmp[sizeof(*rsp) + 32];
+        // memcpy(tmp, proc->pair_hash, 32);
+        // memcpy(tmp + 32, rsp, sizeof(*rsp));
+
+        // ble_sm_alg_sha256_digest(tmp, sizeof(tmp), proc->pair_hash);
+
         if (rsp->max_enc_key_size < BLE_SM_PAIR_KEY_SZ_MIN) {
             res->sm_err = BLE_SM_ERR_ENC_KEY_SZ;
             res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_ENC_KEY_SZ);
-        } else if (rsp->max_enc_key_size > BLE_SM_PAIR_KEY_SZ_MAX) {
+        }
+        else if (rsp->max_enc_key_size > BLE_SM_PAIR_KEY_SZ_MAX) {
             res->sm_err = BLE_SM_ERR_INVAL;
             res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_INVAL);
-        } else if (MYNEWT_VAL(BLE_SM_SC_ONLY) && (rsp->max_enc_key_size != BLE_SM_PAIR_KEY_SZ_MAX)) {
+        }
+        else if (MYNEWT_VAL(BLE_SM_SC_ONLY) &&
+                 (rsp->max_enc_key_size != BLE_SM_PAIR_KEY_SZ_MAX)) {
             /* Fail if Secure Connections Only mode is on and remote does not meet
             * key size requirements - MITM was checked in last step
             */
             res->sm_err = BLE_SM_ERR_ENC_KEY_SZ;
             res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_ENC_KEY_SZ);
-        } else if (!ble_sm_verify_auth_requirements(rsp->authreq)) {
+        }
+        else if (!ble_sm_verify_auth_requirements(rsp->authreq)) {
             res->sm_err = BLE_SM_ERR_AUTHREQ;
             res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_AUTHREQ);
-        } else {
+        }
+        else {
+
+            // Central pq derivation
+            // the second parameter comes from the pairing response
+#if MYNEWT_VAL(ENABLE_SM_PQ)
+            // memcpy(ct, rsp->epub, CRYPTO_CIPHERTEXTBYTES);
+            rc = crypto_kem_dec(proc->dhkeye, rsp->epub, sk);
+            // rc = ble_sm_alg_gen_shared_pq(ct, shared, rsp->epub, sk);
+#else
+            memcpy(&proc->eph_pub_key_peer, rsp->epub, sizeof(rsp->epub));
+
+            if (!proc->bonded) {
+                rc = ble_sm_alg_gen_dhkey(proc->eph_pub_key_peer.x,
+                                          proc->eph_pub_key_peer.y,
+                                          ble_sm_eph_priv_key, proc->dhkeye);
+            }
+            else {
+                // Ec, Sp
+                rc = ble_sm_alg_gen_dhkey(proc->pub_key_peer.x,
+                                          proc->pub_key_peer.y,
+                                          ble_sm_eph_priv_key, proc->dhkeye);
+                // Sc, Ep
+                rc = ble_sm_alg_gen_dhkey(proc->eph_pub_key_peer.x,
+                                          proc->eph_pub_key_peer.y,
+                                          ble_sm_sc_priv_key, proc->dhkey);
+                // Get the shared key
+                ble_sm_alg_hkdf(proc->dhkey, proc->dhkeye, proc->ltk);
+                // printf("\ndhkey: ");
+                // for (int i = 0; i < 32; i++) {
+                //     printf("%02x", proc->ltk[i]);
+                // }
+                // printf("\n");
+                memcpy(proc->dhkeye, proc->ltk, sizeof(proc->ltk));
+            }
+#endif
+            if (rc != 0) {
+                res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_DHKEY);
+                res->sm_err = BLE_SM_ERR_DHKEY;
+                // res->enc_cb = 1;
+            }
+
+            // Shorten the key for AES-128
+            //             uint8_t short_key[16];
+            // #if MYNEWT_VAL(ENABLE_SM_PQ) == 1
+            //             memcpy(short_key, shared, 16);
+            // #else
+            //             memcpy(short_key, proc->dhkeye, 16);
+            // #endif
+
+            if (ble_sm_alg_crypto_auth_verify(proc->dhkeye, proc->pair_hash, 32,
+                                              rsp->auth)) {
+                BLE_HS_LOG(INFO, "\nMAC mismatch\n");
+                res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_AUTHREQ);
+                res->sm_err = BLE_SM_ERR_AUTHREQ;
+                res->enc_cb = 1;
+                return;
+            }
+
+            // uint8_t tmp_mac[16];
+            // // Authenticate message
+            // ble_sm_alg_crypto_auth(proc->dhkeye, proc->pair_hash, 32, tmp_mac);
+
+            // // Check if the MAC is correct
+            // if (memcmp(tmp_mac, rsp->auth, 16) != 0) {
+            //     BLE_HS_LOG_INFO("\nMAC mismatch\n");
+            //     res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_AUTHREQ);
+            //     res->sm_err = BLE_SM_ERR_AUTHREQ;
+            //     res->enc_cb = 1;
+            //     return;
+            // }
+            if (!proc->bonded) {
+                // Add check for Peripheral
+                if (proc->pair_alg == BLE_SM_PAIR_ALG_OOB) {
+                    uint8_t tmp[16];
+                    memcpy(tmp, proc->dhkey, 16);
+                    // TODO: prepare this in python to test
+                    ble_sm_alg_ckdf(psk, tmp, proc->dhkeye);
+                    // TODO: ratchet the OOB secret
+                    // proc->state = BLE_SM_PROC_STATE_RANDOM;
+                }
+                else if (proc->pair_alg == BLE_SM_PAIR_ALG_NUMCMP) {
+                    uint8_t tmp[16];
+                    memcpy(tmp, proc->dhkeye, 16);
+                    // TODO: dynamically handle counter
+                    uint32_t num = ble_sm_alg_cotp(tmp, 0);
+                }
+                else if (proc->pair_alg == BLE_SM_PAIR_ALG_PASSKEY) {
+                    uint8_t tmp[16];
+                    memcpy(tmp, proc->dhkeye, 16);
+                    // TODO: dynamically handle counter
+                    uint32_t num = ble_sm_alg_cotp(tmp, 0);
+                }
+                // else if (proc->pair_alg == BLE_SM_PAIR_ALG_JW) {
+                //     // just a zeroed kdf we could remove it
+                //     memset(proc->dhkey, 0, sizeof(proc->dhkey));
+                //     ble_sm_alg_hkdf(proc->dhkeye, proc->dhkey, proc->ltk);
+                //     memcpy(proc->dhkeye, proc->ltk, sizeof(proc->dhkeye));
+                // }
+            }
+
             ble_sm_pair_cfg(proc);
 
             rc = ble_sm_io_action(proc, &ioact);
@@ -1941,7 +2348,8 @@ ble_sm_pair_rsp_rx(uint16_t conn_handle, struct os_mbuf **om,
                 res->sm_err = BLE_SM_ERR_AUTHREQ;
                 res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_AUTHREQ);
                 res->enc_cb = 1;
-            } else {
+            }
+            else {
                 proc->state = ble_sm_state_after_pair(proc);
                 if (ble_sm_ioact_state(ioact) == proc->state) {
                     res->passkey_params.action = ioact;
@@ -1961,11 +2369,11 @@ ble_sm_pair_rsp_rx(uint16_t conn_handle, struct os_mbuf **om,
  *****************************************************************************/
 
 static void
-ble_sm_sec_req_exec(struct ble_sm_proc *proc, struct ble_sm_result *res,
-                    void *arg)
+ble_sm_sec_req_exec(struct ble_sm_proc* proc, struct ble_sm_result* res,
+                    void* arg)
 {
-    struct ble_sm_sec_req *cmd;
-    struct os_mbuf *txom;
+    struct ble_sm_sec_req* cmd;
+    struct os_mbuf* txom;
     int rc;
 
     cmd = ble_sm_cmd_get(BLE_SM_OP_SEC_REQ, sizeof(*cmd), &txom);
@@ -1983,14 +2391,14 @@ ble_sm_sec_req_exec(struct ble_sm_proc *proc, struct ble_sm_result *res,
 }
 
 static void
-ble_sm_sec_req_rx(uint16_t conn_handle, struct os_mbuf **om,
-                  struct ble_sm_result *res)
+ble_sm_sec_req_rx(uint16_t conn_handle, struct os_mbuf** om,
+                  struct ble_sm_result* res)
 {
     struct ble_store_value_sec value_sec;
     struct ble_store_key_sec key_sec;
     struct ble_hs_conn_addrs addrs;
-    struct ble_sm_sec_req *cmd;
-    struct ble_hs_conn *conn;
+    struct ble_sm_sec_req* cmd;
+    struct ble_hs_conn* conn;
     int authreq_mitm;
 
     res->app_status = ble_hs_mbuf_pullup_base(om, sizeof(*cmd));
@@ -1998,7 +2406,7 @@ ble_sm_sec_req_rx(uint16_t conn_handle, struct os_mbuf **om,
         return;
     }
 
-    cmd = (struct ble_sm_sec_req *)(*om)->om_data;
+    cmd = (struct ble_sm_sec_req*)(*om)->om_data;
 
     /* XXX: Reject if:
      *     o authreq-reserved flags set?
@@ -2018,7 +2426,8 @@ ble_sm_sec_req_rx(uint16_t conn_handle, struct os_mbuf **om,
     if (!(conn->bhc_flags & BLE_HS_CONN_F_MASTER)) {
         res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_CMD_NOT_SUPP);
         res->sm_err = BLE_SM_ERR_CMD_NOT_SUPP;
-    } else {
+    }
+    else {
         /* We will be querying the SM database for a key corresponding to the
          * sender; remember the sender's address while the connection list is
          * locked.
@@ -2036,7 +2445,8 @@ ble_sm_sec_req_rx(uint16_t conn_handle, struct os_mbuf **om,
          */
         if (cmd->authreq & BLE_SM_PAIR_AUTHREQ_BOND) {
             res->app_status = ble_store_read_peer_sec(&key_sec, &value_sec);
-        } else {
+        }
+        else {
             res->app_status = BLE_HS_ENOENT;
         }
         if (res->app_status == 0) {
@@ -2050,13 +2460,11 @@ ble_sm_sec_req_rx(uint16_t conn_handle, struct os_mbuf **om,
         }
 
         if (res->app_status == 0) {
-            res->app_status = ble_sm_enc_initiate(conn_handle,
-                                                  value_sec.key_size,
-                                                  value_sec.ltk,
-                                                  value_sec.ediv,
-                                                  value_sec.rand_num,
-                                                  value_sec.authenticated);
-        } else {
+            res->app_status = ble_sm_enc_initiate(
+                conn_handle, value_sec.key_size, value_sec.ltk, value_sec.ediv,
+                value_sec.rand_num, value_sec.authenticated);
+        }
+        else {
             res->app_status = ble_sm_pair_initiate(conn_handle);
         }
     }
@@ -2067,7 +2475,7 @@ ble_sm_sec_req_rx(uint16_t conn_handle, struct os_mbuf **om,
  *****************************************************************************/
 
 static void
-ble_sm_key_exch_success(struct ble_sm_proc *proc, struct ble_sm_result *res)
+ble_sm_key_exch_success(struct ble_sm_proc* proc, struct ble_sm_result* res)
 {
     /* The procedure is now complete.  Update connection bonded state and
      * terminate procedure.
@@ -2075,8 +2483,7 @@ ble_sm_key_exch_success(struct ble_sm_proc *proc, struct ble_sm_result *res)
     int bonded = !!(proc->flags & BLE_SM_PROC_F_BONDING);
     ble_sm_update_sec_state(proc->conn_handle, 1,
                             !!(proc->flags & BLE_SM_PROC_F_AUTHENTICATED),
-                            bonded,
-                            proc->key_size);
+                            bonded, proc->key_size);
     proc->state = BLE_SM_PROC_STATE_NONE;
 
     res->app_status = 0;
@@ -2086,21 +2493,21 @@ ble_sm_key_exch_success(struct ble_sm_proc *proc, struct ble_sm_result *res)
 }
 
 static void
-ble_sm_key_exch_exec(struct ble_sm_proc *proc, struct ble_sm_result *res,
-                     void *arg)
+ble_sm_key_exch_exec(struct ble_sm_proc* proc, struct ble_sm_result* res,
+                     void* arg)
 {
-    struct ble_sm_id_addr_info *addr_info;
+    struct ble_sm_id_addr_info* addr_info;
     struct ble_hs_conn_addrs addrs;
-    struct ble_sm_sign_info *sign_info;
-    struct ble_sm_master_id *master_id;
-    struct ble_sm_enc_info *enc_info;
-    struct ble_sm_id_info *id_info;
-    struct ble_hs_conn *conn;
+    struct ble_sm_sign_info* sign_info;
+    struct ble_sm_master_id* master_id;
+    struct ble_sm_enc_info* enc_info;
+    struct ble_sm_id_info* id_info;
+    struct ble_hs_conn* conn;
     uint8_t init_key_dist;
     uint8_t resp_key_dist;
     uint8_t our_key_dist;
-    struct os_mbuf *txom;
-    const uint8_t *irk;
+    struct os_mbuf* txom;
+    const uint8_t* irk;
     struct ble_store_gen_key gen_key;
     int ltk_gen = 0;
     int rc;
@@ -2108,7 +2515,8 @@ ble_sm_key_exch_exec(struct ble_sm_proc *proc, struct ble_sm_result *res,
     ble_sm_key_dist(proc, &init_key_dist, &resp_key_dist);
     if (proc->flags & BLE_SM_PROC_F_INITIATOR) {
         our_key_dist = init_key_dist;
-    } else {
+    }
+    else {
         our_key_dist = resp_key_dist;
     }
 
@@ -2148,7 +2556,8 @@ ble_sm_key_exch_exec(struct ble_sm_proc *proc, struct ble_sm_result *res,
 
             /* store LTK before sending since ble_sm_tx consumes tx mbuf */
             memcpy(proc->our_keys.ltk, enc_info->ltk, 16);
-        } else {
+        }
+        else {
             memcpy(enc_info->ltk, proc->our_keys.ltk, 16);
         }
         proc->our_keys.ltk_valid = 1;
@@ -2159,8 +2568,8 @@ ble_sm_key_exch_exec(struct ble_sm_proc *proc, struct ble_sm_result *res,
         }
 
         /* Send master identification. */
-        master_id = ble_sm_cmd_get(BLE_SM_OP_MASTER_ID, sizeof(*master_id),
-                                   &txom);
+        master_id =
+            ble_sm_cmd_get(BLE_SM_OP_MASTER_ID, sizeof(*master_id), &txom);
         if (!master_id) {
             rc = BLE_HS_ENOMEM;
             goto err;
@@ -2180,7 +2589,8 @@ ble_sm_key_exch_exec(struct ble_sm_proc *proc, struct ble_sm_result *res,
 
             proc->our_keys.rand_val = master_id->rand_val;
             proc->our_keys.ediv = master_id->ediv;
-        } else {
+        }
+        else {
             master_id->ediv = proc->our_keys.ediv;
             master_id->rand_val = proc->our_keys.rand_val;
         }
@@ -2194,8 +2604,8 @@ ble_sm_key_exch_exec(struct ble_sm_proc *proc, struct ble_sm_result *res,
 
     if (our_key_dist & BLE_SM_PAIR_KEY_DIST_ID) {
         /* Send identity information. */
-        id_info = ble_sm_cmd_get(BLE_SM_OP_IDENTITY_INFO, sizeof(*id_info),
-                                 &txom);
+        id_info =
+            ble_sm_cmd_get(BLE_SM_OP_IDENTITY_INFO, sizeof(*id_info), &txom);
         if (!id_info) {
             rc = BLE_HS_ENOMEM;
             goto err;
@@ -2242,8 +2652,8 @@ ble_sm_key_exch_exec(struct ble_sm_proc *proc, struct ble_sm_result *res,
 
     if (our_key_dist & BLE_SM_PAIR_KEY_DIST_SIGN) {
         /* Send signing information. */
-        sign_info = ble_sm_cmd_get(BLE_SM_OP_SIGN_INFO, sizeof(*sign_info),
-                                   &txom);
+        sign_info =
+            ble_sm_cmd_get(BLE_SM_OP_SIGN_INFO, sizeof(*sign_info), &txom);
         if (!sign_info) {
             rc = BLE_HS_ENOMEM;
             goto err;
@@ -2256,7 +2666,8 @@ ble_sm_key_exch_exec(struct ble_sm_proc *proc, struct ble_sm_result *res,
             if (rc == 0) {
                 memcpy(proc->our_keys.csrk, gen_key.csrk, 16);
             }
-        } else {
+        }
+        else {
             rc = -1;
         }
 
@@ -2268,7 +2679,8 @@ ble_sm_key_exch_exec(struct ble_sm_proc *proc, struct ble_sm_result *res,
             }
 
             memcpy(proc->our_keys.csrk, sign_info->sig_key, 16);
-        } else {
+        }
+        else {
             memcpy(sign_info->sig_key, proc->our_keys.csrk, 16);
         }
         proc->our_keys.csrk_valid = 1;
@@ -2293,7 +2705,7 @@ err:
 }
 
 static void
-ble_sm_key_rxed(struct ble_sm_proc *proc, struct ble_sm_result *res)
+ble_sm_key_rxed(struct ble_sm_proc* proc, struct ble_sm_result* res)
 {
     BLE_HS_LOG(DEBUG, "rx_key_flags=0x%02x\n", proc->rx_key_flags);
 
@@ -2303,18 +2715,19 @@ ble_sm_key_rxed(struct ble_sm_proc *proc, struct ble_sm_result *res)
          */
         if (proc->flags & BLE_SM_PROC_F_INITIATOR) {
             res->execute = 1;
-        } else {
+        }
+        else {
             ble_sm_key_exch_success(proc, res);
         }
     }
 }
 
 static void
-ble_sm_enc_info_rx(uint16_t conn_handle, struct os_mbuf **om,
-                   struct ble_sm_result *res)
+ble_sm_enc_info_rx(uint16_t conn_handle, struct os_mbuf** om,
+                   struct ble_sm_result* res)
 {
-    struct ble_sm_enc_info *cmd;
-    struct ble_sm_proc *proc;
+    struct ble_sm_enc_info* cmd;
+    struct ble_sm_proc* proc;
 
     res->app_status = ble_hs_mbuf_pullup_base(om, sizeof(*cmd));
     if (res->app_status != 0) {
@@ -2323,7 +2736,7 @@ ble_sm_enc_info_rx(uint16_t conn_handle, struct os_mbuf **om,
         return;
     }
 
-    cmd = (struct ble_sm_enc_info *)(*om)->om_data;
+    cmd = (struct ble_sm_enc_info*)(*om)->om_data;
 
     ble_hs_lock();
 
@@ -2331,7 +2744,8 @@ ble_sm_enc_info_rx(uint16_t conn_handle, struct os_mbuf **om,
     if (proc == NULL) {
         res->app_status = BLE_HS_ENOENT;
         res->sm_err = BLE_SM_ERR_UNSPECIFIED;
-    } else {
+    }
+    else {
         proc->rx_key_flags &= ~BLE_SM_KE_F_ENC_INFO;
         proc->peer_keys.ltk_valid = 1;
         memcpy(proc->peer_keys.ltk, cmd->ltk, 16);
@@ -2344,11 +2758,11 @@ ble_sm_enc_info_rx(uint16_t conn_handle, struct os_mbuf **om,
 }
 
 static void
-ble_sm_master_id_rx(uint16_t conn_handle, struct os_mbuf **om,
-                    struct ble_sm_result *res)
+ble_sm_master_id_rx(uint16_t conn_handle, struct os_mbuf** om,
+                    struct ble_sm_result* res)
 {
-    struct ble_sm_master_id *cmd;
-    struct ble_sm_proc *proc;
+    struct ble_sm_master_id* cmd;
+    struct ble_sm_proc* proc;
 
     res->app_status = ble_hs_mbuf_pullup_base(om, sizeof(*cmd));
     if (res->app_status != 0) {
@@ -2357,7 +2771,7 @@ ble_sm_master_id_rx(uint16_t conn_handle, struct os_mbuf **om,
         return;
     }
 
-    cmd = (struct ble_sm_master_id *)(*om)->om_data;
+    cmd = (struct ble_sm_master_id*)(*om)->om_data;
 
     ble_hs_lock();
 
@@ -2365,7 +2779,8 @@ ble_sm_master_id_rx(uint16_t conn_handle, struct os_mbuf **om,
     if (proc == NULL) {
         res->app_status = BLE_HS_ENOENT;
         res->sm_err = BLE_SM_ERR_UNSPECIFIED;
-    } else {
+    }
+    else {
         proc->rx_key_flags &= ~BLE_SM_KE_F_MASTER_ID;
         proc->peer_keys.ediv_rand_valid = 1;
 
@@ -2379,11 +2794,11 @@ ble_sm_master_id_rx(uint16_t conn_handle, struct os_mbuf **om,
 }
 
 static void
-ble_sm_id_info_rx(uint16_t conn_handle, struct os_mbuf **om,
-                  struct ble_sm_result *res)
+ble_sm_id_info_rx(uint16_t conn_handle, struct os_mbuf** om,
+                  struct ble_sm_result* res)
 {
-    struct ble_sm_id_info *cmd;
-    struct ble_sm_proc *proc;
+    struct ble_sm_id_info* cmd;
+    struct ble_sm_proc* proc;
 
     res->app_status = ble_hs_mbuf_pullup_base(om, sizeof(*cmd));
     if (res->app_status != 0) {
@@ -2392,7 +2807,7 @@ ble_sm_id_info_rx(uint16_t conn_handle, struct os_mbuf **om,
         return;
     }
 
-    cmd = (struct ble_sm_id_info *)(*om)->om_data;
+    cmd = (struct ble_sm_id_info*)(*om)->om_data;
 
     ble_hs_lock();
 
@@ -2400,7 +2815,8 @@ ble_sm_id_info_rx(uint16_t conn_handle, struct os_mbuf **om,
     if (proc == NULL) {
         res->app_status = BLE_HS_ENOENT;
         res->sm_err = BLE_SM_ERR_UNSPECIFIED;
-    } else {
+    }
+    else {
         proc->rx_key_flags &= ~BLE_SM_KE_F_ID_INFO;
 
         memcpy(proc->peer_keys.irk, cmd->irk, 16);
@@ -2413,11 +2829,11 @@ ble_sm_id_info_rx(uint16_t conn_handle, struct os_mbuf **om,
 }
 
 static void
-ble_sm_id_addr_info_rx(uint16_t conn_handle, struct os_mbuf **om,
-                       struct ble_sm_result *res)
+ble_sm_id_addr_info_rx(uint16_t conn_handle, struct os_mbuf** om,
+                       struct ble_sm_result* res)
 {
-    struct ble_sm_id_addr_info *cmd;
-    struct ble_sm_proc *proc;
+    struct ble_sm_id_addr_info* cmd;
+    struct ble_sm_proc* proc;
 
     res->app_status = ble_hs_mbuf_pullup_base(om, sizeof(*cmd));
     if (res->app_status != 0) {
@@ -2426,7 +2842,7 @@ ble_sm_id_addr_info_rx(uint16_t conn_handle, struct os_mbuf **om,
         return;
     }
 
-    cmd = (struct ble_sm_id_addr_info *)(*om)->om_data;
+    cmd = (struct ble_sm_id_addr_info*)(*om)->om_data;
 
     ble_hs_lock();
 
@@ -2434,7 +2850,8 @@ ble_sm_id_addr_info_rx(uint16_t conn_handle, struct os_mbuf **om,
     if (proc == NULL) {
         res->app_status = BLE_HS_ENOENT;
         res->sm_err = BLE_SM_ERR_UNSPECIFIED;
-    } else {
+    }
+    else {
         proc->rx_key_flags &= ~BLE_SM_KE_F_ADDR_INFO;
         proc->peer_keys.addr_valid = 1;
         proc->peer_keys.addr_type = cmd->addr_type;
@@ -2447,11 +2864,11 @@ ble_sm_id_addr_info_rx(uint16_t conn_handle, struct os_mbuf **om,
 }
 
 static void
-ble_sm_sign_info_rx(uint16_t conn_handle, struct os_mbuf **om,
-                    struct ble_sm_result *res)
+ble_sm_sign_info_rx(uint16_t conn_handle, struct os_mbuf** om,
+                    struct ble_sm_result* res)
 {
-    struct ble_sm_sign_info *cmd;
-    struct ble_sm_proc *proc;
+    struct ble_sm_sign_info* cmd;
+    struct ble_sm_proc* proc;
 
     res->app_status = ble_hs_mbuf_pullup_base(om, sizeof(*cmd));
     if (res->app_status != 0) {
@@ -2460,7 +2877,7 @@ ble_sm_sign_info_rx(uint16_t conn_handle, struct os_mbuf **om,
         return;
     }
 
-    cmd = (struct ble_sm_sign_info *)(*om)->om_data;
+    cmd = (struct ble_sm_sign_info*)(*om)->om_data;
 
     ble_hs_lock();
 
@@ -2468,7 +2885,8 @@ ble_sm_sign_info_rx(uint16_t conn_handle, struct os_mbuf **om,
     if (proc == NULL) {
         res->app_status = BLE_HS_ENOENT;
         res->sm_err = BLE_SM_ERR_UNSPECIFIED;
-    } else {
+    }
+    else {
         proc->rx_key_flags &= ~BLE_SM_KE_F_SIGN_INFO;
 
         memcpy(proc->peer_keys.csrk, cmd->sig_key, 16);
@@ -2485,19 +2903,19 @@ ble_sm_sign_info_rx(uint16_t conn_handle, struct os_mbuf **om,
  *****************************************************************************/
 
 static void
-ble_sm_fail_rx(uint16_t conn_handle, struct os_mbuf **om,
-               struct ble_sm_result *res)
+ble_sm_fail_rx(uint16_t conn_handle, struct os_mbuf** om,
+               struct ble_sm_result* res)
 {
-    struct ble_sm_pair_fail *cmd;
+    struct ble_sm_pair_fail* cmd;
 
     res->enc_cb = 1;
 
     res->app_status = ble_hs_mbuf_pullup_base(om, sizeof(*cmd));
     if (res->app_status == 0) {
-        cmd = (struct ble_sm_pair_fail *)(*om)->om_data;
+        cmd = (struct ble_sm_pair_fail*)(*om)->om_data;
 
         res->app_status = BLE_HS_SM_PEER_ERR(cmd->reason);
-        res->sm_err =  cmd->reason;
+        res->sm_err = cmd->reason;
     }
 }
 
@@ -2515,7 +2933,7 @@ int32_t
 ble_sm_timer(void)
 {
     struct ble_sm_proc_list exp_list;
-    struct ble_sm_proc *proc;
+    struct ble_sm_proc* proc;
     int32_t ticks_until_exp;
 
     /* Remove timed-out procedures from the main list and insert them into a
@@ -2546,7 +2964,7 @@ int
 ble_sm_pair_initiate(uint16_t conn_handle)
 {
     struct ble_sm_result res;
-    struct ble_sm_proc *proc;
+    struct ble_sm_proc* proc;
     int rc;
 
     memset(&res, 0, sizeof(res));
@@ -2572,7 +2990,8 @@ ble_sm_pair_initiate(uint16_t conn_handle)
     proc = ble_sm_proc_alloc();
     if (proc == NULL) {
         res.app_status = BLE_HS_ENOMEM;
-    } else {
+    }
+    else {
         proc->conn_handle = conn_handle;
         proc->state = BLE_SM_PROC_STATE_PAIR;
         proc->flags |= BLE_SM_PROC_F_INITIATOR;
@@ -2595,7 +3014,7 @@ int
 ble_sm_slave_initiate(uint16_t conn_handle)
 {
     struct ble_sm_result res;
-    struct ble_sm_proc *proc;
+    struct ble_sm_proc* proc;
 
     memset(&res, 0, sizeof(res));
 
@@ -2608,11 +3027,13 @@ ble_sm_slave_initiate(uint16_t conn_handle)
 
         /* Set pointer to null so that existing entry doesn't get freed. */
         proc = NULL;
-    } else {
+    }
+    else {
         proc = ble_sm_proc_alloc();
         if (proc == NULL) {
             res.app_status = BLE_HS_ENOMEM;
-        } else {
+        }
+        else {
             proc->conn_handle = conn_handle;
             proc->state = BLE_SM_PROC_STATE_SEC_REQ;
             ble_sm_insert(proc);
@@ -2634,12 +3055,13 @@ ble_sm_slave_initiate(uint16_t conn_handle)
  * Initiates the encryption procedure for the specified connection.
  */
 int
-ble_sm_enc_initiate(uint16_t conn_handle, uint8_t key_size,
-                    const uint8_t *ltk, uint16_t ediv,
-                    uint64_t rand_val, int auth)
+ble_sm_enc_initiate(uint16_t conn_handle, uint8_t key_size, const uint8_t* ltk,
+                    uint16_t ediv, uint64_t rand_val, int auth)
 {
+
+    // LTK is now the remote static public key
     struct ble_sm_result res;
-    struct ble_sm_proc *proc;
+    struct ble_sm_proc* proc;
     struct hci_start_encrypt cmd;
 
     memset(&res, 0, sizeof res);
@@ -2652,27 +3074,32 @@ ble_sm_enc_initiate(uint16_t conn_handle, uint8_t key_size,
 
         /* Set pointer to null so that existing entry doesn't get freed. */
         proc = NULL;
-    } else {
+    }
+    else {
         proc = ble_sm_proc_alloc();
         if (proc == NULL) {
             res.app_status = BLE_HS_ENOMEM;
-        } else {
+        }
+        else {
             proc->conn_handle = conn_handle;
             proc->key_size = key_size;
-            proc->state = BLE_SM_PROC_STATE_ENC_RESTORE;
+            proc->state = BLE_SM_PROC_STATE_PAIR;
             proc->flags |= BLE_SM_PROC_F_INITIATOR;
+            proc->bonded = 1;
+            memcpy(proc->pub_key_peer.x, ltk, DHKEYSIZE);
+
             if (auth) {
                 proc->flags |= BLE_SM_PROC_F_AUTHENTICATED;
             }
             ble_sm_insert(proc);
 
-            cmd.connection_handle = conn_handle;
-            cmd.encrypted_diversifier = ediv;
-            cmd.random_number = rand_val;
-            memcpy(cmd.long_term_key, ltk, sizeof cmd.long_term_key);
+            // cmd.connection_handle = conn_handle;
+            // cmd.encrypted_diversifier = ediv;
+            // cmd.random_number = rand_val;
+            // memcpy(cmd.long_term_key, ltk, sizeof cmd.long_term_key);
 
             res.execute = 1;
-            res.state_arg = &cmd;
+            // res.state_arg = &cmd;
         }
     }
 
@@ -2684,13 +3111,13 @@ ble_sm_enc_initiate(uint16_t conn_handle, uint8_t key_size,
 }
 
 static int
-ble_sm_rx(struct ble_l2cap_chan *chan)
+ble_sm_rx(struct ble_l2cap_chan* chan)
 {
     struct ble_sm_result res;
-    ble_sm_rx_fn *rx_cb;
+    ble_sm_rx_fn* rx_cb;
     uint8_t op;
     uint16_t conn_handle;
-    struct os_mbuf **om;
+    struct os_mbuf** om;
     int rc;
 
     STATS_INC(ble_l2cap_stats, sm_rx);
@@ -2716,10 +3143,11 @@ ble_sm_rx(struct ble_l2cap_chan *chan)
         memset(&res, 0, sizeof res);
 
         rx_cb(conn_handle, om, &res);
-        ble_sm_process_result(conn_handle, &res, op == BLE_SM_OP_PAIR_FAIL ?
-                              false : true);
+        ble_sm_process_result(conn_handle, &res,
+                              op == BLE_SM_OP_PAIR_FAIL ? false : true);
         rc = res.app_status;
-    } else {
+    }
+    else {
         rc = BLE_HS_ENOTSUP;
     }
 
@@ -2727,10 +3155,10 @@ ble_sm_rx(struct ble_l2cap_chan *chan)
 }
 
 int
-ble_sm_inject_io(uint16_t conn_handle, struct ble_sm_io *pkey)
+ble_sm_inject_io(uint16_t conn_handle, struct ble_sm_io* pkey)
 {
     struct ble_sm_result res;
-    struct ble_sm_proc *proc;
+    struct ble_sm_proc* proc;
     int rc;
     uint8_t action;
 
@@ -2741,15 +3169,19 @@ ble_sm_inject_io(uint16_t conn_handle, struct ble_sm_io *pkey)
     proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_NONE, -1, NULL);
     if (proc == NULL) {
         rc = BLE_HS_ENOENT;
-    } else if (proc->flags & BLE_SM_PROC_F_IO_INJECTED) {
+    }
+    else if (proc->flags & BLE_SM_PROC_F_IO_INJECTED) {
         rc = BLE_HS_EALREADY;
-    } else if ((ble_sm_io_action(proc, &action) == 0) && pkey->action != action) {
+    }
+    else if ((ble_sm_io_action(proc, &action) == 0) && pkey->action != action) {
         /* Application provided incorrect IO type. */
         rc = BLE_HS_EINVAL;
-    } else if (ble_sm_ioact_state(pkey->action) != proc->state) {
+    }
+    else if (ble_sm_ioact_state(pkey->action) != proc->state) {
         /* Procedure is not ready for user input. */
         rc = BLE_HS_EINVAL;
-    } else {
+    }
+    else {
         /* Assume valid input. */
         rc = 0;
 
@@ -2768,7 +3200,8 @@ ble_sm_inject_io(uint16_t conn_handle, struct ble_sm_io *pkey)
         case BLE_SM_IOACT_DISP:
             if (pkey->passkey > 999999) {
                 rc = BLE_HS_EINVAL;
-            } else {
+            }
+            else {
                 proc->flags |= BLE_SM_PROC_F_IO_INJECTED;
                 memset(proc->tk, 0, 16);
                 proc->tk[0] = (pkey->passkey >> 0) & 0xff;
@@ -2787,7 +3220,8 @@ ble_sm_inject_io(uint16_t conn_handle, struct ble_sm_io *pkey)
             if (!pkey->numcmp_accept) {
                 res.app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_NUMCMP);
                 res.sm_err = BLE_SM_ERR_NUMCMP;
-            } else {
+            }
+            else {
                 proc->flags |= BLE_SM_PROC_F_IO_INJECTED;
                 if (proc->flags & BLE_SM_PROC_F_INITIATOR ||
                     proc->flags & BLE_SM_PROC_F_ADVANCE_ON_IO) {
@@ -2804,7 +3238,8 @@ ble_sm_inject_io(uint16_t conn_handle, struct ble_sm_io *pkey)
                                           (pkey->oob_sc_data.remote != NULL))) {
                 res.app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_OOB);
                 res.sm_err = BLE_SM_ERR_OOB;
-            } else {
+            }
+            else {
                 proc->flags |= BLE_SM_PROC_F_IO_INJECTED;
                 proc->oob_data_local = pkey->oob_sc_data.local;
                 proc->oob_data_remote = pkey->oob_sc_data.remote;
@@ -2854,10 +3289,8 @@ ble_sm_init(void)
 
     STAILQ_INIT(&ble_sm_procs);
 
-    rc = os_mempool_init(&ble_sm_proc_pool,
-                         MYNEWT_VAL(BLE_SM_MAX_PROCS),
-                         sizeof (struct ble_sm_proc),
-                         ble_sm_proc_mem,
+    rc = os_mempool_init(&ble_sm_proc_pool, MYNEWT_VAL(BLE_SM_MAX_PROCS),
+                         sizeof(struct ble_sm_proc), ble_sm_proc_mem,
                          "ble_sm_proc_pool");
     if (rc != 0) {
         return rc;
@@ -2873,10 +3306,10 @@ ble_sm_init(void)
  * simple
  */
 static int
-ble_sm_rx(struct ble_l2cap_chan *chan)
+ble_sm_rx(struct ble_l2cap_chan* chan)
 {
-    struct ble_sm_pair_fail *cmd;
-    struct os_mbuf *txom;
+    struct ble_sm_pair_fail* cmd;
+    struct os_mbuf* txom;
     uint16_t handle;
     int rc;
 
@@ -2900,10 +3333,10 @@ ble_sm_rx(struct ble_l2cap_chan *chan)
 }
 #endif
 
-struct ble_l2cap_chan *
+struct ble_l2cap_chan*
 ble_sm_create_chan(uint16_t conn_handle)
 {
-    struct ble_l2cap_chan *chan;
+    struct ble_l2cap_chan* chan;
 
     chan = ble_l2cap_chan_alloc(conn_handle);
     if (chan == NULL) {
@@ -2920,7 +3353,8 @@ ble_sm_create_chan(uint16_t conn_handle)
 
 #if MYNEWT_VAL(BLE_SM_CSIS_SIRK)
 int
-ble_sm_csis_decrypt_sirk(const uint8_t *ltk, const uint8_t *enc_sirk, uint8_t *out)
+ble_sm_csis_decrypt_sirk(const uint8_t* ltk, const uint8_t* enc_sirk,
+                         uint8_t* out)
 {
     int rc;
 
@@ -2931,8 +3365,8 @@ ble_sm_csis_decrypt_sirk(const uint8_t *ltk, const uint8_t *enc_sirk, uint8_t *o
 }
 
 int
-ble_sm_csis_resolve_rsi(const uint8_t *rsi, const uint8_t *sirk,
-                        const ble_addr_t *ltk_peer_addr)
+ble_sm_csis_resolve_rsi(const uint8_t* rsi, const uint8_t* sirk,
+                        const ble_addr_t* ltk_peer_addr)
 {
     struct ble_store_key_sec key_sec;
     struct ble_store_value_sec value_sec;
@@ -2952,7 +3386,8 @@ ble_sm_csis_resolve_rsi(const uint8_t *rsi, const uint8_t *sirk,
         rc = ble_store_read_peer_sec(&key_sec, &value_sec);
         if (rc != 0) {
             return rc;
-        } else if (!value_sec.ltk_present) {
+        }
+        else if (!value_sec.ltk_present) {
             return BLE_HS_ENOENT;
         }
 
@@ -2960,7 +3395,8 @@ ble_sm_csis_resolve_rsi(const uint8_t *rsi, const uint8_t *sirk,
         if (rc != 0) {
             return rc;
         }
-    } else {
+    }
+    else {
         memcpy(plaintext_sirk, sirk, 16);
     }
 
@@ -2977,7 +3413,8 @@ ble_sm_csis_resolve_rsi(const uint8_t *rsi, const uint8_t *sirk,
 }
 
 int
-ble_sm_csis_encrypt_sirk(const uint8_t *ltk, const uint8_t *plaintext_sirk, uint8_t *out)
+ble_sm_csis_encrypt_sirk(const uint8_t* ltk, const uint8_t* plaintext_sirk,
+                         uint8_t* out)
 {
     int rc;
 
@@ -2988,7 +3425,7 @@ ble_sm_csis_encrypt_sirk(const uint8_t *ltk, const uint8_t *plaintext_sirk, uint
 }
 
 int
-ble_sm_csis_generate_rsi(const uint8_t *sirk, uint8_t *out)
+ble_sm_csis_generate_rsi(const uint8_t* sirk, uint8_t* out)
 {
     const uint8_t prand_check_all_set[3] = {0xff, 0xff, 0xef};
     const uint8_t prand_check_all_reset[3] = {0x0, 0x0, 0x40};
diff --git a/nimble/host/src/ble_sm_alg.c b/nimble/host/src/ble_sm_alg.c
index bf81f21f..34964d45 100644
--- a/nimble/host/src/ble_sm_alg.c
+++ b/nimble/host/src/ble_sm_alg.c
@@ -23,8 +23,8 @@
 #include "syscfg/syscfg.h"
 #include "nimble/nimble_opt.h"
 
-#if NIMBLE_BLE_CONNECT
-#if NIMBLE_BLE_SM
+// #if NIMBLE_BLE_CONNECT
+// #if NIMBLE_BLE_SM
 
 #include "nimble/ble.h"
 #include "ble_hs_priv.h"
@@ -32,20 +32,35 @@
 #include "tinycrypt/constants.h"
 #include "tinycrypt/utils.h"
 
-#if MYNEWT_VAL(BLE_SM_SC)
+// #if MYNEWT_VAL(BLE_SM_SC)
 #include "tinycrypt/cmac_mode.h"
+#include "tinycrypt/ccm_mode.h"
 #include "tinycrypt/ecc_dh.h"
+#include <tinycrypt/sha256.h>
+#include "x25519.h"
+// #include "blake3.h"
+// #include "blake/blake2.h"
+#include "ascon/crypto_hash.h"
+#include "ascon/crypto_auth.h"
+#include "ascon/crypto_aead.h"
+
+#if MYNEWT_VAL(ENABLE_SM_PQ) == 1
+#include "kyber/kem.h"
+#endif
+
+#include "ble_sm_priv.h"
+
 #if MYNEWT_VAL(TRNG)
 #include "trng/trng.h"
 #endif
-#endif
+// #endif
 
 #if MYNEWT_VAL(BLE_SM_SC) && MYNEWT_VAL(TRNG)
-static struct trng_dev *g_trng;
+static struct trng_dev* g_trng;
 #endif
 
 static void
-ble_sm_alg_xor_128(const uint8_t *p, const uint8_t *q, uint8_t *r)
+ble_sm_alg_xor_128(const uint8_t* p, const uint8_t* q, uint8_t* r)
 {
     int i;
 
@@ -55,8 +70,8 @@ ble_sm_alg_xor_128(const uint8_t *p, const uint8_t *q, uint8_t *r)
 }
 
 static int
-ble_sm_alg_encrypt(const uint8_t *key, const uint8_t *plaintext,
-                   uint8_t *enc_data)
+ble_sm_alg_encrypt(const uint8_t* key, const uint8_t* plaintext,
+                   uint8_t* enc_data)
 {
     struct tc_aes_key_sched_struct s;
     uint8_t tmp[16];
@@ -79,8 +94,8 @@ ble_sm_alg_encrypt(const uint8_t *key, const uint8_t *plaintext,
 }
 
 int
-ble_sm_alg_s1(const uint8_t *k, const uint8_t *r1, const uint8_t *r2,
-              uint8_t *out)
+ble_sm_alg_s1(const uint8_t* k, const uint8_t* r1, const uint8_t* r2,
+              uint8_t* out)
 {
     int rc;
 
@@ -115,11 +130,9 @@ ble_sm_alg_s1(const uint8_t *k, const uint8_t *r1, const uint8_t *r2,
 }
 
 int
-ble_sm_alg_c1(const uint8_t *k, const uint8_t *r,
-              const uint8_t *preq, const uint8_t *pres,
-              uint8_t iat, uint8_t rat,
-              const uint8_t *ia, const uint8_t *ra,
-              uint8_t *out_enc_data)
+ble_sm_alg_c1(const uint8_t* k, const uint8_t* r, const uint8_t* preq,
+              const uint8_t* pres, uint8_t iat, uint8_t rat, const uint8_t* ia,
+              const uint8_t* ra, uint8_t* out_enc_data)
 {
     uint8_t p1[16], p2[16];
     int rc;
@@ -184,16 +197,125 @@ done:
     return rc;
 }
 
-#if MYNEWT_VAL(BLE_SM_SC)
+// #if MYNEWT_VAL(BLE_SM_SC)
 
 static void
-ble_sm_alg_log_buf(const char *name, const uint8_t *buf, int len)
+ble_sm_alg_log_buf(const char* name, const uint8_t* buf, int len)
 {
     BLE_HS_LOG(DEBUG, "    %s=", name);
     ble_hs_log_flat_buf(buf, len);
     BLE_HS_LOG(DEBUG, "\n");
 }
 
+int
+ble_sm_alg_sha256_digest(uint8_t* in, unsigned int inlen, uint8_t* out)
+{
+    struct tc_sha256_state_struct s;
+    int rc;
+    rc = tc_sha256_init(&s);
+    if (rc != 1) {
+        return 1;
+    }
+    rc = tc_sha256_update(&s, (const uint8_t*)in, inlen);
+    if (rc != 1) {
+        return 1;
+    }
+    rc = tc_sha256_final(out, &s);
+    if (rc != 1) {
+        return 1;
+    }
+    return 0;
+}
+
+int
+ble_sm_alg_update_hash_transcript(uint8_t* hash, uint8_t* data,
+                                  unsigned int len)
+{
+    uint8_t tmp[TC_SHA256_DIGEST_SIZE + len];
+    // Concat and hash
+    memcpy(tmp, hash, TC_SHA256_DIGEST_SIZE);
+    memcpy(tmp + TC_SHA256_DIGEST_SIZE, data, len);
+
+    // ble_sm_alg_blake_hash(tmp, TC_SHA256_DIGEST_SIZE + len, hash);
+
+    // Use ascon hash
+    int rc = crypto_hash(hash, tmp, sizeof(tmp));
+    if (rc != 0) {
+        BLE_HS_LOG(ERROR, "Error hashing\n");
+        return rc;
+    }
+
+    // ble_sm_alg_blake_hash(tmp, TC_SHA256_DIGEST_SIZE + len, hash);
+
+    return 0;
+}
+
+int
+ble_sm_alg_aes_ccm_encrypt(uint8_t* key, uint8_t* nonce, uint8_t* data,
+                           unsigned int datalen, uint8_t* ad,
+                           unsigned int adlen, uint8_t* out)
+{
+    struct tc_aes_key_sched_struct sched;
+    struct tc_ccm_mode_struct ccm;
+    int rc;
+    size_t nlen = 13;
+    size_t mlen = 16;
+    uint8_t fixed_nonce[13] = {0};
+    // memcpy(fixed_nonce + 5, nonce, 8);
+
+    uint8_t short_key[16];
+    memcpy(short_key, key, 16);
+
+    tc_aes128_set_encrypt_key(&sched, short_key);
+
+    rc = tc_ccm_config(&ccm, &sched, fixed_nonce, nlen, mlen);
+    if (rc != 1) {
+        BLE_HS_LOG(ERROR, "Error AESCCM config\n");
+        return rc;
+    }
+
+    rc = tc_ccm_generation_encryption(out, datalen + mlen, ad, adlen, data,
+                                      datalen, &ccm);
+    if (rc != 1) {
+        BLE_HS_LOG(ERROR, "Error AESCCM encrypt\n");
+        return rc;
+    }
+    return 1;
+}
+
+int
+ble_sm_alg_aes_ccm_decrypt(uint8_t* key, uint8_t* nonce, uint8_t* in,
+                           unsigned int inlen, uint8_t* ad, unsigned int adlen,
+                           uint8_t* out)
+{
+    struct tc_aes_key_sched_struct sched;
+    struct tc_ccm_mode_struct ccm;
+    int rc;
+    uint8_t fixed_nonce[13] = {0};
+    size_t nlen = 13;
+    size_t mlen = 16;
+    // memcpy(fixed_nonce + 5, nonce, 8);
+
+    uint8_t short_key[16];
+    memcpy(short_key, key, 16);
+
+    tc_aes128_set_decrypt_key(&sched, short_key);
+
+    rc = tc_ccm_config(&ccm, &sched, fixed_nonce, nlen, mlen);
+
+    if (rc != 1) {
+        BLE_HS_LOG(ERROR, "Error AESCCM config\n");
+        return rc;
+    }
+    rc = tc_ccm_decryption_verification(out, inlen - 16, ad, adlen, in, inlen,
+                                        &ccm);
+    if (rc != 1) {
+        BLE_HS_LOG(ERROR, "Error AESCCM decrypt\n");
+        return rc;
+    }
+    return 1;
+}
+
 /**
  * Cypher based Message Authentication Code (CMAC) with AES 128 bit
  *
@@ -202,9 +324,9 @@ ble_sm_alg_log_buf(const char *name, const uint8_t *buf, int len)
  * @param len                   Length of the message in octets.
  * @param out                   Output; message authentication code.
  */
-static int
-ble_sm_alg_aes_cmac(const uint8_t *key, const uint8_t *in, size_t len,
-                    uint8_t *out)
+int
+ble_sm_alg_aes_cmac(const uint8_t* key, const uint8_t* in, size_t len,
+                    uint8_t* out)
 {
     struct tc_aes_key_sched_struct sched;
     struct tc_cmac_struct state;
@@ -224,9 +346,149 @@ ble_sm_alg_aes_cmac(const uint8_t *key, const uint8_t *in, size_t len,
     return 0;
 }
 
+static void
+clamp_private_key(uint8_t* key)
+{
+    key[0] &= 248;
+    key[31] = (key[31] & 127) | 64;
+}
+
+static void
+x25519_make_shared(uint8_t* shared_key, const uint8_t* public_key,
+                   const uint8_t* private_key)
+{
+    x25519(shared_key, private_key, public_key, 1);
+}
+
+void
+ble_sm_alg_blake_hash(uint8_t* in, unsigned int inlen, uint8_t* out)
+{
+    // struct blake3 ctx;
+
+    // blake3_init(&ctx);
+    // blake3_update(&ctx, in, inlen);
+    // blake3_out(&ctx, out, 32);
+}
+
+int
+ble_sm_alg_aead_encrypt(uint8_t* out, const uint8_t* data, size_t datalen,
+                        const uint8_t* ad, size_t adlen, uint8_t* nonce,
+                        const uint8_t* key)
+{
+    unsigned long long outlen;
+    int rc = crypto_aead_encrypt(out, &outlen, data, datalen, ad, adlen, NULL,
+                                 nonce, key);
+
+    if (rc != 0) {
+        BLE_HS_LOG(ERROR, "Error AEAD encrypt\n");
+        // return rc;
+    }
+    if (outlen != datalen + 16) {
+        BLE_HS_LOG(ERROR, "Error AEAD encrypt outlen\n");
+    }
+    return rc;
+}
+
+int
+ble_sm_alg_aead_decrypt(uint8_t* out, const uint8_t* data, size_t datalen,
+                        const uint8_t* ad, size_t adlen, uint8_t* nonce,
+                        const uint8_t* key)
+{
+    unsigned long long outlen;
+    int rc = crypto_aead_decrypt(out, &outlen, NULL, data, datalen, ad, adlen,
+                                 nonce, key);
+    if (rc != 0) {
+        BLE_HS_LOG(ERROR, "Error AEAD decrypt\n");
+        // return rc;
+    }
+    if (outlen != datalen - 16) {
+        BLE_HS_LOG(ERROR, "Error AEAD decrypt outlen\n");
+    }
+    return rc;
+}
+
+int
+ble_sm_alg_crypto_auth_verify(const uint8_t* key, const uint8_t* in,
+                              unsigned long long inlen, const uint8_t* tag)
+{
+    return crypto_auth_verify(tag, in, inlen, key);
+}
+
+int
+ble_sm_alg_crypto_auth(const uint8_t* key, const uint8_t* in, size_t len,
+                       uint8_t* out)
+{
+    return crypto_auth(out, in, len, key);
+}
+
+void
+ble_sm_alg_hkdf(uint8_t* salt, uint8_t* key, uint8_t* out)
+{
+    // Use Ascon hmac
+    uint8_t prk[16];
+    uint8_t c1 = 0x01;
+    uint8_t t1[sizeof(prk) + 1];
+
+    // Input key is only 16 bytes, the rest is discarded
+
+    // Extract
+    crypto_auth(prk, salt, 32, key);
+
+    // Expand
+    crypto_auth(t1, &c1, 1, prk);
+    memcpy(out, t1, 16);
+
+    t1[16] = 0x02;
+    crypto_auth(out + 16, t1, sizeof(t1), prk);
+}
+
+void
+ble_sm_alg_ckdf(uint8_t* salt, uint8_t* key, uint8_t* out)
+{
+    uint8_t temp_key[16];
+    uint8_t output[17] = {0};
+
+    // Temp key
+    ble_sm_alg_aes_cmac(key, salt, 32, temp_key);
+
+    // Output 1
+    output[16] = 0x01;
+    ble_sm_alg_aes_cmac(temp_key, output, 17, out);
+    // crypto_auth(out, output, 17, temp_key);
+    // Real extract and expand would continue
+
+    // Output 2
+    output[16] = 0x02;
+    memcpy(output, out, 16);
+    ble_sm_alg_aes_cmac(temp_key, output, 17, out + 16);
+}
+
+uint32_t
+ble_sm_alg_cotp(uint8_t* key, uint64_t counter)
+{
+    uint8_t res[32];
+    uint8_t counter_bytes[8];
+
+    for (int i = 7; i >= 0; i--) {
+        counter_bytes[i] = counter & 0xFF;
+        counter >>= 8;
+    }
+
+    ble_sm_alg_ckdf(counter_bytes, key, res);
+
+    uint8_t offset = res[31] & 0x0F;
+
+    uint32_t bin_code = ((uint32_t)(res[offset] & 0x7F) << 24) |
+                        ((uint32_t)res[offset + 1] << 16) |
+                        ((uint32_t)res[offset + 2] << 8) |
+                        ((uint32_t)res[offset + 3]);
+
+    return bin_code % 100000000;
+}
+
 int
-ble_sm_alg_f4(const uint8_t *u, const uint8_t *v, const uint8_t *x,
-              uint8_t z, uint8_t *out_enc_data)
+ble_sm_alg_f4(const uint8_t* u, const uint8_t* v, const uint8_t* x, uint8_t z,
+              uint8_t* out_enc_data)
 {
     uint8_t xs[16];
     uint8_t m[65];
@@ -270,23 +532,23 @@ ble_sm_alg_f4(const uint8_t *u, const uint8_t *v, const uint8_t *x,
 }
 
 int
-ble_sm_alg_f5(const uint8_t *w, const uint8_t *n1, const uint8_t *n2,
-              uint8_t a1t, const uint8_t *a1, uint8_t a2t, const uint8_t *a2,
-              uint8_t *mackey, uint8_t *ltk)
+ble_sm_alg_f5(const uint8_t* w, const uint8_t* n1, const uint8_t* n2,
+              uint8_t a1t, const uint8_t* a1, uint8_t a2t, const uint8_t* a2,
+              uint8_t* mackey, uint8_t* ltk)
 {
-    static const uint8_t salt[16] = { 0x6c, 0x88, 0x83, 0x91, 0xaa, 0xf5,
-                      0xa5, 0x38, 0x60, 0x37, 0x0b, 0xdb,
-                      0x5a, 0x60, 0x83, 0xbe };
+    static const uint8_t salt[16] = {0x6c, 0x88, 0x83, 0x91, 0xaa, 0xf5,
+                                     0xa5, 0x38, 0x60, 0x37, 0x0b, 0xdb,
+                                     0x5a, 0x60, 0x83, 0xbe};
     uint8_t m[53] = {
-        0x00, /* counter */
-        0x62, 0x74, 0x6c, 0x65, /* keyID */
+        0x00,                                           /* counter */
+        0x62, 0x74, 0x6c, 0x65,                         /* keyID */
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /*n1*/
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /*2*/
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* a1 */
         0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* a2 */
-        0x01, 0x00 /* length */
+        0x01, 0x00                                /* length */
     };
     uint8_t ws[32];
     uint8_t t[16];
@@ -338,10 +600,9 @@ ble_sm_alg_f5(const uint8_t *w, const uint8_t *n1, const uint8_t *n2,
 }
 
 int
-ble_sm_alg_f6(const uint8_t *w, const uint8_t *n1, const uint8_t *n2,
-              const uint8_t *r, const uint8_t *iocap, uint8_t a1t,
-              const uint8_t *a1, uint8_t a2t, const uint8_t *a2,
-              uint8_t *check)
+ble_sm_alg_f6(const uint8_t* w, const uint8_t* n1, const uint8_t* n2,
+              const uint8_t* r, const uint8_t* iocap, uint8_t a1t,
+              const uint8_t* a1, uint8_t a2t, const uint8_t* a2, uint8_t* check)
 {
     uint8_t ws[16];
     uint8_t m[65];
@@ -386,8 +647,8 @@ ble_sm_alg_f6(const uint8_t *w, const uint8_t *n1, const uint8_t *n2,
 }
 
 int
-ble_sm_alg_g2(const uint8_t *u, const uint8_t *v, const uint8_t *x,
-              const uint8_t *y, uint32_t *passkey)
+ble_sm_alg_g2(const uint8_t* u, const uint8_t* v, const uint8_t* x,
+              const uint8_t* y, uint32_t* passkey)
 {
     uint8_t m[80], xs[16];
     int rc;
@@ -419,8 +680,8 @@ ble_sm_alg_g2(const uint8_t *u, const uint8_t *v, const uint8_t *x,
 }
 
 int
-ble_sm_alg_csis_k1(const uint8_t *n, size_t n_len, const uint8_t *salt,
-                   const uint8_t *p, size_t p_len, uint8_t *out)
+ble_sm_alg_csis_k1(const uint8_t* n, size_t n_len, const uint8_t* salt,
+                   const uint8_t* p, size_t p_len, uint8_t* out)
 {
     int rc;
     uint8_t t[16] = {0};
@@ -455,7 +716,7 @@ ble_sm_alg_csis_k1(const uint8_t *n, size_t n_len, const uint8_t *salt,
 }
 
 int
-ble_sm_alg_csis_s1(const uint8_t *m, size_t m_len, uint8_t *out)
+ble_sm_alg_csis_s1(const uint8_t* m, size_t m_len, uint8_t* out)
 {
     int rc;
     uint8_t k_zero[16] = {0};
@@ -479,20 +740,21 @@ ble_sm_alg_csis_s1(const uint8_t *m, size_t m_len, uint8_t *out)
 }
 
 int
-ble_sm_alg_csis_sef(const uint8_t *k, const uint8_t *plaintext_sirk, uint8_t *out)
+ble_sm_alg_csis_sef(const uint8_t* k, const uint8_t* plaintext_sirk,
+                    uint8_t* out)
 {
     uint8_t salt[16];
     int rc;
     int i;
 
     /* s1("SIRKenc") */
-    rc = ble_sm_alg_csis_s1((const uint8_t *) "SIRKenc", 7, salt);
+    rc = ble_sm_alg_csis_s1((const uint8_t*)"SIRKenc", 7, salt);
     if (rc != 0) {
         return rc;
     }
 
     /* k1(K, s1("SIRKenc"), "csis") */
-    rc = ble_sm_alg_csis_k1(k, 16, salt, (const uint8_t *) "csis", 4, out);
+    rc = ble_sm_alg_csis_k1(k, 16, salt, (const uint8_t*)"csis", 4, out);
     if (rc != 0) {
         return rc;
     }
@@ -506,20 +768,20 @@ ble_sm_alg_csis_sef(const uint8_t *k, const uint8_t *plaintext_sirk, uint8_t *ou
 }
 
 int
-ble_sm_alg_csis_sdf(const uint8_t *k, const uint8_t *enc_sirk, uint8_t *out)
+ble_sm_alg_csis_sdf(const uint8_t* k, const uint8_t* enc_sirk, uint8_t* out)
 {
     uint8_t salt[16];
     int rc;
     int i;
 
     /* s1("SIRKenc") */
-    rc = ble_sm_alg_csis_s1((const uint8_t *) "SIRKenc", 7, salt);
+    rc = ble_sm_alg_csis_s1((const uint8_t*)"SIRKenc", 7, salt);
     if (rc != 0) {
         return rc;
     }
 
     /* k1(K, s1("SIRKenc"), "csis") */
-    rc = ble_sm_alg_csis_k1(k, 16, salt, (const uint8_t *) "csis", 4, out);
+    rc = ble_sm_alg_csis_k1(k, 16, salt, (const uint8_t*)"csis", 4, out);
     if (rc != 0) {
         return rc;
     }
@@ -533,7 +795,7 @@ ble_sm_alg_csis_sdf(const uint8_t *k, const uint8_t *enc_sirk, uint8_t *out)
 }
 
 int
-ble_sm_alg_csis_sih(const uint8_t *k, const uint8_t *r, uint8_t *out)
+ble_sm_alg_csis_sih(const uint8_t* k, const uint8_t* r, uint8_t* out)
 {
     uint8_t r1[16];
     int rc;
@@ -552,9 +814,14 @@ ble_sm_alg_csis_sih(const uint8_t *k, const uint8_t *r, uint8_t *out)
 }
 
 int
-ble_sm_alg_gen_dhkey(const uint8_t *peer_pub_key_x, const uint8_t *peer_pub_key_y,
-                     const uint8_t *our_priv_key, uint8_t *out_dhkey)
+ble_sm_alg_gen_dhkey(const uint8_t* peer_pub_key_x,
+                     const uint8_t* peer_pub_key_y, const uint8_t* our_priv_key,
+                     uint8_t* out_dhkey)
 {
+
+#if MYNEWT_VAL(ENABLE_SM_25519)
+    x25519_make_shared(out_dhkey, peer_pub_key_x, our_priv_key);
+#else
     uint8_t dh[32];
     uint8_t pk[64];
     uint8_t priv[32];
@@ -574,37 +841,214 @@ ble_sm_alg_gen_dhkey(const uint8_t *peer_pub_key_x, const uint8_t *peer_pub_key_
     }
 
     swap_buf(out_dhkey, dh, 32);
-
+#endif
     return 0;
 }
 
 /* based on Core Specification 4.2 Vol 3. Part H 2.3.5.6.1 */
 static const uint8_t ble_sm_alg_dbg_priv_key[32] = {
-    0x3f, 0x49, 0xf6, 0xd4, 0xa3, 0xc5, 0x5f, 0x38, 0x74, 0xc9, 0xb3, 0xe3,
-    0xd2, 0x10, 0x3f, 0x50, 0x4a, 0xff, 0x60, 0x7b, 0xeb, 0x40, 0xb7, 0x99,
-    0x58, 0x99, 0xb8, 0xa6, 0xcd, 0x3c, 0x1a, 0xbd
-};
+    0x3f, 0x49, 0xf6, 0xd4, 0xa3, 0xc5, 0x5f, 0x38, 0x74, 0xc9, 0xb3,
+    0xe3, 0xd2, 0x10, 0x3f, 0x50, 0x4a, 0xff, 0x60, 0x7b, 0xeb, 0x40,
+    0xb7, 0x99, 0x58, 0x99, 0xb8, 0xa6, 0xcd, 0x3c, 0x1a, 0xbd};
 
 #if MYNEWT_VAL(BLE_SM_SC_DEBUG_KEYS)
 static const uint8_t ble_sm_alg_dbg_pub_key[64] = {
     /* X */
-    0x20, 0xb0, 0x03, 0xd2, 0xf2, 0x97, 0xbe, 0x2c, 0x5e, 0x2c, 0x83, 0xa7,
-    0xe9, 0xf9, 0xa5, 0xb9, 0xef, 0xf4, 0x91, 0x11, 0xac, 0xf4, 0xfd, 0xdb,
-    0xcc, 0x03, 0x01, 0x48, 0x0e, 0x35, 0x9d, 0xe6,
+    0x20,
+    0xb0,
+    0x03,
+    0xd2,
+    0xf2,
+    0x97,
+    0xbe,
+    0x2c,
+    0x5e,
+    0x2c,
+    0x83,
+    0xa7,
+    0xe9,
+    0xf9,
+    0xa5,
+    0xb9,
+    0xef,
+    0xf4,
+    0x91,
+    0x11,
+    0xac,
+    0xf4,
+    0xfd,
+    0xdb,
+    0xcc,
+    0x03,
+    0x01,
+    0x48,
+    0x0e,
+    0x35,
+    0x9d,
+    0xe6,
     /* Y */
-    0xdc, 0x80, 0x9c, 0x49, 0x65, 0x2a, 0xeb, 0x6d, 0x63, 0x32, 0x9a, 0xbf,
-    0x5a, 0x52, 0x15, 0x5c, 0x76, 0x63, 0x45, 0xc2, 0x8f, 0xed, 0x30, 0x24,
-    0x74, 0x1c, 0x8e, 0xd0, 0x15, 0x89, 0xd2, 0x8b,
+    0xdc,
+    0x80,
+    0x9c,
+    0x49,
+    0x65,
+    0x2a,
+    0xeb,
+    0x6d,
+    0x63,
+    0x32,
+    0x9a,
+    0xbf,
+    0x5a,
+    0x52,
+    0x15,
+    0x5c,
+    0x76,
+    0x63,
+    0x45,
+    0xc2,
+    0x8f,
+    0xed,
+    0x30,
+    0x24,
+    0x74,
+    0x1c,
+    0x8e,
+    0xd0,
+    0x15,
+    0x89,
+    0xd2,
+    0x8b,
 };
 #endif
 
+#if MYNEWT_VAL(SELFTEST)
+/* Unit tests rely on custom RNG function not being set */
+#define ble_sm_alg_rand NULL
+#else
+/* used by uECC to get random data */
+static int
+ble_sm_alg_rand(uint8_t* dst, unsigned int size)
+{
+#if MYNEWT_VAL(TRNG)
+    size_t num;
+
+    if (!g_trng) {
+        g_trng = (struct trng_dev*)os_dev_open("trng", OS_WAIT_FOREVER, NULL);
+        assert(g_trng);
+    }
+
+    while (size) {
+        num = trng_read(g_trng, dst, size);
+        dst += num;
+        size -= num;
+    }
+#else
+    if (ble_hs_hci_rand(dst, size)) {
+        return 0;
+    }
+#endif
+
+    return 1;
+}
+#endif
+
+int
+random_data(uint8_t* dst, unsigned int size)
+{
+    return ble_sm_alg_rand(dst, size);
+}
+
+// static void newhope_generate_keypair(ble_sm_newhope_state *ls, ble_sm_newhope_state *rs) {
+//     uint8_t random_data[64];
+//     size_t pub_key_len;
+//     // Central (Initiator)
+//     if (ls->role == 0) {
+//         ble_sm_alg_rand(ls->random_data, 64);
+//         newhope_keygen(ls->public_key, &(ls->private_key), ls->random_data);
+
+//     // Peripheral (Responder)
+//     } else {
+//         // Responder's keypair is generated from the initiator's public key
+//         ble_sm_alg_rand(random_data, 32);
+//         newhope_sharedb((uint8_t *)&(ls->private_key), ls->public_key, rs->public_key, ls->random_data)
+//     }
+//     ls->generated = 1;
+// }
+
+// static void newhope_make_shared(ble_sm_newhope_state *priv_key_s, ble_sm_newhope_state *pub_key_s, uint8_t *shared_key) {
+//     if (priv_key_s->role == 0) { // Initiator
+//         newhope_shareda(shared_key, &(priv_key_s->private_key), pub_key_s->public_key);
+//     } else { // Responder
+//         if (!priv_key_s->generated){
+//             newhope_sharedb(shared_key, priv_key_s->public_key, pub_key_s->public_key, priv_key_s->random_data);
+//         }else{
+//             memcpy(shared_key, &(priv_key_s->private_key), 32);
+//         }
+
+//     }
+// }
+
+// static void newhope_set_keypair_private(ble_sm_newhope_state *ls, uint8_t *private_key) {
+//     // Central (Initiator)
+//     if (ls->role == 0) {
+//         memcpy(ls->random_data, private_key, 64);
+//         newhope_keygen(ls->public_key, &(ls->private_key), ls->random_data);
+//         ls->generated = 1;
+//     // Responder
+//     } else {
+//         memcpy(ls->random_data, private_key, 32);
+//         memset(ls->public_key, 0, 32);
+
+//     }
+// }
+
+static int
+x25519_gen_keypair(uint8_t* public, uint8_t* private)
+{
+    static uint8_t basepoint[32] = {9};
+    // TODO: Should this be done also for shared key computation?
+    basepoint[EC_PUBLIC_BYTES - 1] &= 0x7F;
+    static uint8_t zero_key[32] = {0};
+    int rc = 0;
+
+    ble_sm_alg_rand(private, 32);
+    clamp_private_key(private);
+    if (memcmp(private, zero_key, 32) != 0) {
+        rc = x25519(public, private, basepoint, 1);
+    }
+    else {
+        rc = 1;
+    }
+    return rc;
+}
+
+// int ble_sm_alg_gen_keypair_pq(uint8_t *pub, uint8_t *priv, int role) {
+//     if (role == 0) {
+//         return crypto_kem_keypair(pub, priv);
+//     }
+//     return 1;
+// }
+
+// int ble_sm_alg_gen_shared_pq(uint8_t *ct, uint8_t *pub, uint8_t *priv, uint8_t *shared_key, int role) {
+//     if (role == 1) {
+//         // pub == ct
+//         return crypto_kem_enc(ct, shared_key, pub);
+//     } else {
+//         return crypto_kem_dec(shared_key, ct, priv);
+//     }
+// }
+
 /**
  * pub: 64 bytes
  * priv: 32 bytes
  */
 int
-ble_sm_alg_gen_key_pair(uint8_t *pub, uint8_t *priv)
+ble_sm_alg_gen_key_pair(uint8_t* pub, uint8_t* priv)
 {
+#if MYNEWT_VAL(ENABLE_SM_25519)
+    return x25519_gen_keypair(pub, priv);
+#else
 #if MYNEWT_VAL(BLE_SM_SC_DEBUG_KEYS)
     swap_buf(pub, ble_sm_alg_dbg_pub_key, 32);
     swap_buf(&pub[32], &ble_sm_alg_dbg_pub_key[32], 32);
@@ -626,45 +1070,17 @@ ble_sm_alg_gen_key_pair(uint8_t *pub, uint8_t *priv)
 #endif
 
     return 0;
-}
-
-#if MYNEWT_VAL(SELFTEST)
-/* Unit tests rely on custom RNG function not being set */
-#define ble_sm_alg_rand NULL
-#else
-/* used by uECC to get random data */
-static int
-ble_sm_alg_rand(uint8_t *dst, unsigned int size)
-{
-#if MYNEWT_VAL(TRNG)
-    size_t num;
-
-    if (!g_trng) {
-        g_trng = (struct trng_dev *)os_dev_open("trng", OS_WAIT_FOREVER, NULL);
-        assert(g_trng);
-    }
-
-    while (size) {
-        num = trng_read(g_trng, dst, size);
-        dst += num;
-        size -= num;
-    }
-#else
-    if (ble_hs_hci_rand(dst, size)) {
-        return 0;
-    }
 #endif
-
-    return 1;
 }
-#endif
 
 void
 ble_sm_alg_ecc_init(void)
 {
+#if !MYNEWT_VAL(ENABLE_SM_PQ)
     uECC_set_rng(ble_sm_alg_rand);
+#endif
 }
 
-#endif
-#endif
-#endif
+// #endif
+// #endif
+// #endif
diff --git a/nimble/host/src/ble_sm_priv.h b/nimble/host/src/ble_sm_priv.h
index d8e1f035..978ca537 100644
--- a/nimble/host/src/ble_sm_priv.h
+++ b/nimble/host/src/ble_sm_priv.h
@@ -24,6 +24,9 @@
 #include "syscfg/syscfg.h"
 #include "os/queue.h"
 #include "nimble/nimble_opt.h"
+#if MYNEWT_VAL(ENABLE_SM_PQ)
+#include "kyber/kem.h"
+#endif
 
 #ifdef __cplusplus
 extern "C" {
@@ -33,24 +36,56 @@ struct ble_gap_sec_state;
 struct hci_le_lt_key_req;
 struct hci_encrypt_change;
 
-#define BLE_SM_MTU                  65
-
-#define BLE_SM_OP_PAIR_REQ                      0x01
-#define BLE_SM_OP_PAIR_RSP                      0x02
-#define BLE_SM_OP_PAIR_CONFIRM                  0x03
-#define BLE_SM_OP_PAIR_RANDOM                   0x04
-#define BLE_SM_OP_PAIR_FAIL                     0x05
-#define BLE_SM_OP_ENC_INFO                      0x06
-#define BLE_SM_OP_MASTER_ID                     0x07
-#define BLE_SM_OP_IDENTITY_INFO                 0x08
-#define BLE_SM_OP_IDENTITY_ADDR_INFO            0x09
-#define BLE_SM_OP_SIGN_INFO                     0x0a
-#define BLE_SM_OP_SEC_REQ                       0x0b
-#define BLE_SM_OP_PAIR_PUBLIC_KEY               0x0c
-#define BLE_SM_OP_PAIR_DHKEY_CHECK              0x0d
-#define BLE_SM_OP_PAIR_KEYPRESS_NOTIFY          0x0e
-
-struct ble_sm_hdr {
+#if MYNEWT_VAL(ENABLE_SM_25519)
+extern uint8_t ble_sm_sc_pub_key[32];
+extern uint8_t ble_sm_eph_pub_key[32];
+
+#else
+extern uint8_t ble_sm_sc_pub_key[64];
+extern uint8_t ble_sm_eph_pub_key[64];
+
+#endif
+extern uint8_t ble_sm_sc_priv_key[32];
+extern uint8_t ble_sm_eph_priv_key[32];
+
+#if MYNEWT_VAL(ENABLE_SM_PQ)
+extern uint8_t pk[CRYPTO_PUBLICKEYBYTES];
+extern uint8_t sk[CRYPTO_SECRETKEYBYTES];
+extern uint8_t ct[CRYPTO_CIPHERTEXTBYTES];
+// uint8_t shared[CRYPTO_BYTES];
+#endif
+
+// MTU depends on the key sizes 64 for p256, 32 for 25519, a lot for PQ
+#if MYNEWT_VAL(ENABLE_SM_PQ)
+#define BLE_SM_MTU 87 + 1120
+#elif MYNEWT_VAL(ENABLE_SM_25519)
+#define BLE_SM_MTU 87 - 32
+#else
+#define BLE_SM_MTU 87
+#endif
+
+#define BLE_SM_OP_PAIR_REQ 0x01
+#define BLE_SM_OP_PAIR_RSP 0x02
+#define BLE_SM_OP_PAIR_CONFIRM 0x03
+#define BLE_SM_OP_PAIR_RANDOM 0x04
+#define BLE_SM_OP_PAIR_FAIL 0x05
+#define BLE_SM_OP_ENC_INFO 0x06
+#define BLE_SM_OP_MASTER_ID 0x07
+#define BLE_SM_OP_IDENTITY_INFO 0x08
+#define BLE_SM_OP_IDENTITY_ADDR_INFO 0x09
+#define BLE_SM_OP_SIGN_INFO 0x0a
+#define BLE_SM_OP_SEC_REQ 0x0b
+#define BLE_SM_OP_PAIR_PUBLIC_KEY 0x0c
+#define BLE_SM_OP_PAIR_DHKEY_CHECK 0x0d
+#define BLE_SM_OP_PAIR_KEYPRESS_NOTIFY 0x0e
+#if MYNEWT_VAL(ENABLE_SM_25519)
+#define DHKEYSIZE 32
+#else
+#define DHKEYSIZE 64
+#endif
+
+struct ble_sm_hdr
+{
     uint8_t opcode;
     uint8_t data[0];
 } __attribute__((packed));
@@ -65,15 +100,28 @@ struct ble_sm_hdr {
  * | Maximum Encryption Key Size        | 1                 |
  * | Initiator Key Distribution         | 1                 |
  * | Responder Key Distribution         | 1                 |
+ * | Local Ephemeral Public Key         | 64                |
+ * | Message Authentication Code        | 16                |
  */
 
-struct ble_sm_pair_cmd {
+struct ble_sm_pair_cmd
+{
     uint8_t io_cap;
     uint8_t oob_data_flag;
     uint8_t authreq;
     uint8_t max_enc_key_size;
     uint8_t init_key_dist;
     uint8_t resp_key_dist;
+#if MYNEWT_VAL(ENABLE_SM_PQ)
+    // pair_req->epub is CRYPTO_PUBLICKEYBYTES
+    // pair_rsp->epub is CRYPTO_PUBLICKEYBYTES - 96
+    uint8_t epub[CRYPTO_PUBLICKEYBYTES];
+#elif MYNEWT_VAL(ENABLE_SM_25519)
+    uint8_t epub[32];
+#else
+    uint8_t epub[64];
+#endif
+    uint8_t auth[16];
 } __attribute__((packed));
 
 /**
@@ -83,8 +131,12 @@ struct ble_sm_pair_cmd {
  * | Confirm Value                      | 16                |
  */
 
-struct ble_sm_pair_confirm {
-    uint8_t value[16];
+struct ble_sm_pair_confirm
+{
+#if MYNEWT_VAL(ENABLE_SM_PQ)
+    uint8_t key[CRYPTO_PUBLICKEYBYTES];
+#endif
+    uint8_t auth[16];
 } __attribute__((packed));
 
 /**
@@ -93,7 +145,8 @@ struct ble_sm_pair_confirm {
  * | (Code=0x04)                        | 1                 |
  * | Random Value                       | 16                |
  */
-struct ble_sm_pair_random {
+struct ble_sm_pair_random
+{
     uint8_t value[16];
 } __attribute__((packed));
 
@@ -103,7 +156,8 @@ struct ble_sm_pair_random {
  * | (Code=0x05)                        | 1                 |
  * | Reason                             | 1                 |
  */
-struct ble_sm_pair_fail {
+struct ble_sm_pair_fail
+{
     uint8_t reason;
 } __attribute__((packed));
 
@@ -113,7 +167,8 @@ struct ble_sm_pair_fail {
  * | (Code=0x06)                        | 1                 |
  * | ltk                                | 16                |
  */
-struct ble_sm_enc_info {
+struct ble_sm_enc_info
+{
     uint8_t ltk[16];
 } __attribute__((packed));
 
@@ -124,7 +179,8 @@ struct ble_sm_enc_info {
  * | EDIV                               | 2                 |
  * | RAND                               | 8                 |
  */
-struct ble_sm_master_id {
+struct ble_sm_master_id
+{
     uint16_t ediv;
     uint64_t rand_val;
 } __attribute__((packed));
@@ -135,7 +191,8 @@ struct ble_sm_master_id {
  * | (Code=0x08)                        | 1                 |
  * | irk                                | 16                |
  */
-struct ble_sm_id_info {
+struct ble_sm_id_info
+{
     uint8_t irk[16];
 } __attribute__((packed));
 
@@ -146,7 +203,8 @@ struct ble_sm_id_info {
  * | addr_type                          | 1                 |
  * | address                            | 6                 |
  */
-struct ble_sm_id_addr_info {
+struct ble_sm_id_addr_info
+{
     uint8_t addr_type;
     uint8_t bd_addr[6];
 } __attribute__((packed));
@@ -157,7 +215,8 @@ struct ble_sm_id_addr_info {
  * | (Code=0x0A)                        | 1                 |
  * | csrk                               | 16                |
  */
-struct ble_sm_sign_info {
+struct ble_sm_sign_info
+{
     uint8_t sig_key[16];
 } __attribute__((packed));
 
@@ -167,10 +226,21 @@ struct ble_sm_sign_info {
  * | (Code=0x0B)                        | 1                 |
  * | authreq                            | 1                 |
  */
-struct ble_sm_sec_req {
+struct ble_sm_sec_req
+{
     uint8_t authreq;
 } __attribute__((packed));
 
+struct ble_sm_enc_public_key
+{
+#if MYNEWT_VAL(ENABLE_SM_25519)
+    uint8_t enc_key[32];
+#else
+    uint8_t enc_key[64];
+#endif
+    uint8_t auth_tag[16];
+} __attribute__((packed));
+
 /**
  * | Parameter                          | Size (octets)     |
  * +------------------------------------+-------------------+
@@ -178,9 +248,15 @@ struct ble_sm_sec_req {
  * | Public Key X                       | 32                |
  * | Public Key Y                       | 32                |
  */
-struct ble_sm_public_key {
+struct ble_sm_public_key
+{
+#if MYNEWT_VAL(ENABLE_SM_25519)
+    uint8_t x[32];
+    uint8_t y[0];
+#else
     uint8_t x[32];
     uint8_t y[32];
+#endif
 } __attribute__((packed));
 
 /**
@@ -189,59 +265,76 @@ struct ble_sm_public_key {
  * | (Code=0x0d)                        | 1                 |
  * | DHKey Check                        | 16                |
  */
-struct ble_sm_dhkey_check {
+struct ble_sm_dhkey_check
+{
     uint8_t value[16];
 } __attribute__((packed));
 
 #if NIMBLE_BLE_SM
 
-#define BLE_SM_PROC_STATE_NONE              ((uint8_t)-1)
-
-#define BLE_SM_PROC_STATE_PAIR              0
-#define BLE_SM_PROC_STATE_CONFIRM           1
-#define BLE_SM_PROC_STATE_RANDOM            2
-#define BLE_SM_PROC_STATE_LTK_START         3
-#define BLE_SM_PROC_STATE_LTK_RESTORE       4
-#define BLE_SM_PROC_STATE_ENC_START         5
-#define BLE_SM_PROC_STATE_ENC_RESTORE       6
-#define BLE_SM_PROC_STATE_KEY_EXCH          7
-#define BLE_SM_PROC_STATE_SEC_REQ           8
-#define BLE_SM_PROC_STATE_PUBLIC_KEY        9
-#define BLE_SM_PROC_STATE_DHKEY_CHECK       10
-#define BLE_SM_PROC_STATE_CNT               11
-
-#define BLE_SM_PROC_F_INITIATOR             0x01
-#define BLE_SM_PROC_F_IO_INJECTED           0x02
-#define BLE_SM_PROC_F_ADVANCE_ON_IO         0x04
-#define BLE_SM_PROC_F_AUTHENTICATED         0x08
-#define BLE_SM_PROC_F_SC                    0x10
-#define BLE_SM_PROC_F_BONDING               0x20
-
-#define BLE_SM_KE_F_ENC_INFO                0x01
-#define BLE_SM_KE_F_MASTER_ID               0x02
-#define BLE_SM_KE_F_ID_INFO                 0x04
-#define BLE_SM_KE_F_ADDR_INFO               0x08
-#define BLE_SM_KE_F_SIGN_INFO               0x10
+#define BLE_SM_PROC_STATE_NONE ((uint8_t)-1)
+
+#define BLE_SM_PROC_STATE_PAIR 0
+#define BLE_SM_PROC_STATE_CONFIRM 1
+#define BLE_SM_PROC_STATE_RANDOM 2
+#define BLE_SM_PROC_STATE_LTK_START 3
+#define BLE_SM_PROC_STATE_LTK_RESTORE 4
+#define BLE_SM_PROC_STATE_ENC_START 5
+#define BLE_SM_PROC_STATE_ENC_RESTORE 6
+#define BLE_SM_PROC_STATE_KEY_EXCH 7
+#define BLE_SM_PROC_STATE_SEC_REQ 8
+#define BLE_SM_PROC_STATE_PUBLIC_KEY 9
+#define BLE_SM_PROC_STATE_DHKEY_CHECK 10
+#define BLE_SM_PROC_STATE_CNT 11
+
+#define BLE_SM_PROC_F_INITIATOR 0x01
+#define BLE_SM_PROC_F_IO_INJECTED 0x02
+#define BLE_SM_PROC_F_ADVANCE_ON_IO 0x04
+#define BLE_SM_PROC_F_AUTHENTICATED 0x08
+#define BLE_SM_PROC_F_SC 0x10
+#define BLE_SM_PROC_F_BONDING 0x20
+
+#define BLE_SM_KE_F_ENC_INFO 0x01
+#define BLE_SM_KE_F_MASTER_ID 0x02
+#define BLE_SM_KE_F_ID_INFO 0x04
+#define BLE_SM_KE_F_ADDR_INFO 0x08
+#define BLE_SM_KE_F_SIGN_INFO 0x10
 
 typedef uint8_t ble_sm_proc_flags;
 
-struct ble_sm_keys {
-    unsigned ltk_valid:1;
-    unsigned ediv_rand_valid:1;
-    unsigned irk_valid:1;
-    unsigned csrk_valid:1;
-    unsigned addr_valid:1;
+struct ble_sm_keys
+{
+    unsigned ltk_valid : 1;
+    unsigned ediv_rand_valid : 1;
+    unsigned irk_valid : 1;
+    unsigned csrk_valid : 1;
+    unsigned addr_valid : 1;
+    unsigned pubkey_valid : 1;
     uint16_t ediv;
     uint64_t rand_val;
     uint8_t addr_type;
     uint8_t key_size;
-    uint8_t ltk[16];    /* Little endian. */
-    uint8_t irk[16];    /* Little endian. */
-    uint8_t csrk[16];   /* Little endian. */
-    uint8_t addr[6];    /* Little endian. */
+    uint8_t ltk[16];  /* Little endian. */
+    uint8_t irk[16];  /* Little endian. */
+    uint8_t csrk[16]; /* Little endian. */
+    uint8_t addr[6];  /* Little endian. */
+#if MYNEWT_VAL(ENABLE_SM_25519)
+    uint8_t pubkey[32];
+#else
+    uint8_t pubkey[64];
+#endif
 };
 
-struct ble_sm_proc {
+// typedef struct ble_sm_newhope_state_s {
+//     uint8_t random_data[64];
+//     uint16_t generated;
+//     poly private_key;
+//     uint8_t public_key[MAX_OF(NEWHOPE_SENDABYTES, NEWHOPE_SENDBBYTES)];
+//     uint8_t role;
+// } ble_sm_newhope_state;
+
+struct ble_sm_proc
+{
     STAILQ_ENTRY(ble_sm_proc) next;
 
     ble_npl_time_t exp_os_ticks;
@@ -252,33 +345,42 @@ struct ble_sm_proc {
     uint8_t rx_key_flags;
     uint8_t key_size;
 
-    uint8_t pair_req[sizeof(struct ble_sm_hdr) + sizeof(struct ble_sm_pair_cmd)];
-    uint8_t pair_rsp[sizeof(struct ble_sm_hdr) + sizeof(struct ble_sm_pair_cmd)];
-    uint8_t tk[16];
+    uint8_t pair_hash[32];
+    uint8_t
+        pair_req[sizeof(struct ble_sm_hdr) + sizeof(struct ble_sm_pair_cmd)];
+    uint8_t
+        pair_rsp[sizeof(struct ble_sm_hdr) + sizeof(struct ble_sm_pair_cmd)];
+    uint8_t tk[32];
     uint8_t confirm_peer[16];
     uint8_t randm[16];
     uint8_t rands[16];
-    uint8_t ltk[16]; /* Little endian. */
+    uint8_t ltk[32]; /* Little endian. */
     struct ble_sm_keys our_keys;
     struct ble_sm_keys peer_keys;
+    uint8_t pq_support;
 
 #if MYNEWT_VAL(BLE_SM_SC)
     /* Secure connections. */
     uint8_t passkey_bits_exchanged;
     uint8_t ri;
     struct ble_sm_public_key pub_key_peer;
+    struct ble_sm_public_key eph_pub_key_peer;
+    uint8_t bonded;
+
     uint8_t mackey[16];
     uint8_t dhkey[32];
-    const struct ble_sm_sc_oob_data *oob_data_local;
-    const struct ble_sm_sc_oob_data *oob_data_remote;
+    uint8_t dhkeye[32];
+    const struct ble_sm_sc_oob_data* oob_data_local;
+    const struct ble_sm_sc_oob_data* oob_data_remote;
 #endif
 };
 
-struct ble_sm_result {
+struct ble_sm_result
+{
     int app_status;
     uint8_t sm_err;
     struct ble_gap_passkey_params passkey_params;
-    void *state_arg;
+    void* state_arg;
     unsigned execute : 1;
     unsigned enc_cb : 1;
     unsigned bonded : 1;
@@ -286,65 +388,147 @@ struct ble_sm_result {
 };
 
 #if MYNEWT_VAL(BLE_HS_DEBUG)
-void ble_sm_dbg_set_next_pair_rand(uint8_t *next_pair_rand);
-void ble_sm_dbg_set_next_ediv(uint16_t next_ediv);
-void ble_sm_dbg_set_next_master_id_rand(uint64_t next_master_id_rand);
-void ble_sm_dbg_set_next_ltk(uint8_t *next_ltk);
-void ble_sm_dbg_set_next_csrk(uint8_t *next_csrk);
-void ble_sm_dbg_set_sc_keys(uint8_t *pubkey, uint8_t *privkey);
+void
+ble_sm_dbg_set_next_pair_rand(uint8_t* next_pair_rand);
+void
+ble_sm_dbg_set_next_ediv(uint16_t next_ediv);
+void
+ble_sm_dbg_set_next_master_id_rand(uint64_t next_master_id_rand);
+void
+ble_sm_dbg_set_next_ltk(uint8_t* next_ltk);
+void
+ble_sm_dbg_set_next_csrk(uint8_t* next_csrk);
+void
+ble_sm_dbg_set_sc_keys(uint8_t* pubkey, uint8_t* privkey);
 #endif
 
-int ble_sm_num_procs(void);
-
-int ble_sm_alg_s1(const uint8_t *k, const uint8_t *r1, const uint8_t *r2,
-                  uint8_t *out);
-int ble_sm_alg_c1(const uint8_t *k, const uint8_t *r,
-                  const uint8_t *preq, const uint8_t *pres,
-                  uint8_t iat, uint8_t rat,
-                  const uint8_t *ia, const uint8_t *ra,
-                  uint8_t *out_enc_data);
-int ble_sm_alg_f4(const uint8_t *u, const uint8_t *v, const uint8_t *x,
-                  uint8_t z, uint8_t *out_enc_data);
-int ble_sm_alg_g2(const uint8_t *u, const uint8_t *v, const uint8_t *x,
-                  const uint8_t *y, uint32_t *passkey);
-int ble_sm_alg_f5(const uint8_t *w, const uint8_t *n1, const uint8_t *n2,
-                  uint8_t a1t, const uint8_t *a1, uint8_t a2t,
-                  const uint8_t *a2, uint8_t *mackey, uint8_t *ltk);
-int ble_sm_alg_f6(const uint8_t *w, const uint8_t *n1, const uint8_t *n2,
-                  const uint8_t *r, const uint8_t *iocap, uint8_t a1t,
-                  const uint8_t *a1, uint8_t a2t, const uint8_t *a2,
-                  uint8_t *check);
-int ble_sm_alg_csis_k1(const uint8_t *n, size_t n_len, const uint8_t *salt,
-                       const uint8_t *p, size_t p_len, uint8_t *out);
-int ble_sm_alg_csis_s1(const uint8_t *m, size_t m_len, uint8_t *out);
-int ble_sm_alg_csis_sef(const uint8_t *k, const uint8_t *plaintext_sirk,
-                        uint8_t *out);
-int ble_sm_alg_csis_sdf(const uint8_t *k, const uint8_t *enc_sirk,
-                        uint8_t *out);
-int ble_sm_alg_csis_sih(const uint8_t *k, const uint8_t *r, uint8_t *out);
-int ble_sm_alg_gen_dhkey(const uint8_t *peer_pub_key_x,
-                         const uint8_t *peer_pub_key_y,
-                         const uint8_t *our_priv_key, uint8_t *out_dhkey);
-int ble_sm_alg_gen_key_pair(uint8_t *pub, uint8_t *priv);
-void ble_sm_alg_ecc_init(void);
-
-int ble_sm_csis_generate_rsi(const uint8_t *sirk, uint8_t *out);
-int ble_sm_csis_encrypt_sirk(const uint8_t *ltk, const uint8_t *plaintext_sirk,
-                             uint8_t *out);
-int ble_sm_csis_decrypt_sirk(const uint8_t *ltk, const uint8_t *enc_sirk, uint8_t *out);
-
-void ble_sm_enc_change_rx(const struct ble_hci_ev_enrypt_chg *ev);
-void ble_sm_enc_key_refresh_rx(const struct ble_hci_ev_enc_key_refresh *ev);
-int ble_sm_ltk_req_rx(const struct ble_hci_ev_le_subev_lt_key_req *ev);
+int
+ble_sm_num_procs(void);
+
+int
+ble_sm_alg_s1(const uint8_t* k, const uint8_t* r1, const uint8_t* r2,
+              uint8_t* out);
+int
+ble_sm_alg_c1(const uint8_t* k, const uint8_t* r, const uint8_t* preq,
+              const uint8_t* pres, uint8_t iat, uint8_t rat, const uint8_t* ia,
+              const uint8_t* ra, uint8_t* out_enc_data);
+int
+ble_sm_alg_f4(const uint8_t* u, const uint8_t* v, const uint8_t* x, uint8_t z,
+              uint8_t* out_enc_data);
+int
+ble_sm_alg_g2(const uint8_t* u, const uint8_t* v, const uint8_t* x,
+              const uint8_t* y, uint32_t* passkey);
+int
+ble_sm_alg_f5(const uint8_t* w, const uint8_t* n1, const uint8_t* n2,
+              uint8_t a1t, const uint8_t* a1, uint8_t a2t, const uint8_t* a2,
+              uint8_t* mackey, uint8_t* ltk);
+int
+ble_sm_alg_f6(const uint8_t* w, const uint8_t* n1, const uint8_t* n2,
+              const uint8_t* r, const uint8_t* iocap, uint8_t a1t,
+              const uint8_t* a1, uint8_t a2t, const uint8_t* a2,
+              uint8_t* check);
+int
+ble_sm_alg_csis_k1(const uint8_t* n, size_t n_len, const uint8_t* salt,
+                   const uint8_t* p, size_t p_len, uint8_t* out);
+int
+ble_sm_alg_csis_s1(const uint8_t* m, size_t m_len, uint8_t* out);
+int
+ble_sm_alg_csis_sef(const uint8_t* k, const uint8_t* plaintext_sirk,
+                    uint8_t* out);
+int
+ble_sm_alg_csis_sdf(const uint8_t* k, const uint8_t* enc_sirk, uint8_t* out);
+int
+ble_sm_alg_csis_sih(const uint8_t* k, const uint8_t* r, uint8_t* out);
+int
+ble_sm_alg_gen_dhkey(const uint8_t* peer_pub_key_x,
+                     const uint8_t* peer_pub_key_y, const uint8_t* our_priv_key,
+                     uint8_t* out_dhkey);
+int
+ble_sm_alg_gen_key_pair(uint8_t* pub, uint8_t* priv);
+void
+ble_sm_alg_ecc_init(void);
+
+int
+ble_sm_alg_gen_keypair_pq(uint8_t* pub, uint8_t* priv, int role);
+
+int
+ble_sm_alg_gen_shared_pq(uint8_t* ct, uint8_t* pub, uint8_t* priv,
+                         uint8_t* shared_key, int role);
+
+void
+ble_sm_alg_blake_hash(uint8_t* in, unsigned int inlen, uint8_t* out);
+int
+ble_sm_alg_sha256_digest(uint8_t* in, unsigned int inlen, uint8_t* out);
+int
+ble_sm_alg_update_hash_transcript(uint8_t* hash, uint8_t* data,
+                                  unsigned int len);
+
+int
+ble_sm_alg_aes_ccm_encrypt(uint8_t* key, uint8_t* nonce, uint8_t* data,
+                           unsigned int datalen, uint8_t* ad,
+                           unsigned int adlen, uint8_t* out);
+
+int
+ble_sm_alg_aes_ccm_decrypt(uint8_t* key, uint8_t* nonce, uint8_t* in,
+                           unsigned int inlen, uint8_t* ad, unsigned int adlen,
+                           uint8_t* out);
+
+int
+ble_sm_alg_aes_cmac(const uint8_t* key, const uint8_t* in, size_t len,
+                    uint8_t* out);
+
+void
+ble_sm_alg_ckdf(uint8_t* salt, uint8_t* key, uint8_t* out);
+void
+ble_sm_alg_hkdf(uint8_t* salt, uint8_t* key, uint8_t* out);
+int
+random_data(uint8_t* dst, unsigned int size);
+int
+ble_sm_alg_crypto_auth(const uint8_t* key, const uint8_t* in, size_t len,
+                       uint8_t* out);
+
+int
+ble_sm_alg_aead_encrypt(uint8_t* out, const uint8_t* data, size_t datalen,
+                        const uint8_t* ad, size_t adlen, uint8_t* nonce,
+                        const uint8_t* key);
+
+int
+ble_sm_alg_aead_decrypt(uint8_t* out, const uint8_t* data, size_t datalen,
+                        const uint8_t* ad, size_t adlen, uint8_t* nonce,
+                        const uint8_t* key);
+
+int
+ble_sm_alg_crypto_auth_verify(const uint8_t* key, const uint8_t* in,
+                              unsigned long long inlen, const uint8_t* tag);
+
+uint32_t
+ble_sm_alg_cotp(uint8_t* key, uint64_t counter);
+
+int
+ble_sm_csis_generate_rsi(const uint8_t* sirk, uint8_t* out);
+int
+ble_sm_csis_encrypt_sirk(const uint8_t* ltk, const uint8_t* plaintext_sirk,
+                         uint8_t* out);
+int
+ble_sm_csis_decrypt_sirk(const uint8_t* ltk, const uint8_t* enc_sirk,
+                         uint8_t* out);
+
+void
+ble_sm_enc_change_rx(const struct ble_hci_ev_enrypt_chg* ev);
+void
+ble_sm_enc_key_refresh_rx(const struct ble_hci_ev_enc_key_refresh* ev);
+int
+ble_sm_ltk_req_rx(const struct ble_hci_ev_le_subev_lt_key_req* ev);
 
 #if MYNEWT_VAL(BLE_SM_LEGACY)
-int ble_sm_lgcy_io_action(struct ble_sm_proc *proc, uint8_t *action);
-void ble_sm_lgcy_confirm_exec(struct ble_sm_proc *proc,
-                              struct ble_sm_result *res);
-void ble_sm_lgcy_random_exec(struct ble_sm_proc *proc,
-                             struct ble_sm_result *res);
-void ble_sm_lgcy_random_rx(struct ble_sm_proc *proc,
-                           struct ble_sm_result *res);
+int
+ble_sm_lgcy_io_action(struct ble_sm_proc* proc, uint8_t* action);
+void
+ble_sm_lgcy_confirm_exec(struct ble_sm_proc* proc, struct ble_sm_result* res);
+void
+ble_sm_lgcy_random_exec(struct ble_sm_proc* proc, struct ble_sm_result* res);
+void
+ble_sm_lgcy_random_rx(struct ble_sm_proc* proc, struct ble_sm_result* res);
 #else
 #define ble_sm_lgcy_io_action(proc, action) (BLE_HS_ENOTSUP)
 #define ble_sm_lgcy_confirm_exec(proc, res)
@@ -353,26 +537,33 @@ void ble_sm_lgcy_random_rx(struct ble_sm_proc *proc,
 #endif
 
 #if MYNEWT_VAL(BLE_SM_SC)
-int ble_sm_sc_io_action(struct ble_sm_proc *proc, uint8_t *action);
-void ble_sm_sc_confirm_exec(struct ble_sm_proc *proc,
-                            struct ble_sm_result *res);
-void ble_sm_sc_random_exec(struct ble_sm_proc *proc,
-                           struct ble_sm_result *res);
-void ble_sm_sc_random_rx(struct ble_sm_proc *proc, struct ble_sm_result *res);
-void ble_sm_sc_public_key_exec(struct ble_sm_proc *proc,
-                               struct ble_sm_result *res,
-                               void *arg);
-void ble_sm_sc_public_key_rx(uint16_t conn_handle, struct os_mbuf **rxom,
-                             struct ble_sm_result *res);
-void ble_sm_sc_dhkey_check_exec(struct ble_sm_proc *proc,
-                                struct ble_sm_result *res, void *arg);
-void ble_sm_sc_dhkey_check_rx(uint16_t conn_handle, struct os_mbuf **rxom,
-                              struct ble_sm_result *res);
-bool ble_sm_sc_oob_data_check(struct ble_sm_proc *proc,
-                              bool oob_data_local_present,
-                              bool oob_data_remote_present);
-void ble_sm_sc_oob_confirm(struct ble_sm_proc *proc, struct ble_sm_result *res);
-void ble_sm_sc_init(void);
+int
+ble_sm_sc_io_action(struct ble_sm_proc* proc, uint8_t* action);
+void
+ble_sm_sc_confirm_exec(struct ble_sm_proc* proc, struct ble_sm_result* res);
+void
+ble_sm_sc_random_exec(struct ble_sm_proc* proc, struct ble_sm_result* res);
+void
+ble_sm_sc_random_rx(struct ble_sm_proc* proc, struct ble_sm_result* res);
+void
+ble_sm_sc_public_key_exec(struct ble_sm_proc* proc, struct ble_sm_result* res,
+                          void* arg);
+void
+ble_sm_sc_public_key_rx(uint16_t conn_handle, struct os_mbuf** rxom,
+                        struct ble_sm_result* res);
+void
+ble_sm_sc_dhkey_check_exec(struct ble_sm_proc* proc, struct ble_sm_result* res,
+                           void* arg);
+void
+ble_sm_sc_dhkey_check_rx(uint16_t conn_handle, struct os_mbuf** rxom,
+                         struct ble_sm_result* res);
+bool
+ble_sm_sc_oob_data_check(struct ble_sm_proc* proc, bool oob_data_local_present,
+                         bool oob_data_remote_present);
+void
+ble_sm_sc_oob_confirm(struct ble_sm_proc* proc, struct ble_sm_result* res);
+void
+ble_sm_sc_init(void);
 #else
 #define ble_sm_sc_io_action(proc, action) (BLE_HS_ENOTSUP)
 #define ble_sm_sc_confirm_exec(proc, res)
@@ -386,29 +577,43 @@ void ble_sm_sc_init(void);
 
 #endif
 
-struct ble_sm_proc *ble_sm_proc_find(uint16_t conn_handle, uint8_t state,
-                                     int is_initiator,
-                                     struct ble_sm_proc **out_prev);
-int ble_sm_gen_pair_rand(uint8_t *pair_rand);
-uint8_t *ble_sm_our_pair_rand(struct ble_sm_proc *proc);
-uint8_t *ble_sm_peer_pair_rand(struct ble_sm_proc *proc);
-int ble_sm_ioact_state(uint8_t action);
-int ble_sm_proc_can_advance(struct ble_sm_proc *proc);
-void ble_sm_process_result(uint16_t conn_handle, struct ble_sm_result *res,
-                           bool tx_fail);
-void ble_sm_confirm_advance(struct ble_sm_proc *proc);
-void ble_sm_ia_ra(struct ble_sm_proc *proc,
-                  uint8_t *out_iat, uint8_t *out_ia,
-                  uint8_t *out_rat, uint8_t *out_ra);
-
-int32_t ble_sm_timer(void);
-void ble_sm_connection_broken(uint16_t conn_handle);
-int ble_sm_pair_initiate(uint16_t conn_handle);
-int ble_sm_slave_initiate(uint16_t conn_handle);
-int ble_sm_enc_initiate(uint16_t conn_handle, uint8_t key_size,
-                        const uint8_t *ltk, uint16_t ediv,
-                        uint64_t rand_val, int auth);
-int ble_sm_init(void);
+struct ble_sm_proc*
+ble_sm_proc_find(uint16_t conn_handle, uint8_t state, int is_initiator,
+                 struct ble_sm_proc** out_prev);
+int
+ble_sm_gen_pair_rand(uint8_t* pair_rand);
+uint8_t*
+ble_sm_our_pair_rand(struct ble_sm_proc* proc);
+uint8_t*
+ble_sm_peer_pair_rand(struct ble_sm_proc* proc);
+int
+ble_sm_ioact_state(uint8_t action);
+int
+ble_sm_proc_can_advance(struct ble_sm_proc* proc);
+void
+ble_sm_process_result(uint16_t conn_handle, struct ble_sm_result* res,
+                      bool tx_fail);
+void
+ble_sm_confirm_advance(struct ble_sm_proc* proc);
+void
+ble_sm_ia_ra(struct ble_sm_proc* proc, uint8_t* out_iat, uint8_t* out_ia,
+             uint8_t* out_rat, uint8_t* out_ra);
+
+int32_t
+ble_sm_timer(void);
+void
+ble_sm_connection_broken(uint16_t conn_handle);
+int
+ble_sm_pair_initiate(uint16_t conn_handle);
+int
+ble_sm_slave_initiate(uint16_t conn_handle);
+int
+ble_sm_enc_initiate(uint16_t conn_handle, uint8_t key_size, const uint8_t* ltk,
+                    uint16_t ediv, uint64_t rand_val, int auth);
+int
+ble_sm_init(void);
+int
+ble_sm_session_initiate(uint16_t conn_handle, uint8_t* peer_pubkey);
 #else
 
 #define ble_sm_enc_change_rx(evt) ((void)(evt))
@@ -417,18 +622,21 @@ int ble_sm_init(void);
 
 #define ble_sm_timer() BLE_HS_FOREVER
 #define ble_sm_connection_broken(conn_handle)
-#define ble_sm_pair_initiate(conn_handle)   BLE_HS_ENOTSUP
-#define ble_sm_slave_initiate(conn_handle)  BLE_HS_ENOTSUP
-#define ble_sm_enc_initiate(conn_handle, keysize, ltk, ediv, rand_val, auth) \
-        BLE_HS_ENOTSUP
+#define ble_sm_pair_initiate(conn_handle) BLE_HS_ENOTSUP
+#define ble_sm_slave_initiate(conn_handle) BLE_HS_ENOTSUP
+#define ble_sm_enc_initiate(conn_handle, keysize, ltk, ediv, rand_val, auth)   \
+    BLE_HS_ENOTSUP
 
 #define ble_sm_init() 0
 
 #endif
 
-struct ble_l2cap_chan *ble_sm_create_chan(uint16_t handle);
-void *ble_sm_cmd_get(uint8_t opcode, size_t len, struct os_mbuf **txom);
-int ble_sm_tx(uint16_t conn_handle, struct os_mbuf *txom);
+struct ble_l2cap_chan*
+ble_sm_create_chan(uint16_t handle);
+void*
+ble_sm_cmd_get(uint8_t opcode, size_t len, struct os_mbuf** txom);
+int
+ble_sm_tx(uint16_t conn_handle, struct os_mbuf* txom);
 
 #ifdef __cplusplus
 }
diff --git a/nimble/host/src/ble_sm_sc.c b/nimble/host/src/ble_sm_sc.c
index 0cd2b2ee..cf999d90 100644
--- a/nimble/host/src/ble_sm_sc.c
+++ b/nimble/host/src/ble_sm_sc.c
@@ -25,13 +25,17 @@
 #include "ble_sm_priv.h"
 
 #if NIMBLE_BLE_CONNECT
-#if MYNEWT_VAL(BLE_SM_SC)
+#if MYNEWT_VAL(BLE_SM_SC) || true
 
-#define BLE_SM_SC_PASSKEY_BYTES     4
-#define BLE_SM_SC_PASSKEY_BITS      20
+#define BLE_SM_SC_PASSKEY_BYTES 4
+#define BLE_SM_SC_PASSKEY_BITS 20
 
-static uint8_t ble_sm_sc_pub_key[64];
-static uint8_t ble_sm_sc_priv_key[32];
+#if MYNEWT_VAL(ENABLE_SM_25519)
+uint8_t ble_sm_sc_pub_key[32];
+#else
+uint8_t ble_sm_sc_pub_key[64];
+#endif
+uint8_t ble_sm_sc_priv_key[32];
 
 /**
  * Whether our public-private key pair has been generated.  We generate it on
@@ -43,25 +47,24 @@ static uint8_t ble_sm_sc_keys_generated;
  * Create some shortened names for the passkey actions so that the table is
  * easier to read.
  */
-#define IOACT_NONE      BLE_SM_IOACT_NONE
-#define IOACT_OOB       BLE_SM_IOACT_OOB
-#define IOACT_INPUT     BLE_SM_IOACT_INPUT
-#define IOACT_DISP      BLE_SM_IOACT_DISP
-#define IOACT_NUMCMP    BLE_SM_IOACT_NUMCMP
+#define IOACT_NONE BLE_SM_IOACT_NONE
+#define IOACT_OOB BLE_SM_IOACT_OOB
+#define IOACT_INPUT BLE_SM_IOACT_INPUT
+#define IOACT_DISP BLE_SM_IOACT_DISP
+#define IOACT_NUMCMP BLE_SM_IOACT_NUMCMP
 
 /**
  * This table expresses the required initiator IO action.  Inputs are:
  *     o Responder IO capabilities (from pair response).
  *     o Initiator IO capabilities (from pair request).
  */
-static const uint8_t ble_sm_sc_init_ioa[5 /*resp*/ ][5 /*init*/ ] =
-{
-      /* init */
-/*r*/ {IOACT_NONE,    IOACT_NONE,   IOACT_INPUT, IOACT_NONE, IOACT_INPUT},
-/*e*/ {IOACT_NONE,    IOACT_NUMCMP, IOACT_INPUT, IOACT_NONE, IOACT_NUMCMP},
-/*s*/ {IOACT_DISP,    IOACT_DISP,   IOACT_INPUT, IOACT_NONE, IOACT_DISP},
-/*p*/ {IOACT_NONE,    IOACT_NONE,   IOACT_NONE,  IOACT_NONE, IOACT_NONE},
-      {IOACT_DISP,    IOACT_NUMCMP, IOACT_INPUT, IOACT_NONE, IOACT_NUMCMP},
+static const uint8_t ble_sm_sc_init_ioa[5 /*resp*/][5 /*init*/] = {
+    /* init */
+    /*r*/ {IOACT_NONE, IOACT_NONE, IOACT_INPUT, IOACT_NONE, IOACT_INPUT},
+    /*e*/ {IOACT_NONE, IOACT_NUMCMP, IOACT_INPUT, IOACT_NONE, IOACT_NUMCMP},
+    /*s*/ {IOACT_DISP, IOACT_DISP, IOACT_INPUT, IOACT_NONE, IOACT_DISP},
+    /*p*/ {IOACT_NONE, IOACT_NONE, IOACT_NONE, IOACT_NONE, IOACT_NONE},
+    {IOACT_DISP, IOACT_NUMCMP, IOACT_INPUT, IOACT_NONE, IOACT_NUMCMP},
 };
 
 /**
@@ -69,14 +72,13 @@ static const uint8_t ble_sm_sc_init_ioa[5 /*resp*/ ][5 /*init*/ ] =
  *     o Responder IO capabilities (from pair response).
  *     o Initiator IO capabilities (from pair request).
  */
-static const uint8_t ble_sm_sc_resp_ioa[5 /*resp*/ ][5 /*init*/ ] =
-{
-      /* init */
-/*r*/ {IOACT_NONE,    IOACT_NONE,   IOACT_DISP,  IOACT_NONE, IOACT_DISP},
-/*e*/ {IOACT_NONE,    IOACT_NUMCMP, IOACT_DISP,  IOACT_NONE, IOACT_NUMCMP},
-/*s*/ {IOACT_INPUT,   IOACT_INPUT,  IOACT_INPUT, IOACT_NONE, IOACT_INPUT},
-/*p*/ {IOACT_NONE,    IOACT_NONE,   IOACT_NONE,  IOACT_NONE, IOACT_NONE},
-      {IOACT_INPUT,   IOACT_NUMCMP, IOACT_DISP,  IOACT_NONE, IOACT_NUMCMP},
+static const uint8_t ble_sm_sc_resp_ioa[5 /*resp*/][5 /*init*/] = {
+    /* init */
+    /*r*/ {IOACT_NONE, IOACT_NONE, IOACT_DISP, IOACT_NONE, IOACT_DISP},
+    /*e*/ {IOACT_NONE, IOACT_NUMCMP, IOACT_DISP, IOACT_NONE, IOACT_NUMCMP},
+    /*s*/ {IOACT_INPUT, IOACT_INPUT, IOACT_INPUT, IOACT_NONE, IOACT_INPUT},
+    /*p*/ {IOACT_NONE, IOACT_NONE, IOACT_NONE, IOACT_NONE, IOACT_NONE},
+    {IOACT_INPUT, IOACT_NUMCMP, IOACT_DISP, IOACT_NONE, IOACT_NUMCMP},
 };
 
 #if MYNEWT_VAL(BLE_HS_DEBUG)
@@ -86,38 +88,40 @@ static uint8_t ble_sm_dbg_sc_priv_key[32];
 static uint8_t ble_sm_dbg_sc_keys_set;
 
 void
-ble_sm_dbg_set_sc_keys(uint8_t *pubkey, uint8_t *privkey)
+ble_sm_dbg_set_sc_keys(uint8_t* pubkey, uint8_t* privkey)
 {
-    memcpy(ble_sm_dbg_sc_pub_key, pubkey,
-           sizeof ble_sm_dbg_sc_pub_key);
-    memcpy(ble_sm_dbg_sc_priv_key, privkey,
-           sizeof ble_sm_dbg_sc_priv_key);
+    memcpy(ble_sm_dbg_sc_pub_key, pubkey, sizeof ble_sm_dbg_sc_pub_key);
+    memcpy(ble_sm_dbg_sc_priv_key, privkey, sizeof ble_sm_dbg_sc_priv_key);
     ble_sm_dbg_sc_keys_set = 1;
 }
 
 #endif
 
 int
-ble_sm_sc_io_action(struct ble_sm_proc *proc, uint8_t *action)
+ble_sm_sc_io_action(struct ble_sm_proc* proc, uint8_t* action)
 {
     struct ble_sm_pair_cmd *pair_req, *pair_rsp;
 
-    pair_req = (struct ble_sm_pair_cmd *) &proc->pair_req[1];
-    pair_rsp = (struct ble_sm_pair_cmd *) &proc->pair_rsp[1];
+    pair_req = (struct ble_sm_pair_cmd*)&proc->pair_req[1];
+    pair_rsp = (struct ble_sm_pair_cmd*)&proc->pair_rsp[1];
 
     if (pair_req->oob_data_flag == BLE_SM_PAIR_OOB_YES ||
         pair_rsp->oob_data_flag == BLE_SM_PAIR_OOB_YES) {
         *action = BLE_SM_IOACT_OOB_SC;
-    } else if (!(pair_req->authreq & BLE_SM_PAIR_AUTHREQ_MITM) &&
-               !(pair_rsp->authreq & BLE_SM_PAIR_AUTHREQ_MITM)) {
+    }
+    else if (!(pair_req->authreq & BLE_SM_PAIR_AUTHREQ_MITM) &&
+             !(pair_rsp->authreq & BLE_SM_PAIR_AUTHREQ_MITM)) {
 
         *action = BLE_SM_IOACT_NONE;
-    } else if (pair_req->io_cap >= BLE_SM_IO_CAP_RESERVED ||
-               pair_rsp->io_cap >= BLE_SM_IO_CAP_RESERVED) {
+    }
+    else if (pair_req->io_cap >= BLE_SM_IO_CAP_RESERVED ||
+             pair_rsp->io_cap >= BLE_SM_IO_CAP_RESERVED) {
         *action = BLE_SM_IOACT_NONE;
-    } else if (proc->flags & BLE_SM_PROC_F_INITIATOR) {
+    }
+    else if (proc->flags & BLE_SM_PROC_F_INITIATOR) {
         *action = ble_sm_sc_init_ioa[pair_rsp->io_cap][pair_req->io_cap];
-    } else {
+    }
+    else {
         *action = ble_sm_sc_resp_ioa[pair_rsp->io_cap][pair_req->io_cap];
     }
 
@@ -151,7 +155,7 @@ ble_sm_sc_io_action(struct ble_sm_proc *proc, uint8_t *action)
 }
 
 static int
-ble_sm_gen_pub_priv(uint8_t *pub, uint8_t *priv)
+ble_sm_gen_pub_priv(uint8_t* pub, uint8_t* priv)
 {
     int rc;
 
@@ -187,7 +191,7 @@ ble_sm_sc_ensure_keys_generated(void)
     }
 
     BLE_HS_LOG(DEBUG, "our pubkey=");
-    ble_hs_log_flat_buf(&ble_sm_sc_pub_key, 64);
+    ble_hs_log_flat_buf(&ble_sm_sc_pub_key, DHKEYSIZE);
     BLE_HS_LOG(DEBUG, "\n");
     BLE_HS_LOG(DEBUG, "our privkey=");
     ble_hs_log_flat_buf(&ble_sm_sc_priv_key, 32);
@@ -202,7 +206,7 @@ ble_sm_sc_ensure_keys_generated(void)
  * (vol. 3, part H, 2.3.5.6.2)
  */
 static int
-ble_sm_sc_initiator_txes_confirm(struct ble_sm_proc *proc)
+ble_sm_sc_initiator_txes_confirm(struct ble_sm_proc* proc)
 {
     BLE_HS_DBG_ASSERT(proc->flags & BLE_SM_PROC_F_SC);
 
@@ -217,7 +221,7 @@ ble_sm_sc_initiator_txes_confirm(struct ble_sm_proc *proc)
  * (vol. 3, part H, 2.3.5.6.2)
  */
 static int
-ble_sm_sc_responder_verifies_random(struct ble_sm_proc *proc)
+ble_sm_sc_responder_verifies_random(struct ble_sm_proc* proc)
 {
     BLE_HS_DBG_ASSERT(proc->flags & BLE_SM_PROC_F_SC);
 
@@ -230,7 +234,7 @@ ble_sm_sc_responder_verifies_random(struct ble_sm_proc *proc)
  * written to the supplied procedure object.
  */
 static int
-ble_sm_sc_gen_ri(struct ble_sm_proc *proc)
+ble_sm_sc_gen_ri(struct ble_sm_proc* proc)
 {
     int byte;
     int bit;
@@ -261,7 +265,7 @@ ble_sm_sc_gen_ri(struct ble_sm_proc *proc)
 }
 
 void
-ble_sm_sc_oob_confirm(struct ble_sm_proc *proc, struct ble_sm_result *res)
+ble_sm_sc_oob_confirm(struct ble_sm_proc* proc, struct ble_sm_result* res)
 {
     int err;
     bool match;
@@ -298,22 +302,36 @@ ble_sm_sc_oob_confirm(struct ble_sm_proc *proc, struct ble_sm_result *res)
 }
 
 void
-ble_sm_sc_confirm_exec(struct ble_sm_proc *proc, struct ble_sm_result *res)
+ble_sm_sc_confirm_exec(struct ble_sm_proc* proc, struct ble_sm_result* res)
 {
-    struct ble_sm_pair_confirm *cmd;
-    struct os_mbuf *txom;
+    struct ble_sm_pair_confirm* cmd;
+    struct os_mbuf* txom;
     int rc;
-
-    rc = ble_sm_sc_gen_ri(proc);
-    if (rc != 0) {
-        res->app_status = rc;
-        res->enc_cb = 1;
-        res->sm_err = BLE_SM_ERR_UNSPECIFIED;
-        return;
+#if MYNEWT_VAL(ENABLE_PQ_SESSION)
+    // TODO: now we do PQDH
+    // Peripheral
+    // if (!(proc->flags & BLE_SM_PROC_F_INITIATOR)) {
+    //     rc = crypto_kem_enc(ct, proc->dhkeye, cmd->value);
+    //     if (rc != 0) {
+    //         memcpy(proc->dhkey, proc->ltk, sizeof(proc->ltk));
+    //         ble_sm_alg_hkdf(proc->dhkey, proc->dhkeye, proc->ltk);
+    //     }
+    // }
+
+    // Central
+    if ((proc->flags & BLE_SM_PROC_F_INITIATOR)) {
+        rc = crypto_kem_keypair(pk, sk);
+        if (rc != 0) {
+            res->app_status = rc;
+            res->enc_cb = 1;
+            res->sm_err = BLE_SM_ERR_UNSPECIFIED;
+            return;
+        }
     }
 
     cmd = ble_sm_cmd_get(BLE_SM_OP_PAIR_CONFIRM, sizeof(*cmd), &txom);
     if (cmd == NULL) {
+        BLE_HS_LOG(ERROR, "ble_sm_cmd_get failed\n");
         rc = BLE_HS_ENOMEM;
         res->app_status = rc;
         res->enc_cb = 1;
@@ -321,39 +339,54 @@ ble_sm_sc_confirm_exec(struct ble_sm_proc *proc, struct ble_sm_result *res)
         return;
     }
 
-    rc = ble_sm_alg_f4(ble_sm_sc_pub_key, proc->pub_key_peer.x,
-                       ble_sm_our_pair_rand(proc), proc->ri, cmd->value);
-    if (rc != 0) {
-        os_mbuf_free_chain(txom);
-        res->app_status = rc;
-        res->enc_cb = 1;
-        res->sm_err = BLE_SM_ERR_UNSPECIFIED;
-        return;
+    if (!(proc->flags & BLE_SM_PROC_F_INITIATOR)) {
+        memcpy(cmd->key, ct, sizeof(ct));
     }
+    else {
+        memcpy(cmd->key, pk, sizeof(pk));
+    }
+    ble_sm_alg_update_hash_transcript(proc->pair_hash, (uint8_t*)cmd,
+                                      sizeof(*cmd) - 16);
+
+    ble_sm_alg_crypto_auth(proc->ltk, proc->pair_hash, 32, cmd->auth);
+
+    // rc = ble_sm_alg_f4(ble_sm_sc_pub_key, proc->pub_key_peer.x,
+    //                    ble_sm_our_pair_rand(proc), proc->ri, cmd->value);
+    // if (rc != 0) {
+    //     os_mbuf_free_chain(txom);
+    //     res->app_status = rc;
+    //     res->enc_cb = 1;
+    //     res->sm_err = BLE_SM_ERR_UNSPECIFIED;
+    //     return;
+    // }
 
     rc = ble_sm_tx(proc->conn_handle, txom);
     if (rc != 0) {
+        BLE_HS_LOG(ERROR, "ble_sm_tx failed\n");
         res->app_status = rc;
         res->enc_cb = 1;
         res->sm_err = BLE_SM_ERR_UNSPECIFIED;
         return;
     }
-
+    // Peripheral goes to enc start as they just sent the confirm
     if (!(proc->flags & BLE_SM_PROC_F_INITIATOR)) {
-        proc->state = BLE_SM_PROC_STATE_RANDOM;
+        proc->state = BLE_SM_PROC_STATE_ENC_START;
+        res->execute = 1;
     }
+#endif
 }
 
 static void
-ble_sm_sc_gen_numcmp(struct ble_sm_proc *proc, struct ble_sm_result *res)
+ble_sm_sc_gen_numcmp(struct ble_sm_proc* proc, struct ble_sm_result* res)
 {
-    uint8_t *pka;
-    uint8_t *pkb;
+    uint8_t* pka;
+    uint8_t* pkb;
 
     if (proc->flags & BLE_SM_PROC_F_INITIATOR) {
         pka = ble_sm_sc_pub_key;
         pkb = proc->pub_key_peer.x;
-    } else {
+    }
+    else {
         pka = proc->pub_key_peer.x;
         pkb = ble_sm_sc_pub_key;
     }
@@ -370,7 +403,7 @@ ble_sm_sc_gen_numcmp(struct ble_sm_proc *proc, struct ble_sm_result *res)
  * completed the random state.
  */
 static int
-ble_sm_sc_random_advance(struct ble_sm_proc *proc)
+ble_sm_sc_random_advance(struct ble_sm_proc* proc)
 {
     int rc;
 
@@ -378,7 +411,8 @@ ble_sm_sc_random_advance(struct ble_sm_proc *proc)
         proc->passkey_bits_exchanged >= BLE_SM_SC_PASSKEY_BITS) {
 
         proc->state = BLE_SM_PROC_STATE_DHKEY_CHECK;
-    } else {
+    }
+    else {
         proc->state = BLE_SM_PROC_STATE_CONFIRM;
         rc = ble_sm_gen_pair_rand(ble_sm_our_pair_rand(proc));
         if (rc != 0) {
@@ -390,10 +424,10 @@ ble_sm_sc_random_advance(struct ble_sm_proc *proc)
 }
 
 void
-ble_sm_sc_random_exec(struct ble_sm_proc *proc, struct ble_sm_result *res)
+ble_sm_sc_random_exec(struct ble_sm_proc* proc, struct ble_sm_result* res)
 {
-    struct ble_sm_pair_random *cmd;
-    struct os_mbuf *txom;
+    struct ble_sm_pair_random* cmd;
+    struct os_mbuf* txom;
     uint8_t ioact;
     int rc;
 
@@ -438,7 +472,7 @@ ble_sm_sc_random_exec(struct ble_sm_proc *proc, struct ble_sm_result *res)
 }
 
 void
-ble_sm_sc_random_rx(struct ble_sm_proc *proc, struct ble_sm_result *res)
+ble_sm_sc_random_rx(struct ble_sm_proc* proc, struct ble_sm_result* res)
 {
     uint8_t confirm_val[16];
     uint8_t ia[6];
@@ -448,17 +482,16 @@ ble_sm_sc_random_rx(struct ble_sm_proc *proc, struct ble_sm_result *res)
     uint8_t rat;
     int rc;
 
-    if (proc->pair_alg != BLE_SM_PAIR_ALG_OOB && (
-        proc->flags & BLE_SM_PROC_F_INITIATOR ||
-        ble_sm_sc_responder_verifies_random(proc))) {
+    if (proc->pair_alg != BLE_SM_PAIR_ALG_OOB &&
+        (proc->flags & BLE_SM_PROC_F_INITIATOR ||
+         ble_sm_sc_responder_verifies_random(proc))) {
 
         BLE_HS_LOG(DEBUG, "tk=");
         ble_hs_log_flat_buf(proc->tk, 16);
         BLE_HS_LOG(DEBUG, "\n");
 
         rc = ble_sm_alg_f4(proc->pub_key_peer.x, ble_sm_sc_pub_key,
-                           ble_sm_peer_pair_rand(proc), proc->ri,
-                           confirm_val);
+                           ble_sm_peer_pair_rand(proc), proc->ri, confirm_val);
         if (rc != 0) {
             res->app_status = rc;
             res->sm_err = BLE_SM_ERR_UNSPECIFIED;
@@ -477,8 +510,8 @@ ble_sm_sc_random_rx(struct ble_sm_proc *proc, struct ble_sm_result *res)
 
     /* Calculate the mac key and ltk. */
     ble_sm_ia_ra(proc, &iat, ia, &rat, ra);
-    rc = ble_sm_alg_f5(proc->dhkey, proc->randm, proc->rands,
-                       iat, ia, rat, ra, proc->mackey, proc->ltk);
+    rc = ble_sm_alg_f5(proc->dhkey, proc->randm, proc->rands, iat, ia, rat, ra,
+                       proc->mackey, proc->ltk);
     if (rc != 0) {
         res->app_status = rc;
         res->sm_err = BLE_SM_ERR_UNSPECIFIED;
@@ -518,25 +551,28 @@ ble_sm_sc_random_rx(struct ble_sm_proc *proc, struct ble_sm_result *res)
             res->passkey_params.action = ioact;
             BLE_HS_DBG_ASSERT(ioact == BLE_SM_IOACT_NUMCMP);
             ble_sm_sc_gen_numcmp(proc, res);
-        } else {
+        }
+        else {
             res->execute = 1;
         }
-    } else {
+    }
+    else {
         if (proc->pair_alg == BLE_SM_PAIR_ALG_OOB &&
             !(proc->flags & BLE_SM_PROC_F_IO_INJECTED)) {
             proc->flags |= BLE_SM_PROC_F_ADVANCE_ON_IO;
-        } else {
+        }
+        else {
             res->execute = 1;
         }
     }
 }
 
 void
-ble_sm_sc_public_key_exec(struct ble_sm_proc *proc, struct ble_sm_result *res,
-                          void *arg)
+ble_sm_sc_public_key_exec(struct ble_sm_proc* proc, struct ble_sm_result* res,
+                          void* arg)
 {
-    struct ble_sm_public_key *cmd;
-    struct os_mbuf *txom;
+    struct ble_sm_enc_public_key* cmd;
+    struct os_mbuf* txom;
     uint8_t ioact;
     int rc;
 
@@ -554,47 +590,113 @@ ble_sm_sc_public_key_exec(struct ble_sm_proc *proc, struct ble_sm_result *res,
         res->sm_err = BLE_SM_ERR_UNSPECIFIED;
         return;
     }
+    // size_t pdatalen = sizeof(struct ble_sm_hdr) + sizeof(struct ble_sm_pair_cmd);
+    // uint8_t pdata[pdatalen*2];
+    // memcpy(pdata, proc->pair_req, pdatalen);
+    // memcpy(pdata + pdatalen, proc->pair_rsp, pdatalen);
 
-    memcpy(cmd->x, ble_sm_sc_pub_key + 0, 32);
-    memcpy(cmd->y, ble_sm_sc_pub_key + 32, 32);
+    // Fill packet with public key
+    // memcpy(cmd->enc_key, ble_sm_sc_pub_key, sizeof(ble_sm_sc_pub_key));
 
-    res->app_status = ble_sm_tx(proc->conn_handle, txom);
-    if (res->app_status != 0) {
-        res->enc_cb = 1;
-        res->sm_err = BLE_SM_ERR_UNSPECIFIED;
-        return;
-    }
+    // // Update hash transcript with our key
+    // ble_sm_alg_update_hash_transcript(proc->pair_hash, cmd->enc_key,
+    //                                   sizeof(cmd->enc_key));
+
+    // Update hash transcript with new key
+    // uint8_t tmp[sizeof(ble_sm_sc_pub_key) + 32];
+    // memcpy(tmp, proc->pair_hash, 32);
+    // memcpy(tmp + 32, ble_sm_sc_pub_key, sizeof(ble_sm_sc_pub_key));
+    // ble_sm_alg_sha256_digest(tmp, sizeof(tmp), proc->pair_hash);
 
+    // Shorten the key for AES-128
+    // uint8_t short_key[16];
+
+    // ble_sm_alg_aes_ccm_encrypt(proc->dhkeye, NULL, ble_sm_sc_pub_key, 64, proc->pair_hash, 32, cmd->enc_key);
+
+    // Sizes are already good, we encryt directly to the packet
+    // memcpy(cmd->x, ble_sm_sc_pub_key + 0, 32);
+    // memcpy(cmd->y, ble_sm_sc_pub_key + 32, 32);
+    uint8_t nonce[16] = {0};
+    // Symmetric ratchet over the shared key to avoid key reuse for AEAD
+
+    // Peripheral
     if (!(proc->flags & BLE_SM_PROC_F_INITIATOR)) {
-        if (proc->pair_alg == BLE_SM_PAIR_ALG_OOB) {
-            proc->state = BLE_SM_PROC_STATE_RANDOM;
-        } else {
-            proc->state = BLE_SM_PROC_STATE_CONFIRM;
-        }
+        // If Peripheral we use the new LTK (i.e., enc key)
 
-        rc = ble_sm_sc_io_action(proc, &ioact);
-        if (rc != 0) {
-            BLE_HS_DBG_ASSERT(0);
-        }
+        // Update hash transcript with our key
+        // ble_sm_alg_update_hash_transcript(proc->pair_hash, cmd->enc_key,
+        //                                   sizeof(cmd->enc_key) + 16);
 
-        if (ble_sm_ioact_state(ioact) == proc->state) {
-            res->passkey_params.action = ioact;
-        }
+        // ble_sm_alg_crypto_auth(proc->ltk, proc->pair_hash, 32, cmd->auth_tag);
 
-        if (ble_sm_proc_can_advance(proc) &&
-            !ble_sm_sc_initiator_txes_confirm(proc)) {
+        // rc = ble_sm_sc_io_action(proc, &ioact);
+        // if (rc != 0) {
+        //     BLE_HS_DBG_ASSERT(0);
+        // }
 
-            res->execute = 1;
-        }
+        // Store the remote public key along with identity
+        // TODO
+        // Save DHKEY to be sent to controller
+        // memcpy(proc->ltk, proc->dhkey, 16);
+
+        // memcpy(proc->peer_keys.pubkey, proc->pub_key_peer.x,
+        //        sizeof(proc->pub_key_peer));
+        // proc->peer_keys.pubkey_valid = 1;
+
+        //TODO: We switch to the state of waiting for LTK req from controller.
+        //proc->state = BLE_SM_PROC_STATE_LTK_START;
+
+        // Instead of waiting we send the key to the controller, which will wait for the enc req at his level
+        proc->state = BLE_SM_PROC_STATE_ENC_START;
+        res->execute = 1;
+        // struct ble_hci_le_f_encrypt cmd;
+        // cmd.conn_handle = proc->conn_handle;
+        // memcpy(cmd.ltk, proc->ltk, 16);
+        // rc = ble_hs_hci_cmd_tx(BLE_HCI_OP(BLE_HCI_OGF_LE, BLE_HCI_OCF_LE_F_ENCRYPT),
+        //                        &cmd, sizeof(cmd), NULL, 0);
+
+        // if (rc != 0) {
+        //     BLE_HS_LOG(DEBUG, "Error ble_hs_hci_cmd_tx %d\n", rc);
+        //     return;
+        // }
+    }
+    else {
+        // If Central we use the Ephemeral
+        // ble_sm_alg_crypto_auth(proc->dhkeye, proc->pair_hash, 32,
+        //                        cmd->auth_tag);
+        ble_sm_alg_hkdf(proc->pair_hash, proc->dhkeye, proc->tk);
+    }
+
+    rc = ble_sm_alg_aead_encrypt(cmd->enc_key, ble_sm_sc_pub_key,
+                                 sizeof(ble_sm_sc_pub_key), proc->pair_hash,
+                                 sizeof(proc->pair_hash), nonce, proc->tk);
+
+    if (rc != 0) {
+        os_mbuf_free_chain(txom);
+        res->app_status = rc;
+        res->enc_cb = 1;
+        res->sm_err = BLE_SM_ERR_UNSPECIFIED;
+        return;
+    }
+
+    // Update hash transcript with our key
+    ble_sm_alg_update_hash_transcript(proc->pair_hash, cmd->enc_key,
+                                      sizeof(cmd->enc_key) + 16);
+
+    res->app_status = ble_sm_tx(proc->conn_handle, txom);
+    if (res->app_status != 0) {
+        res->enc_cb = 1;
+        res->sm_err = BLE_SM_ERR_UNSPECIFIED;
+        return;
     }
 }
 
 void
-ble_sm_sc_public_key_rx(uint16_t conn_handle, struct os_mbuf **om,
-                        struct ble_sm_result *res)
+ble_sm_sc_public_key_rx(uint16_t conn_handle, struct os_mbuf** om,
+                        struct ble_sm_result* res)
 {
-    struct ble_sm_public_key *cmd;
-    struct ble_sm_proc *proc;
+    struct ble_sm_enc_public_key* cmd;
+    struct ble_sm_proc* proc;
     uint8_t ioact;
     int rc;
 
@@ -611,67 +713,139 @@ ble_sm_sc_public_key_rx(uint16_t conn_handle, struct os_mbuf **om,
         return;
     }
 
-    cmd = (struct ble_sm_public_key *)(*om)->om_data;
-    /* Check if the peer public key is same as our generated public key.
-     * Return fail if the public keys match. */
-    if (memcmp(cmd, ble_sm_sc_pub_key, 64) == 0) {
-        res->enc_cb = 1;
-        res->sm_err = BLE_SM_ERR_AUTHREQ;
-        return;
-    }
+    cmd = (struct ble_sm_enc_public_key*)(*om)->om_data;
+    // printf("\nPublic Key Packet: ")
+    // for (size_t i = 0; i < sizeof(cmd); i++) {
+    //     printf("%02x", cmd->enc_key[i]);
+    // }
+    // printf("\n");
+
+    // TODO: do it in a nicer way (also more optimized)
 
     ble_hs_lock();
-    proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_PUBLIC_KEY, -1,
-                            NULL);
+    proc =
+        ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_PUBLIC_KEY, -1, NULL);
     if (proc == NULL) {
         res->app_status = BLE_HS_ENOENT;
         res->sm_err = BLE_SM_ERR_UNSPECIFIED;
-    } else {
-        memcpy(&proc->pub_key_peer, cmd, sizeof(*cmd));
-        rc = ble_sm_alg_gen_dhkey(proc->pub_key_peer.x,
-                                  proc->pub_key_peer.y,
-                                  ble_sm_sc_priv_key,
-                                  proc->dhkey);
+    }
+    else {
+
+        //TODO: replace with MAC, leave key plaintext
+        // ble_sm_alg_aes_ccm_decrypt(proc->dhkeye, NULL, cmd->enc_key, sizeof(struct ble_sm_enc_public_key), proc->pair_hash, 32, proc->pub_key_peer.x);
+
+        // memcpy(proc->pub_key_peer.x, cmd->enc_key, sizeof(cmd->enc_key));
+        uint8_t nonce[16] = {0};
+
+        // We are Peripheral we need to compute tk
+        if (!(proc->flags & BLE_SM_PROC_F_INITIATOR)) {
+            ble_sm_alg_hkdf(proc->pair_hash, proc->dhkeye, proc->tk);
+        }
+
+        rc = ble_sm_alg_aead_decrypt(proc->pub_key_peer.x, cmd->enc_key,
+                                     sizeof(cmd->enc_key) + 16, proc->pair_hash,
+                                     sizeof(proc->pair_hash), nonce, proc->tk);
+
+        if (rc != 0) {
+            res->app_status = rc;
+            res->sm_err = BLE_SM_ERR_UNSPECIFIED;
+            res->enc_cb = 1;
+            return;
+        }
+
+        /* Check if the peer public key is same as our generated public key.
+        * Return fail if the public keys match. */
+        if (memcmp(proc->pub_key_peer.x, ble_sm_sc_pub_key, DHKEYSIZE) == 0) {
+            memset(proc->pub_key_peer.x, 0, DHKEYSIZE);
+            res->enc_cb = 1;
+            res->sm_err = BLE_SM_ERR_AUTHREQ;
+            return;
+        }
+
+        // Update hash transcript with received key
+        ble_sm_alg_update_hash_transcript(proc->pair_hash, cmd->enc_key,
+                                          sizeof(cmd->enc_key) + 16);
+
+        // Shorten the key for AES-128
+        // uint8_t short_key[16];
+
+        // memcpy(&proc->pub_key_peer, cmd, sizeof(*cmd));
+        rc = ble_sm_alg_gen_dhkey(proc->pub_key_peer.x, proc->pub_key_peer.y,
+                                  ble_sm_sc_priv_key, proc->dhkey);
         if (rc != 0) {
             res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_DHKEY);
             res->sm_err = BLE_SM_ERR_DHKEY;
             res->enc_cb = 1;
-        } else {
+        }
+        else {
+            // Generate the LTK (i.e., encryption key)
+            ble_sm_alg_hkdf(proc->dhkey, proc->dhkeye, proc->ltk);
+            // BLE_HS_LOG(INFO, "\n    ziopera ltk=");
+            // ble_hs_log_buf_dflt(proc->ltk, sizeof(proc->ltk));
+            // uint8_t tmp_mac[16];
+            // int valid = 0;
+            // ble_sm_alg_sha256_digest(tmp, sizeof(tmp), proc->pair_hash);
+
+            // We are Central (i.e., initiator)
             if (proc->flags & BLE_SM_PROC_F_INITIATOR) {
-                if (proc->pair_alg == BLE_SM_PAIR_ALG_OOB) {
-                    proc->state = BLE_SM_PROC_STATE_RANDOM;
-                } else {
-                    proc->state = BLE_SM_PROC_STATE_CONFIRM;
-                }
-
-                rc = ble_sm_sc_io_action(proc, &ioact);
-                if (rc != 0) {
-                        BLE_HS_DBG_ASSERT(0);
-                }
-
-                if (ble_sm_ioact_state(ioact) == proc->state) {
-                    res->passkey_params.action = ioact;
-                }
-
-                if (ble_sm_proc_can_advance(proc) &&
-                    ble_sm_sc_initiator_txes_confirm(proc)) {
-
-                    res->execute = 1;
-                }
-            } else {
+
+                // memcpy(proc->peer_keys.pubkey, proc->pub_key_peer.x,
+                //        sizeof(proc->pub_key_peer));
+                // proc->peer_keys.pubkey_valid = 1;
+                // valid = ble_sm_alg_crypto_auth_verify(
+                //     proc->ltk, proc->pair_hash, 32, cmd->auth_tag);
+                // ble_sm_alg_crypto_auth(proc->ltk, proc->pair_hash, 32, tmp_mac);
+                // #if MYNEWT_VAL(ENABLE_PQ_SESSION)
+                //                 // Go to confirm and execute
+                //                 proc->state = BLE_SM_PROC_STATE_CONFIRM;
+                //                 res->execute = 1;
+                // #else
+                // Instead of waiting we send the key to the controller, which will wait for the enc req at his level
+                proc->state = BLE_SM_PROC_STATE_ENC_START;
+                res->execute = 1;
+
+                // proc->state = BLE_SM_PROC_STATE_ENC_START;
+                // res->execute = 1;
+            }
+            else {
+                // valid = ble_sm_alg_crypto_auth_verify(
+                //     proc->dhkeye, proc->pair_hash, 32, cmd->auth_tag);
+                // // This execute flag runs the public_key_exec method (we are peripheral)
+                // ble_sm_alg_crypto_auth(proc->dhkeye, proc->pair_hash, 32,
+                //                        tmp_mac);
+
                 res->execute = 1;
             }
+            // Authenticate message
+
+            // Check if the MAC is correct
+            // if (valid) {
+            //     BLE_HS_LOG_INFO("MAC mismatch\n");
+            //     res->app_status = BLE_HS_SM_US_ERR(BLE_SM_ERR_AUTHREQ);
+            //     res->sm_err = BLE_SM_ERR_AUTHREQ;
+            //     res->enc_cb = 1;
+            //     res->execute = 0;
+            //     // return;
+            // }
+            // Generate the Encryption Key
+            // ble_sm_alg_ckdf(proc->dhkey, proc->dhkeye, proc->ltk);
+            // print the ltk
+            // printf("\nLTK: ");
+            // for (size_t i = 0; i < 16; i++) {
+            //     printf("%02x", proc->ltk[i]);
+            // }
+            // printf("\n");
         }
     }
     ble_hs_unlock();
 }
 
 static void
-ble_sm_sc_dhkey_addrs(struct ble_sm_proc *proc, ble_addr_t *our_addr,
-                      ble_addr_t *peer_addr)
+ble_sm_sc_dhkey_addrs(struct ble_sm_proc* proc, ble_addr_t* our_addr,
+                      ble_addr_t* peer_addr)
 {
     struct ble_hs_conn_addrs addrs;
-    struct ble_hs_conn *conn;
+    struct ble_hs_conn* conn;
 
     conn = ble_hs_conn_find_assert(proc->conn_handle);
 
@@ -682,32 +856,34 @@ ble_sm_sc_dhkey_addrs(struct ble_sm_proc *proc, ble_addr_t *our_addr,
 }
 
 void
-ble_sm_sc_dhkey_check_exec(struct ble_sm_proc *proc, struct ble_sm_result *res,
-                           void *arg)
+ble_sm_sc_dhkey_check_exec(struct ble_sm_proc* proc, struct ble_sm_result* res,
+                           void* arg)
 {
-    struct ble_sm_dhkey_check *cmd;
+    struct ble_sm_dhkey_check* cmd;
     ble_addr_t our_addr;
     ble_addr_t peer_addr;
-    struct os_mbuf *txom;
-    uint8_t *iocap;
+    struct os_mbuf* txom;
+    uint8_t* iocap;
     int rc;
 
     if (proc->flags & BLE_SM_PROC_F_INITIATOR) {
-        struct ble_sm_pair_cmd *pair_req;
+        struct ble_sm_pair_cmd* pair_req;
 
-        pair_req  = (struct ble_sm_pair_cmd *) &proc->pair_req[1];
+        pair_req = (struct ble_sm_pair_cmd*)&proc->pair_req[1];
         iocap = &pair_req->io_cap;
-    } else {
-        struct ble_sm_pair_cmd *pair_rsp;
+    }
+    else {
+        struct ble_sm_pair_cmd* pair_rsp;
 
-        pair_rsp  = (struct ble_sm_pair_cmd *) &proc->pair_rsp[1];
+        pair_rsp = (struct ble_sm_pair_cmd*)&proc->pair_rsp[1];
         iocap = &pair_rsp->io_cap;
     }
 
     if (proc->pair_alg == BLE_SM_PAIR_ALG_OOB) {
         if (proc->oob_data_remote) {
             memcpy(proc->tk, proc->oob_data_remote->r, 16);
-        } else {
+        }
+        else {
             memset(proc->tk, 0, 16);
         }
     }
@@ -747,40 +923,43 @@ err:
 }
 
 static void
-ble_sm_dhkey_check_process(struct ble_sm_proc *proc,
-                           struct ble_sm_dhkey_check *cmd,
-                           struct ble_sm_result *res)
+ble_sm_dhkey_check_process(struct ble_sm_proc* proc,
+                           struct ble_sm_dhkey_check* cmd,
+                           struct ble_sm_result* res)
 {
     uint8_t exp_value[16];
     ble_addr_t our_addr;
     ble_addr_t peer_addr;
-    uint8_t *iocap;
+    uint8_t* iocap;
     uint8_t ioact;
     int rc;
 
     if (proc->flags & BLE_SM_PROC_F_INITIATOR) {
-        struct ble_sm_pair_cmd *pair_rsp;
+        struct ble_sm_pair_cmd* pair_rsp;
 
-        pair_rsp  = (struct ble_sm_pair_cmd *) &proc->pair_rsp[1];
+        pair_rsp = (struct ble_sm_pair_cmd*)&proc->pair_rsp[1];
         iocap = &pair_rsp->io_cap;
 
         if (proc->pair_alg == BLE_SM_PAIR_ALG_OOB) {
             if (pair_rsp->oob_data_flag) {
                 memcpy(proc->tk, proc->oob_data_local->r, 16);
-            } else {
+            }
+            else {
                 memset(proc->tk, 0, 16);
             }
         }
-    } else {
-        struct ble_sm_pair_cmd *pair_req;
+    }
+    else {
+        struct ble_sm_pair_cmd* pair_req;
 
-        pair_req  = (struct ble_sm_pair_cmd *) &proc->pair_req[1];
+        pair_req = (struct ble_sm_pair_cmd*)&proc->pair_req[1];
         iocap = &pair_req->io_cap;
 
         if (proc->pair_alg == BLE_SM_PAIR_ALG_OOB) {
             if (pair_req->oob_data_flag) {
                 memcpy(proc->tk, proc->oob_data_local->r, 16);
-            } else {
+            }
+            else {
                 memset(proc->tk, 0, 16);
             }
         }
@@ -791,13 +970,10 @@ ble_sm_dhkey_check_process(struct ble_sm_proc *proc,
     ble_hs_log_flat_buf(proc->tk, 16);
     BLE_HS_LOG(DEBUG, "\n");
 
-    res->app_status = ble_sm_alg_f6(proc->mackey,
-                                    ble_sm_peer_pair_rand(proc),
-                                    ble_sm_our_pair_rand(proc),
-                                    proc->tk, iocap,
+    res->app_status = ble_sm_alg_f6(proc->mackey, ble_sm_peer_pair_rand(proc),
+                                    ble_sm_our_pair_rand(proc), proc->tk, iocap,
                                     peer_addr.type, peer_addr.val,
-                                    our_addr.type, our_addr.val,
-                                    exp_value);
+                                    our_addr.type, our_addr.val, exp_value);
     if (res->app_status != 0) {
         res->sm_err = BLE_SM_ERR_UNSPECIFIED;
         res->enc_cb = 1;
@@ -831,11 +1007,11 @@ ble_sm_dhkey_check_process(struct ble_sm_proc *proc,
 }
 
 void
-ble_sm_sc_dhkey_check_rx(uint16_t conn_handle, struct os_mbuf **om,
-                         struct ble_sm_result *res)
+ble_sm_sc_dhkey_check_rx(uint16_t conn_handle, struct os_mbuf** om,
+                         struct ble_sm_result* res)
 {
-    struct ble_sm_dhkey_check *cmd;
-    struct ble_sm_proc *proc;
+    struct ble_sm_dhkey_check* cmd;
+    struct ble_sm_proc* proc;
 
     res->app_status = ble_hs_mbuf_pullup_base(om, sizeof(*cmd));
     if (res->app_status != 0) {
@@ -844,43 +1020,44 @@ ble_sm_sc_dhkey_check_rx(uint16_t conn_handle, struct os_mbuf **om,
         return;
     }
 
-    cmd = (struct ble_sm_dhkey_check *)(*om)->om_data;
+    cmd = (struct ble_sm_dhkey_check*)(*om)->om_data;
 
     ble_hs_lock();
-    proc = ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_DHKEY_CHECK, -1,
-                            NULL);
+    proc =
+        ble_sm_proc_find(conn_handle, BLE_SM_PROC_STATE_DHKEY_CHECK, -1, NULL);
     if (proc == NULL) {
         res->app_status = BLE_HS_ENOENT;
-    } else {
+    }
+    else {
         ble_sm_dhkey_check_process(proc, cmd, res);
     }
     ble_hs_unlock();
 }
 
 bool
-ble_sm_sc_oob_data_check(struct ble_sm_proc *proc,
-                         bool oob_data_local_present,
+ble_sm_sc_oob_data_check(struct ble_sm_proc* proc, bool oob_data_local_present,
                          bool oob_data_remote_present)
 {
-    struct ble_sm_pair_cmd *pair_req;
-    struct ble_sm_pair_cmd *pair_rsp;
+    struct ble_sm_pair_cmd* pair_req;
+    struct ble_sm_pair_cmd* pair_rsp;
     bool req_oob_present;
     bool rsp_oob_present;
 
-    pair_req = (struct ble_sm_pair_cmd *) &proc->pair_req[1];
-    pair_rsp = (struct ble_sm_pair_cmd *) &proc->pair_rsp[1];
+    pair_req = (struct ble_sm_pair_cmd*)&proc->pair_req[1];
+    pair_rsp = (struct ble_sm_pair_cmd*)&proc->pair_rsp[1];
     req_oob_present = pair_req->oob_data_flag == BLE_SM_PAIR_OOB_YES;
     rsp_oob_present = pair_rsp->oob_data_flag == BLE_SM_PAIR_OOB_YES;
 
     if (proc->flags & BLE_SM_PROC_F_INITIATOR) {
         return req_oob_present == oob_data_remote_present;
-    } else {
+    }
+    else {
         return rsp_oob_present == oob_data_remote_present;
     }
 }
 
 int
-ble_sm_sc_oob_generate_data(struct ble_sm_sc_oob_data *oob_data)
+ble_sm_sc_oob_generate_data(struct ble_sm_sc_oob_data* oob_data)
 {
     int rc;
 
@@ -914,5 +1091,5 @@ ble_sm_sc_init(void)
     ble_sm_sc_keys_generated = 0;
 }
 
-#endif  /* MYNEWT_VAL(BLE_SM_SC) */
+#endif /* MYNEWT_VAL(BLE_SM_SC) */
 #endif
diff --git a/nimble/host/src/kyber/api.h b/nimble/host/src/kyber/api.h
new file mode 100644
index 00000000..70d40f3f
--- /dev/null
+++ b/nimble/host/src/kyber/api.h
@@ -0,0 +1,66 @@
+#ifndef API_H
+#define API_H
+
+#include <stdint.h>
+
+#define pqcrystals_kyber512_SECRETKEYBYTES 1632
+#define pqcrystals_kyber512_PUBLICKEYBYTES 800
+#define pqcrystals_kyber512_CIPHERTEXTBYTES 768
+#define pqcrystals_kyber512_KEYPAIRCOINBYTES 64
+#define pqcrystals_kyber512_ENCCOINBYTES 32
+#define pqcrystals_kyber512_BYTES 32
+
+#define pqcrystals_kyber512_ref_SECRETKEYBYTES pqcrystals_kyber512_SECRETKEYBYTES
+#define pqcrystals_kyber512_ref_PUBLICKEYBYTES pqcrystals_kyber512_PUBLICKEYBYTES
+#define pqcrystals_kyber512_ref_CIPHERTEXTBYTES pqcrystals_kyber512_CIPHERTEXTBYTES
+#define pqcrystals_kyber512_ref_KEYPAIRCOINBYTES pqcrystals_kyber512_KEYPAIRCOINBYTES
+#define pqcrystals_kyber512_ref_ENCCOINBYTES pqcrystals_kyber512_ENCCOINBYTES
+#define pqcrystals_kyber512_ref_BYTES pqcrystals_kyber512_BYTES
+
+int pqcrystals_kyber512_ref_keypair_derand(uint8_t *pk, uint8_t *sk, const uint8_t *coins);
+int pqcrystals_kyber512_ref_keypair(uint8_t *pk, uint8_t *sk);
+int pqcrystals_kyber512_ref_enc_derand(uint8_t *ct, uint8_t *ss, const uint8_t *pk, const uint8_t *coins);
+int pqcrystals_kyber512_ref_enc(uint8_t *ct, uint8_t *ss, const uint8_t *pk);
+int pqcrystals_kyber512_ref_dec(uint8_t *ss, const uint8_t *ct, const uint8_t *sk);
+
+#define pqcrystals_kyber768_SECRETKEYBYTES 2400
+#define pqcrystals_kyber768_PUBLICKEYBYTES 1184
+#define pqcrystals_kyber768_CIPHERTEXTBYTES 1088
+#define pqcrystals_kyber768_KEYPAIRCOINBYTES 64
+#define pqcrystals_kyber768_ENCCOINBYTES 32
+#define pqcrystals_kyber768_BYTES 32
+
+#define pqcrystals_kyber768_ref_SECRETKEYBYTES pqcrystals_kyber768_SECRETKEYBYTES
+#define pqcrystals_kyber768_ref_PUBLICKEYBYTES pqcrystals_kyber768_PUBLICKEYBYTES
+#define pqcrystals_kyber768_ref_CIPHERTEXTBYTES pqcrystals_kyber768_CIPHERTEXTBYTES
+#define pqcrystals_kyber768_ref_KEYPAIRCOINBYTES pqcrystals_kyber768_KEYPAIRCOINBYTES
+#define pqcrystals_kyber768_ref_ENCCOINBYTES pqcrystals_kyber768_ENCCOINBYTES
+#define pqcrystals_kyber768_ref_BYTES pqcrystals_kyber768_BYTES
+
+int pqcrystals_kyber768_ref_keypair_derand(uint8_t *pk, uint8_t *sk, const uint8_t *coins);
+int pqcrystals_kyber768_ref_keypair(uint8_t *pk, uint8_t *sk);
+int pqcrystals_kyber768_ref_enc_derand(uint8_t *ct, uint8_t *ss, const uint8_t *pk, const uint8_t *coins);
+int pqcrystals_kyber768_ref_enc(uint8_t *ct, uint8_t *ss, const uint8_t *pk);
+int pqcrystals_kyber768_ref_dec(uint8_t *ss, const uint8_t *ct, const uint8_t *sk);
+
+#define pqcrystals_kyber1024_SECRETKEYBYTES 3168
+#define pqcrystals_kyber1024_PUBLICKEYBYTES 1568
+#define pqcrystals_kyber1024_CIPHERTEXTBYTES 1568
+#define pqcrystals_kyber1024_KEYPAIRCOINBYTES 64
+#define pqcrystals_kyber1024_ENCCOINBYTES 32
+#define pqcrystals_kyber1024_BYTES 32
+
+#define pqcrystals_kyber1024_ref_SECRETKEYBYTES pqcrystals_kyber1024_SECRETKEYBYTES
+#define pqcrystals_kyber1024_ref_PUBLICKEYBYTES pqcrystals_kyber1024_PUBLICKEYBYTES
+#define pqcrystals_kyber1024_ref_CIPHERTEXTBYTES pqcrystals_kyber1024_CIPHERTEXTBYTES
+#define pqcrystals_kyber1024_ref_KEYPAIRCOINBYTES pqcrystals_kyber1024_KEYPAIRCOINBYTES
+#define pqcrystals_kyber1024_ref_ENCCOINBYTES pqcrystals_kyber1024_ENCCOINBYTES
+#define pqcrystals_kyber1024_ref_BYTES pqcrystals_kyber1024_BYTES
+
+int pqcrystals_kyber1024_ref_keypair_derand(uint8_t *pk, uint8_t *sk, const uint8_t *coins);
+int pqcrystals_kyber1024_ref_keypair(uint8_t *pk, uint8_t *sk);
+int pqcrystals_kyber1024_ref_enc_derand(uint8_t *ct, uint8_t *ss, const uint8_t *pk, const uint8_t *coins);
+int pqcrystals_kyber1024_ref_enc(uint8_t *ct, uint8_t *ss, const uint8_t *pk);
+int pqcrystals_kyber1024_ref_dec(uint8_t *ss, const uint8_t *ct, const uint8_t *sk);
+
+#endif
diff --git a/nimble/host/src/kyber/cbd.c b/nimble/host/src/kyber/cbd.c
new file mode 100644
index 00000000..1500ffea
--- /dev/null
+++ b/nimble/host/src/kyber/cbd.c
@@ -0,0 +1,128 @@
+#include <stdint.h>
+#include "params.h"
+#include "cbd.h"
+
+/*************************************************
+* Name:        load32_littleendian
+*
+* Description: load 4 bytes into a 32-bit integer
+*              in little-endian order
+*
+* Arguments:   - const uint8_t *x: pointer to input byte array
+*
+* Returns 32-bit unsigned integer loaded from x
+**************************************************/
+static uint32_t load32_littleendian(const uint8_t x[4])
+{
+  uint32_t r;
+  r  = (uint32_t)x[0];
+  r |= (uint32_t)x[1] << 8;
+  r |= (uint32_t)x[2] << 16;
+  r |= (uint32_t)x[3] << 24;
+  return r;
+}
+
+/*************************************************
+* Name:        load24_littleendian
+*
+* Description: load 3 bytes into a 32-bit integer
+*              in little-endian order.
+*              This function is only needed for Kyber-512
+*
+* Arguments:   - const uint8_t *x: pointer to input byte array
+*
+* Returns 32-bit unsigned integer loaded from x (most significant byte is zero)
+**************************************************/
+#if KYBER_ETA1 == 3
+static uint32_t load24_littleendian(const uint8_t x[3])
+{
+  uint32_t r;
+  r  = (uint32_t)x[0];
+  r |= (uint32_t)x[1] << 8;
+  r |= (uint32_t)x[2] << 16;
+  return r;
+}
+#endif
+
+
+/*************************************************
+* Name:        cbd2
+*
+* Description: Given an array of uniformly random bytes, compute
+*              polynomial with coefficients distributed according to
+*              a centered binomial distribution with parameter eta=2
+*
+* Arguments:   - poly *r: pointer to output polynomial
+*              - const uint8_t *buf: pointer to input byte array
+**************************************************/
+static void cbd2(poly *r, const uint8_t buf[2*KYBER_N/4])
+{
+  unsigned int i,j;
+  uint32_t t,d;
+  int16_t a,b;
+
+  for(i=0;i<KYBER_N/8;i++) {
+    t  = load32_littleendian(buf+4*i);
+    d  = t & 0x55555555;
+    d += (t>>1) & 0x55555555;
+
+    for(j=0;j<8;j++) {
+      a = (d >> (4*j+0)) & 0x3;
+      b = (d >> (4*j+2)) & 0x3;
+      r->coeffs[8*i+j] = a - b;
+    }
+  }
+}
+
+/*************************************************
+* Name:        cbd3
+*
+* Description: Given an array of uniformly random bytes, compute
+*              polynomial with coefficients distributed according to
+*              a centered binomial distribution with parameter eta=3.
+*              This function is only needed for Kyber-512
+*
+* Arguments:   - poly *r: pointer to output polynomial
+*              - const uint8_t *buf: pointer to input byte array
+**************************************************/
+#if KYBER_ETA1 == 3
+static void cbd3(poly *r, const uint8_t buf[3*KYBER_N/4])
+{
+  unsigned int i,j;
+  uint32_t t,d;
+  int16_t a,b;
+
+  for(i=0;i<KYBER_N/4;i++) {
+    t  = load24_littleendian(buf+3*i);
+    d  = t & 0x00249249;
+    d += (t>>1) & 0x00249249;
+    d += (t>>2) & 0x00249249;
+
+    for(j=0;j<4;j++) {
+      a = (d >> (6*j+0)) & 0x7;
+      b = (d >> (6*j+3)) & 0x7;
+      r->coeffs[4*i+j] = a - b;
+    }
+  }
+}
+#endif
+
+void poly_cbd_eta1(poly *r, const uint8_t buf[KYBER_ETA1*KYBER_N/4])
+{
+#if KYBER_ETA1 == 2
+  cbd2(r, buf);
+#elif KYBER_ETA1 == 3
+  cbd3(r, buf);
+#else
+#error "This implementation requires eta1 in {2,3}"
+#endif
+}
+
+void poly_cbd_eta2(poly *r, const uint8_t buf[KYBER_ETA2*KYBER_N/4])
+{
+#if KYBER_ETA2 == 2
+  cbd2(r, buf);
+#else
+#error "This implementation requires eta2 = 2"
+#endif
+}
diff --git a/nimble/host/src/kyber/cbd.h b/nimble/host/src/kyber/cbd.h
new file mode 100644
index 00000000..7b677d74
--- /dev/null
+++ b/nimble/host/src/kyber/cbd.h
@@ -0,0 +1,14 @@
+#ifndef CBD_H
+#define CBD_H
+
+#include <stdint.h>
+#include "params.h"
+#include "poly.h"
+
+#define poly_cbd_eta1 KYBER_NAMESPACE(poly_cbd_eta1)
+void poly_cbd_eta1(poly *r, const uint8_t buf[KYBER_ETA1*KYBER_N/4]);
+
+#define poly_cbd_eta2 KYBER_NAMESPACE(poly_cbd_eta2)
+void poly_cbd_eta2(poly *r, const uint8_t buf[KYBER_ETA2*KYBER_N/4]);
+
+#endif
diff --git a/nimble/host/src/kyber/fips202.c b/nimble/host/src/kyber/fips202.c
new file mode 100644
index 00000000..ab3d2a12
--- /dev/null
+++ b/nimble/host/src/kyber/fips202.c
@@ -0,0 +1,774 @@
+/* Based on the public domain implementation in crypto_hash/keccakc512/simple/ from
+ * http://bench.cr.yp.to/supercop.html by Ronny Van Keer and the public domain "TweetFips202"
+ * implementation from https://twitter.com/tweetfips202 by Gilles Van Assche, Daniel J. Bernstein,
+ * and Peter Schwabe */
+
+#include <stddef.h>
+#include <stdint.h>
+#include "fips202.h"
+
+#define NROUNDS 24
+#define ROL(a, offset) ((a << offset) ^ (a >> (64-offset)))
+
+/*************************************************
+* Name:        load64
+*
+* Description: Load 8 bytes into uint64_t in little-endian order
+*
+* Arguments:   - const uint8_t *x: pointer to input byte array
+*
+* Returns the loaded 64-bit unsigned integer
+**************************************************/
+static uint64_t load64(const uint8_t x[8]) {
+  unsigned int i;
+  uint64_t r = 0;
+
+  for(i=0;i<8;i++)
+    r |= (uint64_t)x[i] << 8*i;
+
+  return r;
+}
+
+/*************************************************
+* Name:        store64
+*
+* Description: Store a 64-bit integer to array of 8 bytes in little-endian order
+*
+* Arguments:   - uint8_t *x: pointer to the output byte array (allocated)
+*              - uint64_t u: input 64-bit unsigned integer
+**************************************************/
+static void store64(uint8_t x[8], uint64_t u) {
+  unsigned int i;
+
+  for(i=0;i<8;i++)
+    x[i] = u >> 8*i;
+}
+
+/* Keccak round constants */
+static const uint64_t KeccakF_RoundConstants[NROUNDS] = {
+  (uint64_t)0x0000000000000001ULL,
+  (uint64_t)0x0000000000008082ULL,
+  (uint64_t)0x800000000000808aULL,
+  (uint64_t)0x8000000080008000ULL,
+  (uint64_t)0x000000000000808bULL,
+  (uint64_t)0x0000000080000001ULL,
+  (uint64_t)0x8000000080008081ULL,
+  (uint64_t)0x8000000000008009ULL,
+  (uint64_t)0x000000000000008aULL,
+  (uint64_t)0x0000000000000088ULL,
+  (uint64_t)0x0000000080008009ULL,
+  (uint64_t)0x000000008000000aULL,
+  (uint64_t)0x000000008000808bULL,
+  (uint64_t)0x800000000000008bULL,
+  (uint64_t)0x8000000000008089ULL,
+  (uint64_t)0x8000000000008003ULL,
+  (uint64_t)0x8000000000008002ULL,
+  (uint64_t)0x8000000000000080ULL,
+  (uint64_t)0x000000000000800aULL,
+  (uint64_t)0x800000008000000aULL,
+  (uint64_t)0x8000000080008081ULL,
+  (uint64_t)0x8000000000008080ULL,
+  (uint64_t)0x0000000080000001ULL,
+  (uint64_t)0x8000000080008008ULL
+};
+
+/*************************************************
+* Name:        KeccakF1600_StatePermute
+*
+* Description: The Keccak F1600 Permutation
+*
+* Arguments:   - uint64_t *state: pointer to input/output Keccak state
+**************************************************/
+static void KeccakF1600_StatePermute(uint64_t state[25])
+{
+        int round;
+
+        uint64_t Aba, Abe, Abi, Abo, Abu;
+        uint64_t Aga, Age, Agi, Ago, Agu;
+        uint64_t Aka, Ake, Aki, Ako, Aku;
+        uint64_t Ama, Ame, Ami, Amo, Amu;
+        uint64_t Asa, Ase, Asi, Aso, Asu;
+        uint64_t BCa, BCe, BCi, BCo, BCu;
+        uint64_t Da, De, Di, Do, Du;
+        uint64_t Eba, Ebe, Ebi, Ebo, Ebu;
+        uint64_t Ega, Ege, Egi, Ego, Egu;
+        uint64_t Eka, Eke, Eki, Eko, Eku;
+        uint64_t Ema, Eme, Emi, Emo, Emu;
+        uint64_t Esa, Ese, Esi, Eso, Esu;
+
+        //copyFromState(A, state)
+        Aba = state[ 0];
+        Abe = state[ 1];
+        Abi = state[ 2];
+        Abo = state[ 3];
+        Abu = state[ 4];
+        Aga = state[ 5];
+        Age = state[ 6];
+        Agi = state[ 7];
+        Ago = state[ 8];
+        Agu = state[ 9];
+        Aka = state[10];
+        Ake = state[11];
+        Aki = state[12];
+        Ako = state[13];
+        Aku = state[14];
+        Ama = state[15];
+        Ame = state[16];
+        Ami = state[17];
+        Amo = state[18];
+        Amu = state[19];
+        Asa = state[20];
+        Ase = state[21];
+        Asi = state[22];
+        Aso = state[23];
+        Asu = state[24];
+
+        for(round = 0; round < NROUNDS; round += 2) {
+            //    prepareTheta
+            BCa = Aba^Aga^Aka^Ama^Asa;
+            BCe = Abe^Age^Ake^Ame^Ase;
+            BCi = Abi^Agi^Aki^Ami^Asi;
+            BCo = Abo^Ago^Ako^Amo^Aso;
+            BCu = Abu^Agu^Aku^Amu^Asu;
+
+            //thetaRhoPiChiIotaPrepareTheta(round, A, E)
+            Da = BCu^ROL(BCe, 1);
+            De = BCa^ROL(BCi, 1);
+            Di = BCe^ROL(BCo, 1);
+            Do = BCi^ROL(BCu, 1);
+            Du = BCo^ROL(BCa, 1);
+
+            Aba ^= Da;
+            BCa = Aba;
+            Age ^= De;
+            BCe = ROL(Age, 44);
+            Aki ^= Di;
+            BCi = ROL(Aki, 43);
+            Amo ^= Do;
+            BCo = ROL(Amo, 21);
+            Asu ^= Du;
+            BCu = ROL(Asu, 14);
+            Eba =   BCa ^((~BCe)&  BCi );
+            Eba ^= (uint64_t)KeccakF_RoundConstants[round];
+            Ebe =   BCe ^((~BCi)&  BCo );
+            Ebi =   BCi ^((~BCo)&  BCu );
+            Ebo =   BCo ^((~BCu)&  BCa );
+            Ebu =   BCu ^((~BCa)&  BCe );
+
+            Abo ^= Do;
+            BCa = ROL(Abo, 28);
+            Agu ^= Du;
+            BCe = ROL(Agu, 20);
+            Aka ^= Da;
+            BCi = ROL(Aka,  3);
+            Ame ^= De;
+            BCo = ROL(Ame, 45);
+            Asi ^= Di;
+            BCu = ROL(Asi, 61);
+            Ega =   BCa ^((~BCe)&  BCi );
+            Ege =   BCe ^((~BCi)&  BCo );
+            Egi =   BCi ^((~BCo)&  BCu );
+            Ego =   BCo ^((~BCu)&  BCa );
+            Egu =   BCu ^((~BCa)&  BCe );
+
+            Abe ^= De;
+            BCa = ROL(Abe,  1);
+            Agi ^= Di;
+            BCe = ROL(Agi,  6);
+            Ako ^= Do;
+            BCi = ROL(Ako, 25);
+            Amu ^= Du;
+            BCo = ROL(Amu,  8);
+            Asa ^= Da;
+            BCu = ROL(Asa, 18);
+            Eka =   BCa ^((~BCe)&  BCi );
+            Eke =   BCe ^((~BCi)&  BCo );
+            Eki =   BCi ^((~BCo)&  BCu );
+            Eko =   BCo ^((~BCu)&  BCa );
+            Eku =   BCu ^((~BCa)&  BCe );
+
+            Abu ^= Du;
+            BCa = ROL(Abu, 27);
+            Aga ^= Da;
+            BCe = ROL(Aga, 36);
+            Ake ^= De;
+            BCi = ROL(Ake, 10);
+            Ami ^= Di;
+            BCo = ROL(Ami, 15);
+            Aso ^= Do;
+            BCu = ROL(Aso, 56);
+            Ema =   BCa ^((~BCe)&  BCi );
+            Eme =   BCe ^((~BCi)&  BCo );
+            Emi =   BCi ^((~BCo)&  BCu );
+            Emo =   BCo ^((~BCu)&  BCa );
+            Emu =   BCu ^((~BCa)&  BCe );
+
+            Abi ^= Di;
+            BCa = ROL(Abi, 62);
+            Ago ^= Do;
+            BCe = ROL(Ago, 55);
+            Aku ^= Du;
+            BCi = ROL(Aku, 39);
+            Ama ^= Da;
+            BCo = ROL(Ama, 41);
+            Ase ^= De;
+            BCu = ROL(Ase,  2);
+            Esa =   BCa ^((~BCe)&  BCi );
+            Ese =   BCe ^((~BCi)&  BCo );
+            Esi =   BCi ^((~BCo)&  BCu );
+            Eso =   BCo ^((~BCu)&  BCa );
+            Esu =   BCu ^((~BCa)&  BCe );
+
+            //    prepareTheta
+            BCa = Eba^Ega^Eka^Ema^Esa;
+            BCe = Ebe^Ege^Eke^Eme^Ese;
+            BCi = Ebi^Egi^Eki^Emi^Esi;
+            BCo = Ebo^Ego^Eko^Emo^Eso;
+            BCu = Ebu^Egu^Eku^Emu^Esu;
+
+            //thetaRhoPiChiIotaPrepareTheta(round+1, E, A)
+            Da = BCu^ROL(BCe, 1);
+            De = BCa^ROL(BCi, 1);
+            Di = BCe^ROL(BCo, 1);
+            Do = BCi^ROL(BCu, 1);
+            Du = BCo^ROL(BCa, 1);
+
+            Eba ^= Da;
+            BCa = Eba;
+            Ege ^= De;
+            BCe = ROL(Ege, 44);
+            Eki ^= Di;
+            BCi = ROL(Eki, 43);
+            Emo ^= Do;
+            BCo = ROL(Emo, 21);
+            Esu ^= Du;
+            BCu = ROL(Esu, 14);
+            Aba =   BCa ^((~BCe)&  BCi );
+            Aba ^= (uint64_t)KeccakF_RoundConstants[round+1];
+            Abe =   BCe ^((~BCi)&  BCo );
+            Abi =   BCi ^((~BCo)&  BCu );
+            Abo =   BCo ^((~BCu)&  BCa );
+            Abu =   BCu ^((~BCa)&  BCe );
+
+            Ebo ^= Do;
+            BCa = ROL(Ebo, 28);
+            Egu ^= Du;
+            BCe = ROL(Egu, 20);
+            Eka ^= Da;
+            BCi = ROL(Eka, 3);
+            Eme ^= De;
+            BCo = ROL(Eme, 45);
+            Esi ^= Di;
+            BCu = ROL(Esi, 61);
+            Aga =   BCa ^((~BCe)&  BCi );
+            Age =   BCe ^((~BCi)&  BCo );
+            Agi =   BCi ^((~BCo)&  BCu );
+            Ago =   BCo ^((~BCu)&  BCa );
+            Agu =   BCu ^((~BCa)&  BCe );
+
+            Ebe ^= De;
+            BCa = ROL(Ebe, 1);
+            Egi ^= Di;
+            BCe = ROL(Egi, 6);
+            Eko ^= Do;
+            BCi = ROL(Eko, 25);
+            Emu ^= Du;
+            BCo = ROL(Emu, 8);
+            Esa ^= Da;
+            BCu = ROL(Esa, 18);
+            Aka =   BCa ^((~BCe)&  BCi );
+            Ake =   BCe ^((~BCi)&  BCo );
+            Aki =   BCi ^((~BCo)&  BCu );
+            Ako =   BCo ^((~BCu)&  BCa );
+            Aku =   BCu ^((~BCa)&  BCe );
+
+            Ebu ^= Du;
+            BCa = ROL(Ebu, 27);
+            Ega ^= Da;
+            BCe = ROL(Ega, 36);
+            Eke ^= De;
+            BCi = ROL(Eke, 10);
+            Emi ^= Di;
+            BCo = ROL(Emi, 15);
+            Eso ^= Do;
+            BCu = ROL(Eso, 56);
+            Ama =   BCa ^((~BCe)&  BCi );
+            Ame =   BCe ^((~BCi)&  BCo );
+            Ami =   BCi ^((~BCo)&  BCu );
+            Amo =   BCo ^((~BCu)&  BCa );
+            Amu =   BCu ^((~BCa)&  BCe );
+
+            Ebi ^= Di;
+            BCa = ROL(Ebi, 62);
+            Ego ^= Do;
+            BCe = ROL(Ego, 55);
+            Eku ^= Du;
+            BCi = ROL(Eku, 39);
+            Ema ^= Da;
+            BCo = ROL(Ema, 41);
+            Ese ^= De;
+            BCu = ROL(Ese, 2);
+            Asa =   BCa ^((~BCe)&  BCi );
+            Ase =   BCe ^((~BCi)&  BCo );
+            Asi =   BCi ^((~BCo)&  BCu );
+            Aso =   BCo ^((~BCu)&  BCa );
+            Asu =   BCu ^((~BCa)&  BCe );
+        }
+
+        //copyToState(state, A)
+        state[ 0] = Aba;
+        state[ 1] = Abe;
+        state[ 2] = Abi;
+        state[ 3] = Abo;
+        state[ 4] = Abu;
+        state[ 5] = Aga;
+        state[ 6] = Age;
+        state[ 7] = Agi;
+        state[ 8] = Ago;
+        state[ 9] = Agu;
+        state[10] = Aka;
+        state[11] = Ake;
+        state[12] = Aki;
+        state[13] = Ako;
+        state[14] = Aku;
+        state[15] = Ama;
+        state[16] = Ame;
+        state[17] = Ami;
+        state[18] = Amo;
+        state[19] = Amu;
+        state[20] = Asa;
+        state[21] = Ase;
+        state[22] = Asi;
+        state[23] = Aso;
+        state[24] = Asu;
+}
+
+/*************************************************
+* Name:        keccak_init
+*
+* Description: Initializes the Keccak state.
+*
+* Arguments:   - uint64_t *s: pointer to Keccak state
+**************************************************/
+static void keccak_init(uint64_t s[25])
+{
+  unsigned int i;
+  for(i=0;i<25;i++)
+    s[i] = 0;
+}
+
+/*************************************************
+* Name:        keccak_absorb
+*
+* Description: Absorb step of Keccak; incremental.
+*
+* Arguments:   - uint64_t *s: pointer to Keccak state
+*              - unsigned int pos: position in current block to be absorbed
+*              - unsigned int r: rate in bytes (e.g., 168 for SHAKE128)
+*              - const uint8_t *in: pointer to input to be absorbed into s
+*              - size_t inlen: length of input in bytes
+*
+* Returns new position pos in current block
+**************************************************/
+static unsigned int keccak_absorb(uint64_t s[25],
+                                  unsigned int pos,
+                                  unsigned int r,
+                                  const uint8_t *in,
+                                  size_t inlen)
+{
+  unsigned int i;
+
+  while(pos+inlen >= r) {
+    for(i=pos;i<r;i++)
+      s[i/8] ^= (uint64_t)*in++ << 8*(i%8);
+    inlen -= r-pos;
+    KeccakF1600_StatePermute(s);
+    pos = 0;
+  }
+
+  for(i=pos;i<pos+inlen;i++)
+    s[i/8] ^= (uint64_t)*in++ << 8*(i%8);
+
+  return i;
+}
+
+/*************************************************
+* Name:        keccak_finalize
+*
+* Description: Finalize absorb step.
+*
+* Arguments:   - uint64_t *s: pointer to Keccak state
+*              - unsigned int pos: position in current block to be absorbed
+*              - unsigned int r: rate in bytes (e.g., 168 for SHAKE128)
+*              - uint8_t p: domain separation byte
+**************************************************/
+static void keccak_finalize(uint64_t s[25], unsigned int pos, unsigned int r, uint8_t p)
+{
+  s[pos/8] ^= (uint64_t)p << 8*(pos%8);
+  s[r/8-1] ^= 1ULL << 63;
+}
+
+/*************************************************
+* Name:        keccak_squeeze
+*
+* Description: Squeeze step of Keccak. Squeezes arbitratrily many bytes.
+*              Modifies the state. Can be called multiple times to keep
+*              squeezing, i.e., is incremental.
+*
+* Arguments:   - uint8_t *out: pointer to output
+*              - size_t outlen: number of bytes to be squeezed (written to out)
+*              - uint64_t *s: pointer to input/output Keccak state
+*              - unsigned int pos: number of bytes in current block already squeezed
+*              - unsigned int r: rate in bytes (e.g., 168 for SHAKE128)
+*
+* Returns new position pos in current block
+**************************************************/
+static unsigned int keccak_squeeze(uint8_t *out,
+                                   size_t outlen,
+                                   uint64_t s[25],
+                                   unsigned int pos,
+                                   unsigned int r)
+{
+  unsigned int i;
+
+  while(outlen) {
+    if(pos == r) {
+      KeccakF1600_StatePermute(s);
+      pos = 0;
+    }
+    for(i=pos;i < r && i < pos+outlen; i++)
+      *out++ = s[i/8] >> 8*(i%8);
+    outlen -= i-pos;
+    pos = i;
+  }
+
+  return pos;
+}
+
+
+/*************************************************
+* Name:        keccak_absorb_once
+*
+* Description: Absorb step of Keccak;
+*              non-incremental, starts by zeroeing the state.
+*
+* Arguments:   - uint64_t *s: pointer to (uninitialized) output Keccak state
+*              - unsigned int r: rate in bytes (e.g., 168 for SHAKE128)
+*              - const uint8_t *in: pointer to input to be absorbed into s
+*              - size_t inlen: length of input in bytes
+*              - uint8_t p: domain-separation byte for different Keccak-derived functions
+**************************************************/
+static void keccak_absorb_once(uint64_t s[25],
+                               unsigned int r,
+                               const uint8_t *in,
+                               size_t inlen,
+                               uint8_t p)
+{
+  unsigned int i;
+
+  for(i=0;i<25;i++)
+    s[i] = 0;
+
+  while(inlen >= r) {
+    for(i=0;i<r/8;i++)
+      s[i] ^= load64(in+8*i);
+    in += r;
+    inlen -= r;
+    KeccakF1600_StatePermute(s);
+  }
+
+  for(i=0;i<inlen;i++)
+    s[i/8] ^= (uint64_t)in[i] << 8*(i%8);
+
+  s[i/8] ^= (uint64_t)p << 8*(i%8);
+  s[(r-1)/8] ^= 1ULL << 63;
+}
+
+/*************************************************
+* Name:        keccak_squeezeblocks
+*
+* Description: Squeeze step of Keccak. Squeezes full blocks of r bytes each.
+*              Modifies the state. Can be called multiple times to keep
+*              squeezing, i.e., is incremental. Assumes zero bytes of current
+*              block have already been squeezed.
+*
+* Arguments:   - uint8_t *out: pointer to output blocks
+*              - size_t nblocks: number of blocks to be squeezed (written to out)
+*              - uint64_t *s: pointer to input/output Keccak state
+*              - unsigned int r: rate in bytes (e.g., 168 for SHAKE128)
+**************************************************/
+static void keccak_squeezeblocks(uint8_t *out,
+                                 size_t nblocks,
+                                 uint64_t s[25],
+                                 unsigned int r)
+{
+  unsigned int i;
+
+  while(nblocks) {
+    KeccakF1600_StatePermute(s);
+    for(i=0;i<r/8;i++)
+      store64(out+8*i, s[i]);
+    out += r;
+    nblocks -= 1;
+  }
+}
+
+/*************************************************
+* Name:        shake128_init
+*
+* Description: Initilizes Keccak state for use as SHAKE128 XOF
+*
+* Arguments:   - keccak_state *state: pointer to (uninitialized) Keccak state
+**************************************************/
+void shake128_init(keccak_state *state)
+{
+  keccak_init(state->s);
+  state->pos = 0;
+}
+
+/*************************************************
+* Name:        shake128_absorb
+*
+* Description: Absorb step of the SHAKE128 XOF; incremental.
+*
+* Arguments:   - keccak_state *state: pointer to (initialized) output Keccak state
+*              - const uint8_t *in: pointer to input to be absorbed into s
+*              - size_t inlen: length of input in bytes
+**************************************************/
+void shake128_absorb(keccak_state *state, const uint8_t *in, size_t inlen)
+{
+  state->pos = keccak_absorb(state->s, state->pos, SHAKE128_RATE, in, inlen);
+}
+
+/*************************************************
+* Name:        shake128_finalize
+*
+* Description: Finalize absorb step of the SHAKE128 XOF.
+*
+* Arguments:   - keccak_state *state: pointer to Keccak state
+**************************************************/
+void shake128_finalize(keccak_state *state)
+{
+  keccak_finalize(state->s, state->pos, SHAKE128_RATE, 0x1F);
+  state->pos = SHAKE128_RATE;
+}
+
+/*************************************************
+* Name:        shake128_squeeze
+*
+* Description: Squeeze step of SHAKE128 XOF. Squeezes arbitraily many
+*              bytes. Can be called multiple times to keep squeezing.
+*
+* Arguments:   - uint8_t *out: pointer to output blocks
+*              - size_t outlen : number of bytes to be squeezed (written to output)
+*              - keccak_state *s: pointer to input/output Keccak state
+**************************************************/
+void shake128_squeeze(uint8_t *out, size_t outlen, keccak_state *state)
+{
+  state->pos = keccak_squeeze(out, outlen, state->s, state->pos, SHAKE128_RATE);
+}
+
+/*************************************************
+* Name:        shake128_absorb_once
+*
+* Description: Initialize, absorb into and finalize SHAKE128 XOF; non-incremental.
+*
+* Arguments:   - keccak_state *state: pointer to (uninitialized) output Keccak state
+*              - const uint8_t *in: pointer to input to be absorbed into s
+*              - size_t inlen: length of input in bytes
+**************************************************/
+void shake128_absorb_once(keccak_state *state, const uint8_t *in, size_t inlen)
+{
+  keccak_absorb_once(state->s, SHAKE128_RATE, in, inlen, 0x1F);
+  state->pos = SHAKE128_RATE;
+}
+
+/*************************************************
+* Name:        shake128_squeezeblocks
+*
+* Description: Squeeze step of SHAKE128 XOF. Squeezes full blocks of
+*              SHAKE128_RATE bytes each. Can be called multiple times
+*              to keep squeezing. Assumes new block has not yet been
+*              started (state->pos = SHAKE128_RATE).
+*
+* Arguments:   - uint8_t *out: pointer to output blocks
+*              - size_t nblocks: number of blocks to be squeezed (written to output)
+*              - keccak_state *s: pointer to input/output Keccak state
+**************************************************/
+void shake128_squeezeblocks(uint8_t *out, size_t nblocks, keccak_state *state)
+{
+  keccak_squeezeblocks(out, nblocks, state->s, SHAKE128_RATE);
+}
+
+/*************************************************
+* Name:        shake256_init
+*
+* Description: Initilizes Keccak state for use as SHAKE256 XOF
+*
+* Arguments:   - keccak_state *state: pointer to (uninitialized) Keccak state
+**************************************************/
+void shake256_init(keccak_state *state)
+{
+  keccak_init(state->s);
+  state->pos = 0;
+}
+
+/*************************************************
+* Name:        shake256_absorb
+*
+* Description: Absorb step of the SHAKE256 XOF; incremental.
+*
+* Arguments:   - keccak_state *state: pointer to (initialized) output Keccak state
+*              - const uint8_t *in: pointer to input to be absorbed into s
+*              - size_t inlen: length of input in bytes
+**************************************************/
+void shake256_absorb(keccak_state *state, const uint8_t *in, size_t inlen)
+{
+  state->pos = keccak_absorb(state->s, state->pos, SHAKE256_RATE, in, inlen);
+}
+
+/*************************************************
+* Name:        shake256_finalize
+*
+* Description: Finalize absorb step of the SHAKE256 XOF.
+*
+* Arguments:   - keccak_state *state: pointer to Keccak state
+**************************************************/
+void shake256_finalize(keccak_state *state)
+{
+  keccak_finalize(state->s, state->pos, SHAKE256_RATE, 0x1F);
+  state->pos = SHAKE256_RATE;
+}
+
+/*************************************************
+* Name:        shake256_squeeze
+*
+* Description: Squeeze step of SHAKE256 XOF. Squeezes arbitraily many
+*              bytes. Can be called multiple times to keep squeezing.
+*
+* Arguments:   - uint8_t *out: pointer to output blocks
+*              - size_t outlen : number of bytes to be squeezed (written to output)
+*              - keccak_state *s: pointer to input/output Keccak state
+**************************************************/
+void shake256_squeeze(uint8_t *out, size_t outlen, keccak_state *state)
+{
+  state->pos = keccak_squeeze(out, outlen, state->s, state->pos, SHAKE256_RATE);
+}
+
+/*************************************************
+* Name:        shake256_absorb_once
+*
+* Description: Initialize, absorb into and finalize SHAKE256 XOF; non-incremental.
+*
+* Arguments:   - keccak_state *state: pointer to (uninitialized) output Keccak state
+*              - const uint8_t *in: pointer to input to be absorbed into s
+*              - size_t inlen: length of input in bytes
+**************************************************/
+void shake256_absorb_once(keccak_state *state, const uint8_t *in, size_t inlen)
+{
+  keccak_absorb_once(state->s, SHAKE256_RATE, in, inlen, 0x1F);
+  state->pos = SHAKE256_RATE;
+}
+
+/*************************************************
+* Name:        shake256_squeezeblocks
+*
+* Description: Squeeze step of SHAKE256 XOF. Squeezes full blocks of
+*              SHAKE256_RATE bytes each. Can be called multiple times
+*              to keep squeezing. Assumes next block has not yet been
+*              started (state->pos = SHAKE256_RATE).
+*
+* Arguments:   - uint8_t *out: pointer to output blocks
+*              - size_t nblocks: number of blocks to be squeezed (written to output)
+*              - keccak_state *s: pointer to input/output Keccak state
+**************************************************/
+void shake256_squeezeblocks(uint8_t *out, size_t nblocks, keccak_state *state)
+{
+  keccak_squeezeblocks(out, nblocks, state->s, SHAKE256_RATE);
+}
+
+/*************************************************
+* Name:        shake128
+*
+* Description: SHAKE128 XOF with non-incremental API
+*
+* Arguments:   - uint8_t *out: pointer to output
+*              - size_t outlen: requested output length in bytes
+*              - const uint8_t *in: pointer to input
+*              - size_t inlen: length of input in bytes
+**************************************************/
+void shake128(uint8_t *out, size_t outlen, const uint8_t *in, size_t inlen)
+{
+  size_t nblocks;
+  keccak_state state;
+
+  shake128_absorb_once(&state, in, inlen);
+  nblocks = outlen/SHAKE128_RATE;
+  shake128_squeezeblocks(out, nblocks, &state);
+  outlen -= nblocks*SHAKE128_RATE;
+  out += nblocks*SHAKE128_RATE;
+  shake128_squeeze(out, outlen, &state);
+}
+
+/*************************************************
+* Name:        shake256
+*
+* Description: SHAKE256 XOF with non-incremental API
+*
+* Arguments:   - uint8_t *out: pointer to output
+*              - size_t outlen: requested output length in bytes
+*              - const uint8_t *in: pointer to input
+*              - size_t inlen: length of input in bytes
+**************************************************/
+void shake256(uint8_t *out, size_t outlen, const uint8_t *in, size_t inlen)
+{
+  size_t nblocks;
+  keccak_state state;
+
+  shake256_absorb_once(&state, in, inlen);
+  nblocks = outlen/SHAKE256_RATE;
+  shake256_squeezeblocks(out, nblocks, &state);
+  outlen -= nblocks*SHAKE256_RATE;
+  out += nblocks*SHAKE256_RATE;
+  shake256_squeeze(out, outlen, &state);
+}
+
+/*************************************************
+* Name:        sha3_256
+*
+* Description: SHA3-256 with non-incremental API
+*
+* Arguments:   - uint8_t *h: pointer to output (32 bytes)
+*              - const uint8_t *in: pointer to input
+*              - size_t inlen: length of input in bytes
+**************************************************/
+void sha3_256(uint8_t h[32], const uint8_t *in, size_t inlen)
+{
+  unsigned int i;
+  uint64_t s[25];
+
+  keccak_absorb_once(s, SHA3_256_RATE, in, inlen, 0x06);
+  KeccakF1600_StatePermute(s);
+  for(i=0;i<4;i++)
+    store64(h+8*i,s[i]);
+}
+
+/*************************************************
+* Name:        sha3_512
+*
+* Description: SHA3-512 with non-incremental API
+*
+* Arguments:   - uint8_t *h: pointer to output (64 bytes)
+*              - const uint8_t *in: pointer to input
+*              - size_t inlen: length of input in bytes
+**************************************************/
+void sha3_512(uint8_t h[64], const uint8_t *in, size_t inlen)
+{
+  unsigned int i;
+  uint64_t s[25];
+
+  keccak_absorb_once(s, SHA3_512_RATE, in, inlen, 0x06);
+  KeccakF1600_StatePermute(s);
+  for(i=0;i<8;i++)
+    store64(h+8*i,s[i]);
+}
diff --git a/nimble/host/src/kyber/fips202.h b/nimble/host/src/kyber/fips202.h
new file mode 100644
index 00000000..df2dde57
--- /dev/null
+++ b/nimble/host/src/kyber/fips202.h
@@ -0,0 +1,54 @@
+#ifndef FIPS202_H
+#define FIPS202_H
+
+#include <stddef.h>
+#include <stdint.h>
+
+#define SHAKE128_RATE 168
+#define SHAKE256_RATE 136
+#define SHA3_256_RATE 136
+#define SHA3_512_RATE 72
+
+#define FIPS202_NAMESPACE(s) pqcrystals_kyber_fips202_ref_##s
+
+typedef struct {
+  uint64_t s[25];
+  unsigned int pos;
+} keccak_state;
+
+#define shake128_init FIPS202_NAMESPACE(shake128_init)
+void shake128_init(keccak_state *state);
+#define shake128_absorb FIPS202_NAMESPACE(shake128_absorb)
+void shake128_absorb(keccak_state *state, const uint8_t *in, size_t inlen);
+#define shake128_finalize FIPS202_NAMESPACE(shake128_finalize)
+void shake128_finalize(keccak_state *state);
+#define shake128_squeeze FIPS202_NAMESPACE(shake128_squeeze)
+void shake128_squeeze(uint8_t *out, size_t outlen, keccak_state *state);
+#define shake128_absorb_once FIPS202_NAMESPACE(shake128_absorb_once)
+void shake128_absorb_once(keccak_state *state, const uint8_t *in, size_t inlen);
+#define shake128_squeezeblocks FIPS202_NAMESPACE(shake128_squeezeblocks)
+void shake128_squeezeblocks(uint8_t *out, size_t nblocks, keccak_state *state);
+
+#define shake256_init FIPS202_NAMESPACE(shake256_init)
+void shake256_init(keccak_state *state);
+#define shake256_absorb FIPS202_NAMESPACE(shake256_absorb)
+void shake256_absorb(keccak_state *state, const uint8_t *in, size_t inlen);
+#define shake256_finalize FIPS202_NAMESPACE(shake256_finalize)
+void shake256_finalize(keccak_state *state);
+#define shake256_squeeze FIPS202_NAMESPACE(shake256_squeeze)
+void shake256_squeeze(uint8_t *out, size_t outlen, keccak_state *state);
+#define shake256_absorb_once FIPS202_NAMESPACE(shake256_absorb_once)
+void shake256_absorb_once(keccak_state *state, const uint8_t *in, size_t inlen);
+#define shake256_squeezeblocks FIPS202_NAMESPACE(shake256_squeezeblocks)
+void shake256_squeezeblocks(uint8_t *out, size_t nblocks,  keccak_state *state);
+
+#define shake128 FIPS202_NAMESPACE(shake128)
+void shake128(uint8_t *out, size_t outlen, const uint8_t *in, size_t inlen);
+#define shake256 FIPS202_NAMESPACE(shake256)
+void shake256(uint8_t *out, size_t outlen, const uint8_t *in, size_t inlen);
+#define sha3_256 FIPS202_NAMESPACE(sha3_256)
+void sha3_256(uint8_t h[32], const uint8_t *in, size_t inlen);
+#define sha3_512 FIPS202_NAMESPACE(sha3_512)
+void sha3_512(uint8_t h[64], const uint8_t *in, size_t inlen);
+
+#endif
diff --git a/nimble/host/src/kyber/indcpa.c b/nimble/host/src/kyber/indcpa.c
new file mode 100644
index 00000000..633fe300
--- /dev/null
+++ b/nimble/host/src/kyber/indcpa.c
@@ -0,0 +1,334 @@
+#include <stddef.h>
+#include <stdint.h>
+#include <string.h>
+#include "params.h"
+#include "indcpa.h"
+#include "polyvec.h"
+#include "poly.h"
+#include "ntt.h"
+#include "symmetric.h"
+#include "randombytes.h"
+
+/*************************************************
+* Name:        pack_pk
+*
+* Description: Serialize the public key as concatenation of the
+*              serialized vector of polynomials pk
+*              and the public seed used to generate the matrix A.
+*
+* Arguments:   uint8_t *r: pointer to the output serialized public key
+*              polyvec *pk: pointer to the input public-key polyvec
+*              const uint8_t *seed: pointer to the input public seed
+**************************************************/
+static void pack_pk(uint8_t r[KYBER_INDCPA_PUBLICKEYBYTES],
+                    polyvec *pk,
+                    const uint8_t seed[KYBER_SYMBYTES])
+{
+  polyvec_tobytes(r, pk);
+  memcpy(r+KYBER_POLYVECBYTES, seed, KYBER_SYMBYTES);
+}
+
+/*************************************************
+* Name:        unpack_pk
+*
+* Description: De-serialize public key from a byte array;
+*              approximate inverse of pack_pk
+*
+* Arguments:   - polyvec *pk: pointer to output public-key polynomial vector
+*              - uint8_t *seed: pointer to output seed to generate matrix A
+*              - const uint8_t *packedpk: pointer to input serialized public key
+**************************************************/
+static void unpack_pk(polyvec *pk,
+                      uint8_t seed[KYBER_SYMBYTES],
+                      const uint8_t packedpk[KYBER_INDCPA_PUBLICKEYBYTES])
+{
+  polyvec_frombytes(pk, packedpk);
+  memcpy(seed, packedpk+KYBER_POLYVECBYTES, KYBER_SYMBYTES);
+}
+
+/*************************************************
+* Name:        pack_sk
+*
+* Description: Serialize the secret key
+*
+* Arguments:   - uint8_t *r: pointer to output serialized secret key
+*              - polyvec *sk: pointer to input vector of polynomials (secret key)
+**************************************************/
+static void pack_sk(uint8_t r[KYBER_INDCPA_SECRETKEYBYTES], polyvec *sk)
+{
+  polyvec_tobytes(r, sk);
+}
+
+/*************************************************
+* Name:        unpack_sk
+*
+* Description: De-serialize the secret key; inverse of pack_sk
+*
+* Arguments:   - polyvec *sk: pointer to output vector of polynomials (secret key)
+*              - const uint8_t *packedsk: pointer to input serialized secret key
+**************************************************/
+static void unpack_sk(polyvec *sk, const uint8_t packedsk[KYBER_INDCPA_SECRETKEYBYTES])
+{
+  polyvec_frombytes(sk, packedsk);
+}
+
+/*************************************************
+* Name:        pack_ciphertext
+*
+* Description: Serialize the ciphertext as concatenation of the
+*              compressed and serialized vector of polynomials b
+*              and the compressed and serialized polynomial v
+*
+* Arguments:   uint8_t *r: pointer to the output serialized ciphertext
+*              poly *pk: pointer to the input vector of polynomials b
+*              poly *v: pointer to the input polynomial v
+**************************************************/
+static void pack_ciphertext(uint8_t r[KYBER_INDCPA_BYTES], polyvec *b, poly *v)
+{
+  polyvec_compress(r, b);
+  poly_compress(r+KYBER_POLYVECCOMPRESSEDBYTES, v);
+}
+
+/*************************************************
+* Name:        unpack_ciphertext
+*
+* Description: De-serialize and decompress ciphertext from a byte array;
+*              approximate inverse of pack_ciphertext
+*
+* Arguments:   - polyvec *b: pointer to the output vector of polynomials b
+*              - poly *v: pointer to the output polynomial v
+*              - const uint8_t *c: pointer to the input serialized ciphertext
+**************************************************/
+static void unpack_ciphertext(polyvec *b, poly *v, const uint8_t c[KYBER_INDCPA_BYTES])
+{
+  polyvec_decompress(b, c);
+  poly_decompress(v, c+KYBER_POLYVECCOMPRESSEDBYTES);
+}
+
+/*************************************************
+* Name:        rej_uniform
+*
+* Description: Run rejection sampling on uniform random bytes to generate
+*              uniform random integers mod q
+*
+* Arguments:   - int16_t *r: pointer to output buffer
+*              - unsigned int len: requested number of 16-bit integers (uniform mod q)
+*              - const uint8_t *buf: pointer to input buffer (assumed to be uniformly random bytes)
+*              - unsigned int buflen: length of input buffer in bytes
+*
+* Returns number of sampled 16-bit integers (at most len)
+**************************************************/
+static unsigned int rej_uniform(int16_t *r,
+                                unsigned int len,
+                                const uint8_t *buf,
+                                unsigned int buflen)
+{
+  unsigned int ctr, pos;
+  uint16_t val0, val1;
+
+  ctr = pos = 0;
+  while(ctr < len && pos + 3 <= buflen) {
+    val0 = ((buf[pos+0] >> 0) | ((uint16_t)buf[pos+1] << 8)) & 0xFFF;
+    val1 = ((buf[pos+1] >> 4) | ((uint16_t)buf[pos+2] << 4)) & 0xFFF;
+    pos += 3;
+
+    if(val0 < KYBER_Q)
+      r[ctr++] = val0;
+    if(ctr < len && val1 < KYBER_Q)
+      r[ctr++] = val1;
+  }
+
+  return ctr;
+}
+
+#define gen_a(A,B)  gen_matrix(A,B,0)
+#define gen_at(A,B) gen_matrix(A,B,1)
+
+/*************************************************
+* Name:        gen_matrix
+*
+* Description: Deterministically generate matrix A (or the transpose of A)
+*              from a seed. Entries of the matrix are polynomials that look
+*              uniformly random. Performs rejection sampling on output of
+*              a XOF
+*
+* Arguments:   - polyvec *a: pointer to ouptput matrix A
+*              - const uint8_t *seed: pointer to input seed
+*              - int transposed: boolean deciding whether A or A^T is generated
+**************************************************/
+#if(XOF_BLOCKBYTES % 3)
+#error "Implementation of gen_matrix assumes that XOF_BLOCKBYTES is a multiple of 3"
+#endif
+
+#define GEN_MATRIX_NBLOCKS ((12*KYBER_N/8*(1 << 12)/KYBER_Q + XOF_BLOCKBYTES)/XOF_BLOCKBYTES)
+// Not static for benchmarking
+void gen_matrix(polyvec *a, const uint8_t seed[KYBER_SYMBYTES], int transposed)
+{
+  unsigned int ctr, i, j;
+  unsigned int buflen;
+  uint8_t buf[GEN_MATRIX_NBLOCKS*XOF_BLOCKBYTES];
+  xof_state state;
+
+  for(i=0;i<KYBER_K;i++) {
+    for(j=0;j<KYBER_K;j++) {
+      if(transposed)
+        xof_absorb(&state, seed, i, j);
+      else
+        xof_absorb(&state, seed, j, i);
+
+      xof_squeezeblocks(buf, GEN_MATRIX_NBLOCKS, &state);
+      buflen = GEN_MATRIX_NBLOCKS*XOF_BLOCKBYTES;
+      ctr = rej_uniform(a[i].vec[j].coeffs, KYBER_N, buf, buflen);
+
+      while(ctr < KYBER_N) {
+        xof_squeezeblocks(buf, 1, &state);
+        buflen = XOF_BLOCKBYTES;
+        ctr += rej_uniform(a[i].vec[j].coeffs + ctr, KYBER_N - ctr, buf, buflen);
+      }
+    }
+  }
+}
+
+/*************************************************
+* Name:        indcpa_keypair_derand
+*
+* Description: Generates public and private key for the CPA-secure
+*              public-key encryption scheme underlying Kyber
+*
+* Arguments:   - uint8_t *pk: pointer to output public key
+*                             (of length KYBER_INDCPA_PUBLICKEYBYTES bytes)
+*              - uint8_t *sk: pointer to output private key
+*                             (of length KYBER_INDCPA_SECRETKEYBYTES bytes)
+*              - const uint8_t *coins: pointer to input randomness
+*                             (of length KYBER_SYMBYTES bytes)
+**************************************************/
+void indcpa_keypair_derand(uint8_t pk[KYBER_INDCPA_PUBLICKEYBYTES],
+                           uint8_t sk[KYBER_INDCPA_SECRETKEYBYTES],
+                           const uint8_t coins[KYBER_SYMBYTES])
+{
+  unsigned int i;
+  uint8_t buf[2*KYBER_SYMBYTES];
+  const uint8_t *publicseed = buf;
+  const uint8_t *noiseseed = buf+KYBER_SYMBYTES;
+  uint8_t nonce = 0;
+  polyvec a[KYBER_K], e, pkpv, skpv;
+
+  memcpy(buf, coins, KYBER_SYMBYTES);
+  buf[KYBER_SYMBYTES] = KYBER_K;
+  hash_g(buf, buf, KYBER_SYMBYTES+1);
+
+  gen_a(a, publicseed);
+
+  for(i=0;i<KYBER_K;i++)
+    poly_getnoise_eta1(&skpv.vec[i], noiseseed, nonce++);
+  for(i=0;i<KYBER_K;i++)
+    poly_getnoise_eta1(&e.vec[i], noiseseed, nonce++);
+
+  polyvec_ntt(&skpv);
+  polyvec_ntt(&e);
+
+  // matrix-vector multiplication
+  for(i=0;i<KYBER_K;i++) {
+    polyvec_basemul_acc_montgomery(&pkpv.vec[i], &a[i], &skpv);
+    poly_tomont(&pkpv.vec[i]);
+  }
+
+  polyvec_add(&pkpv, &pkpv, &e);
+  polyvec_reduce(&pkpv);
+
+  pack_sk(sk, &skpv);
+  pack_pk(pk, &pkpv, publicseed);
+}
+
+
+/*************************************************
+* Name:        indcpa_enc
+*
+* Description: Encryption function of the CPA-secure
+*              public-key encryption scheme underlying Kyber.
+*
+* Arguments:   - uint8_t *c: pointer to output ciphertext
+*                            (of length KYBER_INDCPA_BYTES bytes)
+*              - const uint8_t *m: pointer to input message
+*                                  (of length KYBER_INDCPA_MSGBYTES bytes)
+*              - const uint8_t *pk: pointer to input public key
+*                                   (of length KYBER_INDCPA_PUBLICKEYBYTES)
+*              - const uint8_t *coins: pointer to input random coins used as seed
+*                                      (of length KYBER_SYMBYTES) to deterministically
+*                                      generate all randomness
+**************************************************/
+void indcpa_enc(uint8_t c[KYBER_INDCPA_BYTES],
+                const uint8_t m[KYBER_INDCPA_MSGBYTES],
+                const uint8_t pk[KYBER_INDCPA_PUBLICKEYBYTES],
+                const uint8_t coins[KYBER_SYMBYTES])
+{
+  unsigned int i;
+  uint8_t seed[KYBER_SYMBYTES];
+  uint8_t nonce = 0;
+  polyvec sp, pkpv, ep, at[KYBER_K], b;
+  poly v, k, epp;
+
+  unpack_pk(&pkpv, seed, pk);
+  poly_frommsg(&k, m);
+  gen_at(at, seed);
+
+
+
+  for(i=0;i<KYBER_K;i++)
+    poly_getnoise_eta1(sp.vec+i, coins, nonce++);
+  for(i=0;i<KYBER_K;i++)
+    poly_getnoise_eta2(ep.vec+i, coins, nonce++);
+  poly_getnoise_eta2(&epp, coins, nonce++);
+
+  polyvec_ntt(&sp);
+
+  // matrix-vector multiplication
+  for(i=0;i<KYBER_K;i++)
+    polyvec_basemul_acc_montgomery(&b.vec[i], &at[i], &sp);
+
+  polyvec_basemul_acc_montgomery(&v, &pkpv, &sp);
+
+  polyvec_invntt_tomont(&b);
+  poly_invntt_tomont(&v);
+
+  polyvec_add(&b, &b, &ep);
+  poly_add(&v, &v, &epp);
+  poly_add(&v, &v, &k);
+  polyvec_reduce(&b);
+  poly_reduce(&v);
+
+  pack_ciphertext(c, &b, &v);
+}
+
+/*************************************************
+* Name:        indcpa_dec
+*
+* Description: Decryption function of the CPA-secure
+*              public-key encryption scheme underlying Kyber.
+*
+* Arguments:   - uint8_t *m: pointer to output decrypted message
+*                            (of length KYBER_INDCPA_MSGBYTES)
+*              - const uint8_t *c: pointer to input ciphertext
+*                                  (of length KYBER_INDCPA_BYTES)
+*              - const uint8_t *sk: pointer to input secret key
+*                                   (of length KYBER_INDCPA_SECRETKEYBYTES)
+**************************************************/
+void indcpa_dec(uint8_t m[KYBER_INDCPA_MSGBYTES],
+                const uint8_t c[KYBER_INDCPA_BYTES],
+                const uint8_t sk[KYBER_INDCPA_SECRETKEYBYTES])
+{
+  polyvec b, skpv;
+  poly v, mp;
+
+  unpack_ciphertext(&b, &v, c);
+  unpack_sk(&skpv, sk);
+
+  polyvec_ntt(&b);
+  polyvec_basemul_acc_montgomery(&mp, &skpv, &b);
+  poly_invntt_tomont(&mp);
+
+  poly_sub(&mp, &v, &mp);
+  poly_reduce(&mp);
+
+  poly_tomsg(m, &mp);
+}
diff --git a/nimble/host/src/kyber/indcpa.h b/nimble/host/src/kyber/indcpa.h
new file mode 100644
index 00000000..6dd5088c
--- /dev/null
+++ b/nimble/host/src/kyber/indcpa.h
@@ -0,0 +1,27 @@
+#ifndef INDCPA_H
+#define INDCPA_H
+
+#include <stdint.h>
+#include "params.h"
+#include "polyvec.h"
+
+#define gen_matrix KYBER_NAMESPACE(gen_matrix)
+void gen_matrix(polyvec *a, const uint8_t seed[KYBER_SYMBYTES], int transposed);
+
+#define indcpa_keypair_derand KYBER_NAMESPACE(indcpa_keypair_derand)
+void indcpa_keypair_derand(uint8_t pk[KYBER_INDCPA_PUBLICKEYBYTES],
+                           uint8_t sk[KYBER_INDCPA_SECRETKEYBYTES],
+                           const uint8_t coins[KYBER_SYMBYTES]);
+
+#define indcpa_enc KYBER_NAMESPACE(indcpa_enc)
+void indcpa_enc(uint8_t c[KYBER_INDCPA_BYTES],
+                const uint8_t m[KYBER_INDCPA_MSGBYTES],
+                const uint8_t pk[KYBER_INDCPA_PUBLICKEYBYTES],
+                const uint8_t coins[KYBER_SYMBYTES]);
+
+#define indcpa_dec KYBER_NAMESPACE(indcpa_dec)
+void indcpa_dec(uint8_t m[KYBER_INDCPA_MSGBYTES],
+                const uint8_t c[KYBER_INDCPA_BYTES],
+                const uint8_t sk[KYBER_INDCPA_SECRETKEYBYTES]);
+
+#endif
diff --git a/nimble/host/src/kyber/kem.c b/nimble/host/src/kyber/kem.c
new file mode 100644
index 00000000..1594a245
--- /dev/null
+++ b/nimble/host/src/kyber/kem.c
@@ -0,0 +1,171 @@
+#include <stddef.h>
+#include <stdint.h>
+#include <string.h>
+#include "params.h"
+#include "kem.h"
+#include "indcpa.h"
+#include "verify.h"
+#include "symmetric.h"
+#include "randombytes.h"
+/*************************************************
+* Name:        crypto_kem_keypair_derand
+*
+* Description: Generates public and private key
+*              for CCA-secure Kyber key encapsulation mechanism
+*
+* Arguments:   - uint8_t *pk: pointer to output public key
+*                (an already allocated array of KYBER_PUBLICKEYBYTES bytes)
+*              - uint8_t *sk: pointer to output private key
+*                (an already allocated array of KYBER_SECRETKEYBYTES bytes)
+*              - uint8_t *coins: pointer to input randomness
+*                (an already allocated array filled with 2*KYBER_SYMBYTES random bytes)
+**
+* Returns 0 (success)
+**************************************************/
+int
+crypto_kem_keypair_derand(uint8_t* pk, uint8_t* sk, const uint8_t* coins)
+{
+    indcpa_keypair_derand(pk, sk, coins);
+    memcpy(sk + KYBER_INDCPA_SECRETKEYBYTES, pk, KYBER_PUBLICKEYBYTES);
+    hash_h(sk + KYBER_SECRETKEYBYTES - 2 * KYBER_SYMBYTES, pk,
+           KYBER_PUBLICKEYBYTES);
+    /* Value z for pseudo-random output on reject */
+    memcpy(sk + KYBER_SECRETKEYBYTES - KYBER_SYMBYTES, coins + KYBER_SYMBYTES,
+           KYBER_SYMBYTES);
+    return 0;
+}
+
+/*************************************************
+* Name:        crypto_kem_keypair
+*
+* Description: Generates public and private key
+*              for CCA-secure Kyber key encapsulation mechanism
+*
+* Arguments:   - uint8_t *pk: pointer to output public key
+*                (an already allocated array of KYBER_PUBLICKEYBYTES bytes)
+*              - uint8_t *sk: pointer to output private key
+*                (an already allocated array of KYBER_SECRETKEYBYTES bytes)
+*
+* Returns 0 (success)
+**************************************************/
+int
+crypto_kem_keypair(uint8_t* pk, uint8_t* sk)
+{
+    uint8_t coins[2 * KYBER_SYMBYTES];
+    randombytes(coins, 2 * KYBER_SYMBYTES);
+    crypto_kem_keypair_derand(pk, sk, coins);
+    return 0;
+}
+
+/*************************************************
+* Name:        crypto_kem_enc_derand
+*
+* Description: Generates cipher text and shared
+*              secret for given public key
+*
+* Arguments:   - uint8_t *ct: pointer to output cipher text
+*                (an already allocated array of KYBER_CIPHERTEXTBYTES bytes)
+*              - uint8_t *ss: pointer to output shared secret
+*                (an already allocated array of KYBER_SSBYTES bytes)
+*              - const uint8_t *pk: pointer to input public key
+*                (an already allocated array of KYBER_PUBLICKEYBYTES bytes)
+*              - const uint8_t *coins: pointer to input randomness
+*                (an already allocated array filled with KYBER_SYMBYTES random bytes)
+**
+* Returns 0 (success)
+**************************************************/
+int
+crypto_kem_enc_derand(uint8_t* ct, uint8_t* ss, const uint8_t* pk,
+                      const uint8_t* coins)
+{
+    uint8_t buf[2 * KYBER_SYMBYTES];
+    /* Will contain key, coins */
+    uint8_t kr[2 * KYBER_SYMBYTES];
+
+    memcpy(buf, coins, KYBER_SYMBYTES);
+
+    /* Multitarget countermeasure for coins + contributory KEM */
+    hash_h(buf + KYBER_SYMBYTES, pk, KYBER_PUBLICKEYBYTES);
+
+    hash_g(kr, buf, 2 * KYBER_SYMBYTES);
+
+    /* coins are in kr+KYBER_SYMBYTES */
+    indcpa_enc(ct, buf, pk, kr + KYBER_SYMBYTES);
+
+    memcpy(ss, kr, KYBER_SYMBYTES);
+
+    return 0;
+}
+
+/*************************************************
+* Name:        crypto_kem_enc
+*
+* Description: Generates cipher text and shared
+*              secret for given public key
+*
+* Arguments:   - uint8_t *ct: pointer to output cipher text
+*                (an already allocated array of KYBER_CIPHERTEXTBYTES bytes)
+*              - uint8_t *ss: pointer to output shared secret
+*                (an already allocated array of KYBER_SSBYTES bytes)
+*              - const uint8_t *pk: pointer to input public key
+*                (an already allocated array of KYBER_PUBLICKEYBYTES bytes)
+*
+* Returns 0 (success)
+**************************************************/
+int
+crypto_kem_enc(uint8_t* ct, uint8_t* ss, const uint8_t* pk)
+{
+    uint8_t coins[KYBER_SYMBYTES];
+    randombytes(coins, KYBER_SYMBYTES);
+    crypto_kem_enc_derand(ct, ss, pk, coins);
+    return 0;
+}
+
+/*************************************************
+* Name:        crypto_kem_dec
+*
+* Description: Generates shared secret for given
+*              cipher text and private key
+*
+* Arguments:   - uint8_t *ss: pointer to output shared secret
+*                (an already allocated array of KYBER_SSBYTES bytes)
+*              - const uint8_t *ct: pointer to input cipher text
+*                (an already allocated array of KYBER_CIPHERTEXTBYTES bytes)
+*              - const uint8_t *sk: pointer to input private key
+*                (an already allocated array of KYBER_SECRETKEYBYTES bytes)
+*
+* Returns 0.
+*
+* On failure, ss will contain a pseudo-random value.
+**************************************************/
+int
+crypto_kem_dec(uint8_t* ss, const uint8_t* ct, const uint8_t* sk)
+{
+    int fail;
+    uint8_t buf[2 * KYBER_SYMBYTES];
+    /* Will contain key, coins */
+    uint8_t kr[2 * KYBER_SYMBYTES];
+    //  uint8_t cmp[KYBER_CIPHERTEXTBYTES+KYBER_SYMBYTES];
+    uint8_t cmp[KYBER_CIPHERTEXTBYTES];
+    const uint8_t* pk = sk + KYBER_INDCPA_SECRETKEYBYTES;
+
+    indcpa_dec(buf, ct, sk);
+
+    /* Multitarget countermeasure for coins + contributory KEM */
+    memcpy(buf + KYBER_SYMBYTES, sk + KYBER_SECRETKEYBYTES - 2 * KYBER_SYMBYTES,
+           KYBER_SYMBYTES);
+    hash_g(kr, buf, 2 * KYBER_SYMBYTES);
+
+    /* coins are in kr+KYBER_SYMBYTES */
+    indcpa_enc(cmp, buf, pk, kr + KYBER_SYMBYTES);
+
+    fail = verify(ct, cmp, KYBER_CIPHERTEXTBYTES);
+
+    /* Compute rejection key */
+    rkprf(ss, sk + KYBER_SECRETKEYBYTES - KYBER_SYMBYTES, ct);
+
+    /* Copy true key to return buffer if fail is false */
+    cmov(ss, kr, KYBER_SYMBYTES, !fail);
+
+    return 0;
+}
diff --git a/nimble/host/src/kyber/kem.h b/nimble/host/src/kyber/kem.h
new file mode 100644
index 00000000..9a2f944a
--- /dev/null
+++ b/nimble/host/src/kyber/kem.h
@@ -0,0 +1,35 @@
+#ifndef KEM_H
+#define KEM_H
+
+#include <stdint.h>
+#include "params.h"
+
+#define CRYPTO_SECRETKEYBYTES  KYBER_SECRETKEYBYTES
+#define CRYPTO_PUBLICKEYBYTES  KYBER_PUBLICKEYBYTES
+#define CRYPTO_CIPHERTEXTBYTES KYBER_CIPHERTEXTBYTES
+#define CRYPTO_BYTES           KYBER_SSBYTES
+
+#if   (KYBER_K == 2)
+#define CRYPTO_ALGNAME "Kyber512"
+#elif (KYBER_K == 3)
+#define CRYPTO_ALGNAME "Kyber768"
+#elif (KYBER_K == 4)
+#define CRYPTO_ALGNAME "Kyber1024"
+#endif
+
+// #define crypto_kem_keypair_derand KYBER_NAMESPACE(keypair_derand)
+int crypto_kem_keypair_derand(uint8_t *pk, uint8_t *sk, const uint8_t *coins);
+
+// #define crypto_kem_keypair KYBER_NAMESPACE(keypair)
+int crypto_kem_keypair(uint8_t *pk, uint8_t *sk);
+
+// #define crypto_kem_enc_derand KYBER_NAMESPACE(enc_derand)
+int crypto_kem_enc_derand(uint8_t *ct, uint8_t *ss, const uint8_t *pk, const uint8_t *coins);
+
+// #define crypto_kem_enc KYBER_NAMESPACE(enc)
+int crypto_kem_enc(uint8_t *ct, uint8_t *ss, const uint8_t *pk);
+
+// #define crypto_kem_dec KYBER_NAMESPACE(dec)
+int crypto_kem_dec(uint8_t *ss, const uint8_t *ct, const uint8_t *sk);
+
+#endif
diff --git a/nimble/host/src/kyber/ntt.c b/nimble/host/src/kyber/ntt.c
new file mode 100644
index 00000000..2f2eb10b
--- /dev/null
+++ b/nimble/host/src/kyber/ntt.c
@@ -0,0 +1,146 @@
+#include <stdint.h>
+#include "params.h"
+#include "ntt.h"
+#include "reduce.h"
+
+/* Code to generate zetas and zetas_inv used in the number-theoretic transform:
+
+#define KYBER_ROOT_OF_UNITY 17
+
+static const uint8_t tree[128] = {
+  0, 64, 32, 96, 16, 80, 48, 112, 8, 72, 40, 104, 24, 88, 56, 120,
+  4, 68, 36, 100, 20, 84, 52, 116, 12, 76, 44, 108, 28, 92, 60, 124,
+  2, 66, 34, 98, 18, 82, 50, 114, 10, 74, 42, 106, 26, 90, 58, 122,
+  6, 70, 38, 102, 22, 86, 54, 118, 14, 78, 46, 110, 30, 94, 62, 126,
+  1, 65, 33, 97, 17, 81, 49, 113, 9, 73, 41, 105, 25, 89, 57, 121,
+  5, 69, 37, 101, 21, 85, 53, 117, 13, 77, 45, 109, 29, 93, 61, 125,
+  3, 67, 35, 99, 19, 83, 51, 115, 11, 75, 43, 107, 27, 91, 59, 123,
+  7, 71, 39, 103, 23, 87, 55, 119, 15, 79, 47, 111, 31, 95, 63, 127
+};
+
+void init_ntt() {
+  unsigned int i;
+  int16_t tmp[128];
+
+  tmp[0] = MONT;
+  for(i=1;i<128;i++)
+    tmp[i] = fqmul(tmp[i-1],MONT*KYBER_ROOT_OF_UNITY % KYBER_Q);
+
+  for(i=0;i<128;i++) {
+    zetas[i] = tmp[tree[i]];
+    if(zetas[i] > KYBER_Q/2)
+      zetas[i] -= KYBER_Q;
+    if(zetas[i] < -KYBER_Q/2)
+      zetas[i] += KYBER_Q;
+  }
+}
+*/
+
+const int16_t zetas[128] = {
+  -1044,  -758,  -359, -1517,  1493,  1422,   287,   202,
+   -171,   622,  1577,   182,   962, -1202, -1474,  1468,
+    573, -1325,   264,   383,  -829,  1458, -1602,  -130,
+   -681,  1017,   732,   608, -1542,   411,  -205, -1571,
+   1223,   652,  -552,  1015, -1293,  1491,  -282, -1544,
+    516,    -8,  -320,  -666, -1618, -1162,   126,  1469,
+   -853,   -90,  -271,   830,   107, -1421,  -247,  -951,
+   -398,   961, -1508,  -725,   448, -1065,   677, -1275,
+  -1103,   430,   555,   843, -1251,   871,  1550,   105,
+    422,   587,   177,  -235,  -291,  -460,  1574,  1653,
+   -246,   778,  1159,  -147,  -777,  1483,  -602,  1119,
+  -1590,   644,  -872,   349,   418,   329,  -156,   -75,
+    817,  1097,   603,   610,  1322, -1285, -1465,   384,
+  -1215,  -136,  1218, -1335,  -874,   220, -1187, -1659,
+  -1185, -1530, -1278,   794, -1510,  -854,  -870,   478,
+   -108,  -308,   996,   991,   958, -1460,  1522,  1628
+};
+
+/*************************************************
+* Name:        fqmul
+*
+* Description: Multiplication followed by Montgomery reduction
+*
+* Arguments:   - int16_t a: first factor
+*              - int16_t b: second factor
+*
+* Returns 16-bit integer congruent to a*b*R^{-1} mod q
+**************************************************/
+static int16_t fqmul(int16_t a, int16_t b) {
+  return montgomery_reduce((int32_t)a*b);
+}
+
+/*************************************************
+* Name:        ntt
+*
+* Description: Inplace number-theoretic transform (NTT) in Rq.
+*              input is in standard order, output is in bitreversed order
+*
+* Arguments:   - int16_t r[256]: pointer to input/output vector of elements of Zq
+**************************************************/
+void ntt(int16_t r[256]) {
+  unsigned int len, start, j, k;
+  int16_t t, zeta;
+
+  k = 1;
+  for(len = 128; len >= 2; len >>= 1) {
+    for(start = 0; start < 256; start = j + len) {
+      zeta = zetas[k++];
+      for(j = start; j < start + len; j++) {
+        t = fqmul(zeta, r[j + len]);
+        r[j + len] = r[j] - t;
+        r[j] = r[j] + t;
+      }
+    }
+  }
+}
+
+/*************************************************
+* Name:        invntt_tomont
+*
+* Description: Inplace inverse number-theoretic transform in Rq and
+*              multiplication by Montgomery factor 2^16.
+*              Input is in bitreversed order, output is in standard order
+*
+* Arguments:   - int16_t r[256]: pointer to input/output vector of elements of Zq
+**************************************************/
+void invntt(int16_t r[256]) {
+  unsigned int start, len, j, k;
+  int16_t t, zeta;
+  const int16_t f = 1441; // mont^2/128
+
+  k = 127;
+  for(len = 2; len <= 128; len <<= 1) {
+    for(start = 0; start < 256; start = j + len) {
+      zeta = zetas[k--];
+      for(j = start; j < start + len; j++) {
+        t = r[j];
+        r[j] = barrett_reduce(t + r[j + len]);
+        r[j + len] = r[j + len] - t;
+        r[j + len] = fqmul(zeta, r[j + len]);
+      }
+    }
+  }
+
+  for(j = 0; j < 256; j++)
+    r[j] = fqmul(r[j], f);
+}
+
+/*************************************************
+* Name:        basemul
+*
+* Description: Multiplication of polynomials in Zq[X]/(X^2-zeta)
+*              used for multiplication of elements in Rq in NTT domain
+*
+* Arguments:   - int16_t r[2]: pointer to the output polynomial
+*              - const int16_t a[2]: pointer to the first factor
+*              - const int16_t b[2]: pointer to the second factor
+*              - int16_t zeta: integer defining the reduction polynomial
+**************************************************/
+void basemul(int16_t r[2], const int16_t a[2], const int16_t b[2], int16_t zeta)
+{
+  r[0]  = fqmul(a[1], b[1]);
+  r[0]  = fqmul(r[0], zeta);
+  r[0] += fqmul(a[0], b[0]);
+  r[1]  = fqmul(a[0], b[1]);
+  r[1] += fqmul(a[1], b[0]);
+}
diff --git a/nimble/host/src/kyber/ntt.h b/nimble/host/src/kyber/ntt.h
new file mode 100644
index 00000000..227ea74f
--- /dev/null
+++ b/nimble/host/src/kyber/ntt.h
@@ -0,0 +1,19 @@
+#ifndef NTT_H
+#define NTT_H
+
+#include <stdint.h>
+#include "params.h"
+
+#define zetas KYBER_NAMESPACE(zetas)
+extern const int16_t zetas[128];
+
+#define ntt KYBER_NAMESPACE(ntt)
+void ntt(int16_t poly[256]);
+
+#define invntt KYBER_NAMESPACE(invntt)
+void invntt(int16_t poly[256]);
+
+#define basemul KYBER_NAMESPACE(basemul)
+void basemul(int16_t r[2], const int16_t a[2], const int16_t b[2], int16_t zeta);
+
+#endif
diff --git a/nimble/host/src/kyber/params.h b/nimble/host/src/kyber/params.h
new file mode 100644
index 00000000..0802c748
--- /dev/null
+++ b/nimble/host/src/kyber/params.h
@@ -0,0 +1,55 @@
+#ifndef PARAMS_H
+#define PARAMS_H
+
+#ifndef KYBER_K
+#define KYBER_K 3	/* Change this for different security strengths */
+#endif
+
+
+/* Don't change parameters below this line */
+#if   (KYBER_K == 2)
+#define KYBER_NAMESPACE(s) pqcrystals_kyber512_ref_##s
+#elif (KYBER_K == 3)
+#define KYBER_NAMESPACE(s) pqcrystals_kyber768_ref_##s
+#elif (KYBER_K == 4)
+#define KYBER_NAMESPACE(s) pqcrystals_kyber1024_ref_##s
+#else
+#error "KYBER_K must be in {2,3,4}"
+#endif
+
+#define KYBER_N 256
+#define KYBER_Q 3329
+
+#define KYBER_SYMBYTES 32   /* size in bytes of hashes, and seeds */
+#define KYBER_SSBYTES  32   /* size in bytes of shared key */
+
+#define KYBER_POLYBYTES		384
+#define KYBER_POLYVECBYTES	(KYBER_K * KYBER_POLYBYTES)
+
+#if KYBER_K == 2
+#define KYBER_ETA1 3
+#define KYBER_POLYCOMPRESSEDBYTES    128
+#define KYBER_POLYVECCOMPRESSEDBYTES (KYBER_K * 320)
+#elif KYBER_K == 3
+#define KYBER_ETA1 2
+#define KYBER_POLYCOMPRESSEDBYTES    128
+#define KYBER_POLYVECCOMPRESSEDBYTES (KYBER_K * 320)
+#elif KYBER_K == 4
+#define KYBER_ETA1 2
+#define KYBER_POLYCOMPRESSEDBYTES    160
+#define KYBER_POLYVECCOMPRESSEDBYTES (KYBER_K * 352)
+#endif
+
+#define KYBER_ETA2 2
+
+#define KYBER_INDCPA_MSGBYTES       (KYBER_SYMBYTES)
+#define KYBER_INDCPA_PUBLICKEYBYTES (KYBER_POLYVECBYTES + KYBER_SYMBYTES)
+#define KYBER_INDCPA_SECRETKEYBYTES (KYBER_POLYVECBYTES)
+#define KYBER_INDCPA_BYTES          (KYBER_POLYVECCOMPRESSEDBYTES + KYBER_POLYCOMPRESSEDBYTES)
+
+#define KYBER_PUBLICKEYBYTES  (KYBER_INDCPA_PUBLICKEYBYTES)
+/* 32 bytes of additional space to save H(pk) */
+#define KYBER_SECRETKEYBYTES  (KYBER_INDCPA_SECRETKEYBYTES + KYBER_INDCPA_PUBLICKEYBYTES + 2*KYBER_SYMBYTES)
+#define KYBER_CIPHERTEXTBYTES (KYBER_INDCPA_BYTES)
+
+#endif
diff --git a/nimble/host/src/kyber/poly.c b/nimble/host/src/kyber/poly.c
new file mode 100644
index 00000000..cbd3abfb
--- /dev/null
+++ b/nimble/host/src/kyber/poly.c
@@ -0,0 +1,360 @@
+#include <stdint.h>
+#include "params.h"
+#include "poly.h"
+#include "ntt.h"
+#include "reduce.h"
+#include "cbd.h"
+#include "symmetric.h"
+#include "verify.h"
+
+/*************************************************
+* Name:        poly_compress
+*
+* Description: Compression and subsequent serialization of a polynomial
+*
+* Arguments:   - uint8_t *r: pointer to output byte array
+*                            (of length KYBER_POLYCOMPRESSEDBYTES)
+*              - const poly *a: pointer to input polynomial
+**************************************************/
+void poly_compress(uint8_t r[KYBER_POLYCOMPRESSEDBYTES], const poly *a)
+{
+  unsigned int i,j;
+  int16_t u;
+  uint32_t d0;
+  uint8_t t[8];
+
+#if (KYBER_POLYCOMPRESSEDBYTES == 128)
+
+  for(i=0;i<KYBER_N/8;i++) {
+    for(j=0;j<8;j++) {
+      // map to positive standard representatives
+      u  = a->coeffs[8*i+j];
+      u += (u >> 15) & KYBER_Q;
+/*    t[j] = ((((uint16_t)u << 4) + KYBER_Q/2)/KYBER_Q) & 15; */
+      d0 = u << 4;
+      d0 += 1665;
+      d0 *= 80635;
+      d0 >>= 28;
+      t[j] = d0 & 0xf;
+    }
+
+    r[0] = t[0] | (t[1] << 4);
+    r[1] = t[2] | (t[3] << 4);
+    r[2] = t[4] | (t[5] << 4);
+    r[3] = t[6] | (t[7] << 4);
+    r += 4;
+  }
+#elif (KYBER_POLYCOMPRESSEDBYTES == 160)
+  for(i=0;i<KYBER_N/8;i++) {
+    for(j=0;j<8;j++) {
+      // map to positive standard representatives
+      u  = a->coeffs[8*i+j];
+      u += (u >> 15) & KYBER_Q;
+/*    t[j] = ((((uint32_t)u << 5) + KYBER_Q/2)/KYBER_Q) & 31; */
+      d0 = u << 5;
+      d0 += 1664;
+      d0 *= 40318;
+      d0 >>= 27;
+      t[j] = d0 & 0x1f;
+    }
+
+    r[0] = (t[0] >> 0) | (t[1] << 5);
+    r[1] = (t[1] >> 3) | (t[2] << 2) | (t[3] << 7);
+    r[2] = (t[3] >> 1) | (t[4] << 4);
+    r[3] = (t[4] >> 4) | (t[5] << 1) | (t[6] << 6);
+    r[4] = (t[6] >> 2) | (t[7] << 3);
+    r += 5;
+  }
+#else
+#error "KYBER_POLYCOMPRESSEDBYTES needs to be in {128, 160}"
+#endif
+}
+
+/*************************************************
+* Name:        poly_decompress
+*
+* Description: De-serialization and subsequent decompression of a polynomial;
+*              approximate inverse of poly_compress
+*
+* Arguments:   - poly *r: pointer to output polynomial
+*              - const uint8_t *a: pointer to input byte array
+*                                  (of length KYBER_POLYCOMPRESSEDBYTES bytes)
+**************************************************/
+void poly_decompress(poly *r, const uint8_t a[KYBER_POLYCOMPRESSEDBYTES])
+{
+  unsigned int i;
+
+#if (KYBER_POLYCOMPRESSEDBYTES == 128)
+  for(i=0;i<KYBER_N/2;i++) {
+    r->coeffs[2*i+0] = (((uint16_t)(a[0] & 15)*KYBER_Q) + 8) >> 4;
+    r->coeffs[2*i+1] = (((uint16_t)(a[0] >> 4)*KYBER_Q) + 8) >> 4;
+    a += 1;
+  }
+#elif (KYBER_POLYCOMPRESSEDBYTES == 160)
+  unsigned int j;
+  uint8_t t[8];
+  for(i=0;i<KYBER_N/8;i++) {
+    t[0] = (a[0] >> 0);
+    t[1] = (a[0] >> 5) | (a[1] << 3);
+    t[2] = (a[1] >> 2);
+    t[3] = (a[1] >> 7) | (a[2] << 1);
+    t[4] = (a[2] >> 4) | (a[3] << 4);
+    t[5] = (a[3] >> 1);
+    t[6] = (a[3] >> 6) | (a[4] << 2);
+    t[7] = (a[4] >> 3);
+    a += 5;
+
+    for(j=0;j<8;j++)
+      r->coeffs[8*i+j] = ((uint32_t)(t[j] & 31)*KYBER_Q + 16) >> 5;
+  }
+#else
+#error "KYBER_POLYCOMPRESSEDBYTES needs to be in {128, 160}"
+#endif
+}
+
+/*************************************************
+* Name:        poly_tobytes
+*
+* Description: Serialization of a polynomial
+*
+* Arguments:   - uint8_t *r: pointer to output byte array
+*                            (needs space for KYBER_POLYBYTES bytes)
+*              - const poly *a: pointer to input polynomial
+**************************************************/
+void poly_tobytes(uint8_t r[KYBER_POLYBYTES], const poly *a)
+{
+  unsigned int i;
+  uint16_t t0, t1;
+
+  for(i=0;i<KYBER_N/2;i++) {
+    // map to positive standard representatives
+    t0  = a->coeffs[2*i];
+    t0 += ((int16_t)t0 >> 15) & KYBER_Q;
+    t1 = a->coeffs[2*i+1];
+    t1 += ((int16_t)t1 >> 15) & KYBER_Q;
+    r[3*i+0] = (t0 >> 0);
+    r[3*i+1] = (t0 >> 8) | (t1 << 4);
+    r[3*i+2] = (t1 >> 4);
+  }
+}
+
+/*************************************************
+* Name:        poly_frombytes
+*
+* Description: De-serialization of a polynomial;
+*              inverse of poly_tobytes
+*
+* Arguments:   - poly *r: pointer to output polynomial
+*              - const uint8_t *a: pointer to input byte array
+*                                  (of KYBER_POLYBYTES bytes)
+**************************************************/
+void poly_frombytes(poly *r, const uint8_t a[KYBER_POLYBYTES])
+{
+  unsigned int i;
+  for(i=0;i<KYBER_N/2;i++) {
+    r->coeffs[2*i]   = ((a[3*i+0] >> 0) | ((uint16_t)a[3*i+1] << 8)) & 0xFFF;
+    r->coeffs[2*i+1] = ((a[3*i+1] >> 4) | ((uint16_t)a[3*i+2] << 4)) & 0xFFF;
+  }
+}
+
+/*************************************************
+* Name:        poly_frommsg
+*
+* Description: Convert 32-byte message to polynomial
+*
+* Arguments:   - poly *r: pointer to output polynomial
+*              - const uint8_t *msg: pointer to input message
+**************************************************/
+void poly_frommsg(poly *r, const uint8_t msg[KYBER_INDCPA_MSGBYTES])
+{
+  unsigned int i,j;
+
+#if (KYBER_INDCPA_MSGBYTES != KYBER_N/8)
+#error "KYBER_INDCPA_MSGBYTES must be equal to KYBER_N/8 bytes!"
+#endif
+
+  for(i=0;i<KYBER_N/8;i++) {
+    for(j=0;j<8;j++) {
+      r->coeffs[8*i+j] = 0;
+      cmov_int16(r->coeffs+8*i+j, ((KYBER_Q+1)/2), (msg[i] >> j)&1);
+    }
+  }
+}
+
+/*************************************************
+* Name:        poly_tomsg
+*
+* Description: Convert polynomial to 32-byte message
+*
+* Arguments:   - uint8_t *msg: pointer to output message
+*              - const poly *a: pointer to input polynomial
+**************************************************/
+void poly_tomsg(uint8_t msg[KYBER_INDCPA_MSGBYTES], const poly *a)
+{
+  unsigned int i,j;
+  uint32_t t;
+
+  for(i=0;i<KYBER_N/8;i++) {
+    msg[i] = 0;
+    for(j=0;j<8;j++) {
+      t  = a->coeffs[8*i+j];
+      // t += ((int16_t)t >> 15) & KYBER_Q;
+      // t  = (((t << 1) + KYBER_Q/2)/KYBER_Q) & 1;
+      t <<= 1;
+      t += 1665;
+      t *= 80635;
+      t >>= 28;
+      t &= 1;
+      msg[i] |= t << j;
+    }
+  }
+}
+
+/*************************************************
+* Name:        poly_getnoise_eta1
+*
+* Description: Sample a polynomial deterministically from a seed and a nonce,
+*              with output polynomial close to centered binomial distribution
+*              with parameter KYBER_ETA1
+*
+* Arguments:   - poly *r: pointer to output polynomial
+*              - const uint8_t *seed: pointer to input seed
+*                                     (of length KYBER_SYMBYTES bytes)
+*              - uint8_t nonce: one-byte input nonce
+**************************************************/
+void poly_getnoise_eta1(poly *r, const uint8_t seed[KYBER_SYMBYTES], uint8_t nonce)
+{
+  uint8_t buf[KYBER_ETA1*KYBER_N/4];
+  prf(buf, sizeof(buf), seed, nonce);
+  poly_cbd_eta1(r, buf);
+}
+
+/*************************************************
+* Name:        poly_getnoise_eta2
+*
+* Description: Sample a polynomial deterministically from a seed and a nonce,
+*              with output polynomial close to centered binomial distribution
+*              with parameter KYBER_ETA2
+*
+* Arguments:   - poly *r: pointer to output polynomial
+*              - const uint8_t *seed: pointer to input seed
+*                                     (of length KYBER_SYMBYTES bytes)
+*              - uint8_t nonce: one-byte input nonce
+**************************************************/
+void poly_getnoise_eta2(poly *r, const uint8_t seed[KYBER_SYMBYTES], uint8_t nonce)
+{
+  uint8_t buf[KYBER_ETA2*KYBER_N/4];
+  prf(buf, sizeof(buf), seed, nonce);
+  poly_cbd_eta2(r, buf);
+}
+
+
+/*************************************************
+* Name:        poly_ntt
+*
+* Description: Computes negacyclic number-theoretic transform (NTT) of
+*              a polynomial in place;
+*              inputs assumed to be in normal order, output in bitreversed order
+*
+* Arguments:   - uint16_t *r: pointer to in/output polynomial
+**************************************************/
+void poly_ntt(poly *r)
+{
+  ntt(r->coeffs);
+  poly_reduce(r);
+}
+
+/*************************************************
+* Name:        poly_invntt_tomont
+*
+* Description: Computes inverse of negacyclic number-theoretic transform (NTT)
+*              of a polynomial in place;
+*              inputs assumed to be in bitreversed order, output in normal order
+*
+* Arguments:   - uint16_t *a: pointer to in/output polynomial
+**************************************************/
+void poly_invntt_tomont(poly *r)
+{
+  invntt(r->coeffs);
+}
+
+/*************************************************
+* Name:        poly_basemul_montgomery
+*
+* Description: Multiplication of two polynomials in NTT domain
+*
+* Arguments:   - poly *r: pointer to output polynomial
+*              - const poly *a: pointer to first input polynomial
+*              - const poly *b: pointer to second input polynomial
+**************************************************/
+void poly_basemul_montgomery(poly *r, const poly *a, const poly *b)
+{
+  unsigned int i;
+  for(i=0;i<KYBER_N/4;i++) {
+    basemul(&r->coeffs[4*i], &a->coeffs[4*i], &b->coeffs[4*i], zetas[64+i]);
+    basemul(&r->coeffs[4*i+2], &a->coeffs[4*i+2], &b->coeffs[4*i+2], -zetas[64+i]);
+  }
+}
+
+/*************************************************
+* Name:        poly_tomont
+*
+* Description: Inplace conversion of all coefficients of a polynomial
+*              from normal domain to Montgomery domain
+*
+* Arguments:   - poly *r: pointer to input/output polynomial
+**************************************************/
+void poly_tomont(poly *r)
+{
+  unsigned int i;
+  const int16_t f = (1ULL << 32) % KYBER_Q;
+  for(i=0;i<KYBER_N;i++)
+    r->coeffs[i] = montgomery_reduce((int32_t)r->coeffs[i]*f);
+}
+
+/*************************************************
+* Name:        poly_reduce
+*
+* Description: Applies Barrett reduction to all coefficients of a polynomial
+*              for details of the Barrett reduction see comments in reduce.c
+*
+* Arguments:   - poly *r: pointer to input/output polynomial
+**************************************************/
+void poly_reduce(poly *r)
+{
+  unsigned int i;
+  for(i=0;i<KYBER_N;i++)
+    r->coeffs[i] = barrett_reduce(r->coeffs[i]);
+}
+
+/*************************************************
+* Name:        poly_add
+*
+* Description: Add two polynomials; no modular reduction is performed
+*
+* Arguments: - poly *r: pointer to output polynomial
+*            - const poly *a: pointer to first input polynomial
+*            - const poly *b: pointer to second input polynomial
+**************************************************/
+void poly_add(poly *r, const poly *a, const poly *b)
+{
+  unsigned int i;
+  for(i=0;i<KYBER_N;i++)
+    r->coeffs[i] = a->coeffs[i] + b->coeffs[i];
+}
+
+/*************************************************
+* Name:        poly_sub
+*
+* Description: Subtract two polynomials; no modular reduction is performed
+*
+* Arguments: - poly *r:       pointer to output polynomial
+*            - const poly *a: pointer to first input polynomial
+*            - const poly *b: pointer to second input polynomial
+**************************************************/
+void poly_sub(poly *r, const poly *a, const poly *b)
+{
+  unsigned int i;
+  for(i=0;i<KYBER_N;i++)
+    r->coeffs[i] = a->coeffs[i] - b->coeffs[i];
+}
diff --git a/nimble/host/src/kyber/poly.h b/nimble/host/src/kyber/poly.h
new file mode 100644
index 00000000..9a99c7cd
--- /dev/null
+++ b/nimble/host/src/kyber/poly.h
@@ -0,0 +1,53 @@
+#ifndef POLY_H
+#define POLY_H
+
+#include <stdint.h>
+#include "params.h"
+
+/*
+ * Elements of R_q = Z_q[X]/(X^n + 1). Represents polynomial
+ * coeffs[0] + X*coeffs[1] + X^2*coeffs[2] + ... + X^{n-1}*coeffs[n-1]
+ */
+typedef struct{
+  int16_t coeffs[KYBER_N];
+} poly;
+
+#define poly_compress KYBER_NAMESPACE(poly_compress)
+void poly_compress(uint8_t r[KYBER_POLYCOMPRESSEDBYTES], const poly *a);
+#define poly_decompress KYBER_NAMESPACE(poly_decompress)
+void poly_decompress(poly *r, const uint8_t a[KYBER_POLYCOMPRESSEDBYTES]);
+
+#define poly_tobytes KYBER_NAMESPACE(poly_tobytes)
+void poly_tobytes(uint8_t r[KYBER_POLYBYTES], const poly *a);
+#define poly_frombytes KYBER_NAMESPACE(poly_frombytes)
+void poly_frombytes(poly *r, const uint8_t a[KYBER_POLYBYTES]);
+
+#define poly_frommsg KYBER_NAMESPACE(poly_frommsg)
+void poly_frommsg(poly *r, const uint8_t msg[KYBER_INDCPA_MSGBYTES]);
+#define poly_tomsg KYBER_NAMESPACE(poly_tomsg)
+void poly_tomsg(uint8_t msg[KYBER_INDCPA_MSGBYTES], const poly *r);
+
+#define poly_getnoise_eta1 KYBER_NAMESPACE(poly_getnoise_eta1)
+void poly_getnoise_eta1(poly *r, const uint8_t seed[KYBER_SYMBYTES], uint8_t nonce);
+
+#define poly_getnoise_eta2 KYBER_NAMESPACE(poly_getnoise_eta2)
+void poly_getnoise_eta2(poly *r, const uint8_t seed[KYBER_SYMBYTES], uint8_t nonce);
+
+#define poly_ntt KYBER_NAMESPACE(poly_ntt)
+void poly_ntt(poly *r);
+#define poly_invntt_tomont KYBER_NAMESPACE(poly_invntt_tomont)
+void poly_invntt_tomont(poly *r);
+#define poly_basemul_montgomery KYBER_NAMESPACE(poly_basemul_montgomery)
+void poly_basemul_montgomery(poly *r, const poly *a, const poly *b);
+#define poly_tomont KYBER_NAMESPACE(poly_tomont)
+void poly_tomont(poly *r);
+
+#define poly_reduce KYBER_NAMESPACE(poly_reduce)
+void poly_reduce(poly *r);
+
+#define poly_add KYBER_NAMESPACE(poly_add)
+void poly_add(poly *r, const poly *a, const poly *b);
+#define poly_sub KYBER_NAMESPACE(poly_sub)
+void poly_sub(poly *r, const poly *a, const poly *b);
+
+#endif
diff --git a/nimble/host/src/kyber/polyvec.c b/nimble/host/src/kyber/polyvec.c
new file mode 100644
index 00000000..669f6a5f
--- /dev/null
+++ b/nimble/host/src/kyber/polyvec.c
@@ -0,0 +1,246 @@
+#include <stdint.h>
+#include "params.h"
+#include "poly.h"
+#include "polyvec.h"
+
+/*************************************************
+* Name:        polyvec_compress
+*
+* Description: Compress and serialize vector of polynomials
+*
+* Arguments:   - uint8_t *r: pointer to output byte array
+*                            (needs space for KYBER_POLYVECCOMPRESSEDBYTES)
+*              - const polyvec *a: pointer to input vector of polynomials
+**************************************************/
+void polyvec_compress(uint8_t r[KYBER_POLYVECCOMPRESSEDBYTES], const polyvec *a)
+{
+  unsigned int i,j,k;
+  uint64_t d0;
+
+#if (KYBER_POLYVECCOMPRESSEDBYTES == (KYBER_K * 352))
+  uint16_t t[8];
+  for(i=0;i<KYBER_K;i++) {
+    for(j=0;j<KYBER_N/8;j++) {
+      for(k=0;k<8;k++) {
+        t[k]  = a->vec[i].coeffs[8*j+k];
+        t[k] += ((int16_t)t[k] >> 15) & KYBER_Q;
+/*      t[k]  = ((((uint32_t)t[k] << 11) + KYBER_Q/2)/KYBER_Q) & 0x7ff; */
+        d0 = t[k];
+        d0 <<= 11;
+        d0 += 1664;
+        d0 *= 645084;
+        d0 >>= 31;
+        t[k] = d0 & 0x7ff;
+      }
+
+      r[ 0] = (t[0] >>  0);
+      r[ 1] = (t[0] >>  8) | (t[1] << 3);
+      r[ 2] = (t[1] >>  5) | (t[2] << 6);
+      r[ 3] = (t[2] >>  2);
+      r[ 4] = (t[2] >> 10) | (t[3] << 1);
+      r[ 5] = (t[3] >>  7) | (t[4] << 4);
+      r[ 6] = (t[4] >>  4) | (t[5] << 7);
+      r[ 7] = (t[5] >>  1);
+      r[ 8] = (t[5] >>  9) | (t[6] << 2);
+      r[ 9] = (t[6] >>  6) | (t[7] << 5);
+      r[10] = (t[7] >>  3);
+      r += 11;
+    }
+  }
+#elif (KYBER_POLYVECCOMPRESSEDBYTES == (KYBER_K * 320))
+  uint16_t t[4];
+  for(i=0;i<KYBER_K;i++) {
+    for(j=0;j<KYBER_N/4;j++) {
+      for(k=0;k<4;k++) {
+        t[k]  = a->vec[i].coeffs[4*j+k];
+        t[k] += ((int16_t)t[k] >> 15) & KYBER_Q;
+/*      t[k]  = ((((uint32_t)t[k] << 10) + KYBER_Q/2)/ KYBER_Q) & 0x3ff; */
+        d0 = t[k];
+        d0 <<= 10;
+        d0 += 1665;
+        d0 *= 1290167;
+        d0 >>= 32;
+        t[k] = d0 & 0x3ff;
+      }
+
+      r[0] = (t[0] >> 0);
+      r[1] = (t[0] >> 8) | (t[1] << 2);
+      r[2] = (t[1] >> 6) | (t[2] << 4);
+      r[3] = (t[2] >> 4) | (t[3] << 6);
+      r[4] = (t[3] >> 2);
+      r += 5;
+    }
+  }
+#else
+#error "KYBER_POLYVECCOMPRESSEDBYTES needs to be in {320*KYBER_K, 352*KYBER_K}"
+#endif
+}
+
+/*************************************************
+* Name:        polyvec_decompress
+*
+* Description: De-serialize and decompress vector of polynomials;
+*              approximate inverse of polyvec_compress
+*
+* Arguments:   - polyvec *r:       pointer to output vector of polynomials
+*              - const uint8_t *a: pointer to input byte array
+*                                  (of length KYBER_POLYVECCOMPRESSEDBYTES)
+**************************************************/
+void polyvec_decompress(polyvec *r, const uint8_t a[KYBER_POLYVECCOMPRESSEDBYTES])
+{
+  unsigned int i,j,k;
+
+#if (KYBER_POLYVECCOMPRESSEDBYTES == (KYBER_K * 352))
+  uint16_t t[8];
+  for(i=0;i<KYBER_K;i++) {
+    for(j=0;j<KYBER_N/8;j++) {
+      t[0] = (a[0] >> 0) | ((uint16_t)a[ 1] << 8);
+      t[1] = (a[1] >> 3) | ((uint16_t)a[ 2] << 5);
+      t[2] = (a[2] >> 6) | ((uint16_t)a[ 3] << 2) | ((uint16_t)a[4] << 10);
+      t[3] = (a[4] >> 1) | ((uint16_t)a[ 5] << 7);
+      t[4] = (a[5] >> 4) | ((uint16_t)a[ 6] << 4);
+      t[5] = (a[6] >> 7) | ((uint16_t)a[ 7] << 1) | ((uint16_t)a[8] << 9);
+      t[6] = (a[8] >> 2) | ((uint16_t)a[ 9] << 6);
+      t[7] = (a[9] >> 5) | ((uint16_t)a[10] << 3);
+      a += 11;
+
+      for(k=0;k<8;k++)
+        r->vec[i].coeffs[8*j+k] = ((uint32_t)(t[k] & 0x7FF)*KYBER_Q + 1024) >> 11;
+    }
+  }
+#elif (KYBER_POLYVECCOMPRESSEDBYTES == (KYBER_K * 320))
+  uint16_t t[4];
+  for(i=0;i<KYBER_K;i++) {
+    for(j=0;j<KYBER_N/4;j++) {
+      t[0] = (a[0] >> 0) | ((uint16_t)a[1] << 8);
+      t[1] = (a[1] >> 2) | ((uint16_t)a[2] << 6);
+      t[2] = (a[2] >> 4) | ((uint16_t)a[3] << 4);
+      t[3] = (a[3] >> 6) | ((uint16_t)a[4] << 2);
+      a += 5;
+
+      for(k=0;k<4;k++)
+        r->vec[i].coeffs[4*j+k] = ((uint32_t)(t[k] & 0x3FF)*KYBER_Q + 512) >> 10;
+    }
+  }
+#else
+#error "KYBER_POLYVECCOMPRESSEDBYTES needs to be in {320*KYBER_K, 352*KYBER_K}"
+#endif
+}
+
+/*************************************************
+* Name:        polyvec_tobytes
+*
+* Description: Serialize vector of polynomials
+*
+* Arguments:   - uint8_t *r: pointer to output byte array
+*                            (needs space for KYBER_POLYVECBYTES)
+*              - const polyvec *a: pointer to input vector of polynomials
+**************************************************/
+void polyvec_tobytes(uint8_t r[KYBER_POLYVECBYTES], const polyvec *a)
+{
+  unsigned int i;
+  for(i=0;i<KYBER_K;i++)
+    poly_tobytes(r+i*KYBER_POLYBYTES, &a->vec[i]);
+}
+
+/*************************************************
+* Name:        polyvec_frombytes
+*
+* Description: De-serialize vector of polynomials;
+*              inverse of polyvec_tobytes
+*
+* Arguments:   - uint8_t *r:       pointer to output byte array
+*              - const polyvec *a: pointer to input vector of polynomials
+*                                  (of length KYBER_POLYVECBYTES)
+**************************************************/
+void polyvec_frombytes(polyvec *r, const uint8_t a[KYBER_POLYVECBYTES])
+{
+  unsigned int i;
+  for(i=0;i<KYBER_K;i++)
+    poly_frombytes(&r->vec[i], a+i*KYBER_POLYBYTES);
+}
+
+/*************************************************
+* Name:        polyvec_ntt
+*
+* Description: Apply forward NTT to all elements of a vector of polynomials
+*
+* Arguments:   - polyvec *r: pointer to in/output vector of polynomials
+**************************************************/
+void polyvec_ntt(polyvec *r)
+{
+  unsigned int i;
+  for(i=0;i<KYBER_K;i++)
+    poly_ntt(&r->vec[i]);
+}
+
+/*************************************************
+* Name:        polyvec_invntt_tomont
+*
+* Description: Apply inverse NTT to all elements of a vector of polynomials
+*              and multiply by Montgomery factor 2^16
+*
+* Arguments:   - polyvec *r: pointer to in/output vector of polynomials
+**************************************************/
+void polyvec_invntt_tomont(polyvec *r)
+{
+  unsigned int i;
+  for(i=0;i<KYBER_K;i++)
+    poly_invntt_tomont(&r->vec[i]);
+}
+
+/*************************************************
+* Name:        polyvec_basemul_acc_montgomery
+*
+* Description: Multiply elements of a and b in NTT domain, accumulate into r,
+*              and multiply by 2^-16.
+*
+* Arguments: - poly *r: pointer to output polynomial
+*            - const polyvec *a: pointer to first input vector of polynomials
+*            - const polyvec *b: pointer to second input vector of polynomials
+**************************************************/
+void polyvec_basemul_acc_montgomery(poly *r, const polyvec *a, const polyvec *b)
+{
+  unsigned int i;
+  poly t;
+
+  poly_basemul_montgomery(r, &a->vec[0], &b->vec[0]);
+  for(i=1;i<KYBER_K;i++) {
+    poly_basemul_montgomery(&t, &a->vec[i], &b->vec[i]);
+    poly_add(r, r, &t);
+  }
+
+  poly_reduce(r);
+}
+
+/*************************************************
+* Name:        polyvec_reduce
+*
+* Description: Applies Barrett reduction to each coefficient
+*              of each element of a vector of polynomials;
+*              for details of the Barrett reduction see comments in reduce.c
+*
+* Arguments:   - polyvec *r: pointer to input/output polynomial
+**************************************************/
+void polyvec_reduce(polyvec *r)
+{
+  unsigned int i;
+  for(i=0;i<KYBER_K;i++)
+    poly_reduce(&r->vec[i]);
+}
+
+/*************************************************
+* Name:        polyvec_add
+*
+* Description: Add vectors of polynomials
+*
+* Arguments: - polyvec *r: pointer to output vector of polynomials
+*            - const polyvec *a: pointer to first input vector of polynomials
+*            - const polyvec *b: pointer to second input vector of polynomials
+**************************************************/
+void polyvec_add(polyvec *r, const polyvec *a, const polyvec *b)
+{
+  unsigned int i;
+  for(i=0;i<KYBER_K;i++)
+    poly_add(&r->vec[i], &a->vec[i], &b->vec[i]);
+}
diff --git a/nimble/host/src/kyber/polyvec.h b/nimble/host/src/kyber/polyvec.h
new file mode 100644
index 00000000..57b60549
--- /dev/null
+++ b/nimble/host/src/kyber/polyvec.h
@@ -0,0 +1,36 @@
+#ifndef POLYVEC_H
+#define POLYVEC_H
+
+#include <stdint.h>
+#include "params.h"
+#include "poly.h"
+
+typedef struct{
+  poly vec[KYBER_K];
+} polyvec;
+
+#define polyvec_compress KYBER_NAMESPACE(polyvec_compress)
+void polyvec_compress(uint8_t r[KYBER_POLYVECCOMPRESSEDBYTES], const polyvec *a);
+#define polyvec_decompress KYBER_NAMESPACE(polyvec_decompress)
+void polyvec_decompress(polyvec *r, const uint8_t a[KYBER_POLYVECCOMPRESSEDBYTES]);
+
+#define polyvec_tobytes KYBER_NAMESPACE(polyvec_tobytes)
+void polyvec_tobytes(uint8_t r[KYBER_POLYVECBYTES], const polyvec *a);
+#define polyvec_frombytes KYBER_NAMESPACE(polyvec_frombytes)
+void polyvec_frombytes(polyvec *r, const uint8_t a[KYBER_POLYVECBYTES]);
+
+#define polyvec_ntt KYBER_NAMESPACE(polyvec_ntt)
+void polyvec_ntt(polyvec *r);
+#define polyvec_invntt_tomont KYBER_NAMESPACE(polyvec_invntt_tomont)
+void polyvec_invntt_tomont(polyvec *r);
+
+#define polyvec_basemul_acc_montgomery KYBER_NAMESPACE(polyvec_basemul_acc_montgomery)
+void polyvec_basemul_acc_montgomery(poly *r, const polyvec *a, const polyvec *b);
+
+#define polyvec_reduce KYBER_NAMESPACE(polyvec_reduce)
+void polyvec_reduce(polyvec *r);
+
+#define polyvec_add KYBER_NAMESPACE(polyvec_add)
+void polyvec_add(polyvec *r, const polyvec *a, const polyvec *b);
+
+#endif
diff --git a/nimble/host/src/kyber/randombytes.c b/nimble/host/src/kyber/randombytes.c
new file mode 100644
index 00000000..06a36108
--- /dev/null
+++ b/nimble/host/src/kyber/randombytes.c
@@ -0,0 +1,119 @@
+#include <stddef.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include "randombytes.h"
+#include "syscfg/syscfg.h"
+#include "host/ble_hs_hci.h"
+#include <assert.h>
+#include "os/os.h"
+
+#if MYNEWT_VAL(TRNG)
+#include "trng/trng.h"
+
+static struct trng_dev *g_trng;
+#endif
+
+// #ifdef _WIN32
+// void randombytes(uint8_t *out, size_t outlen) {
+//   HCRYPTPROV ctx;
+//   size_t len;
+
+//   if(!CryptAcquireContext(&ctx, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))
+//     abort();
+
+//   while(outlen > 0) {
+//     len = (outlen > 1048576) ? 1048576 : outlen;
+//     if(!CryptGenRandom(ctx, len, (BYTE *)out))
+//       abort();
+
+//     out += len;
+//     outlen -= len;
+//   }
+
+//   if(!CryptReleaseContext(ctx, 0))
+//     abort();
+// }
+// #elif defined(__linux__) && defined(SYS_getrandom)
+// void randombytes(uint8_t *out, size_t outlen) {
+//   ssize_t ret;
+
+//   while(outlen > 0) {
+//     ret = syscall(SYS_getrandom, out, outlen, 0);
+//     if(ret == -1 && errno == EINTR)
+//       continue;
+//     else if(ret == -1)
+//       abort();
+
+//     out += ret;
+//     outlen -= ret;
+//   }
+// }
+// #elif defined(__NetBSD__)
+// void randombytes(uint8_t *out, size_t outlen) {
+//   ssize_t ret;
+
+//   while(outlen > 0) {
+//     ret = getrandom(out, outlen, 0);
+//     if(ret == -1 && errno == EINTR)
+//       continue;
+//     else if(ret == -1)
+//       abort();
+
+//     out += ret;
+//     outlen -= ret;
+//   }
+// }
+// #else
+// void randombytes(uint8_t *out, size_t outlen) {
+//   static int fd = -1;
+//   ssize_t ret;
+
+//   while(fd == -1) {
+//     fd = open("/dev/urandom", O_RDONLY);
+//     if(fd == -1 && errno == EINTR)
+//       continue;
+//     else if(fd == -1)
+//       abort();
+//   }
+
+//   while(outlen > 0) {
+//     ret = read(fd, out, outlen);
+//     if(ret == -1 && errno == EINTR)
+//       continue;
+//     else if(ret == -1)
+//       abort();
+
+//     out += ret;
+//     outlen -= ret;
+//   }
+// }
+// #endif
+
+// #if MYNEWT_VAL(SELFTEST)
+// /* Unit tests rely on custom RNG function not being set */
+// #define ble_sm_alg_rand NULL
+// #else
+/* used by uECC to get random data */
+void randombytes(uint8_t *out, size_t outlen)
+{
+#if MYNEWT_VAL_TRNG
+    size_t num;
+
+    if (!g_trng) {
+        g_trng = (struct trng_dev *)os_dev_open("trng", OS_WAIT_FOREVER, NULL);
+        assert(g_trng);
+    }
+
+    while (outlen) {
+        num = trng_read(g_trng, out, outlen);
+        out += num;
+        outlen -= num;
+    }
+#else
+    if (!ble_hs_hci_rand(out, outlen)) {
+        assert(0);
+    }
+#endif
+
+}
+// #endif
diff --git a/nimble/host/src/kyber/randombytes.h b/nimble/host/src/kyber/randombytes.h
new file mode 100644
index 00000000..619b7f9a
--- /dev/null
+++ b/nimble/host/src/kyber/randombytes.h
@@ -0,0 +1,9 @@
+#ifndef RANDOMBYTES_H
+#define RANDOMBYTES_H
+
+#include <stddef.h>
+#include <stdint.h>
+
+void randombytes(uint8_t *out, size_t outlen);
+
+#endif
diff --git a/nimble/host/src/kyber/reduce.c b/nimble/host/src/kyber/reduce.c
new file mode 100644
index 00000000..9d8e7edf
--- /dev/null
+++ b/nimble/host/src/kyber/reduce.c
@@ -0,0 +1,42 @@
+#include <stdint.h>
+#include "params.h"
+#include "reduce.h"
+
+/*************************************************
+* Name:        montgomery_reduce
+*
+* Description: Montgomery reduction; given a 32-bit integer a, computes
+*              16-bit integer congruent to a * R^-1 mod q, where R=2^16
+*
+* Arguments:   - int32_t a: input integer to be reduced;
+*                           has to be in {-q2^15,...,q2^15-1}
+*
+* Returns:     integer in {-q+1,...,q-1} congruent to a * R^-1 modulo q.
+**************************************************/
+int16_t montgomery_reduce(int32_t a)
+{
+  int16_t t;
+
+  t = (int16_t)a*QINV;
+  t = (a - (int32_t)t*KYBER_Q) >> 16;
+  return t;
+}
+
+/*************************************************
+* Name:        barrett_reduce
+*
+* Description: Barrett reduction; given a 16-bit integer a, computes
+*              centered representative congruent to a mod q in {-(q-1)/2,...,(q-1)/2}
+*
+* Arguments:   - int16_t a: input integer to be reduced
+*
+* Returns:     integer in {-(q-1)/2,...,(q-1)/2} congruent to a modulo q.
+**************************************************/
+int16_t barrett_reduce(int16_t a) {
+  int16_t t;
+  const int16_t v = ((1<<26) + KYBER_Q/2)/KYBER_Q;
+
+  t  = ((int32_t)v*a + (1<<25)) >> 26;
+  t *= KYBER_Q;
+  return a - t;
+}
diff --git a/nimble/host/src/kyber/reduce.h b/nimble/host/src/kyber/reduce.h
new file mode 100644
index 00000000..c1bc1e4c
--- /dev/null
+++ b/nimble/host/src/kyber/reduce.h
@@ -0,0 +1,16 @@
+#ifndef REDUCE_H
+#define REDUCE_H
+
+#include <stdint.h>
+#include "params.h"
+
+#define MONT -1044 // 2^16 mod q
+#define QINV -3327 // q^-1 mod 2^16
+
+#define montgomery_reduce KYBER_NAMESPACE(montgomery_reduce)
+int16_t montgomery_reduce(int32_t a);
+
+#define barrett_reduce KYBER_NAMESPACE(barrett_reduce)
+int16_t barrett_reduce(int16_t a);
+
+#endif
diff --git a/nimble/host/src/kyber/symmetric-shake.c b/nimble/host/src/kyber/symmetric-shake.c
new file mode 100644
index 00000000..6a990719
--- /dev/null
+++ b/nimble/host/src/kyber/symmetric-shake.c
@@ -0,0 +1,73 @@
+#include <stddef.h>
+#include <stdint.h>
+#include <string.h>
+#include "params.h"
+#include "symmetric.h"
+#include "fips202.h"
+
+/*************************************************
+* Name:        kyber_shake128_absorb
+*
+* Description: Absorb step of the SHAKE128 specialized for the Kyber context.
+*
+* Arguments:   - keccak_state *state: pointer to (uninitialized) output Keccak state
+*              - const uint8_t *seed: pointer to KYBER_SYMBYTES input to be absorbed into state
+*              - uint8_t i: additional byte of input
+*              - uint8_t j: additional byte of input
+**************************************************/
+void kyber_shake128_absorb(keccak_state *state,
+                           const uint8_t seed[KYBER_SYMBYTES],
+                           uint8_t x,
+                           uint8_t y)
+{
+  uint8_t extseed[KYBER_SYMBYTES+2];
+
+  memcpy(extseed, seed, KYBER_SYMBYTES);
+  extseed[KYBER_SYMBYTES+0] = x;
+  extseed[KYBER_SYMBYTES+1] = y;
+
+  shake128_absorb_once(state, extseed, sizeof(extseed));
+}
+
+/*************************************************
+* Name:        kyber_shake256_prf
+*
+* Description: Usage of SHAKE256 as a PRF, concatenates secret and public input
+*              and then generates outlen bytes of SHAKE256 output
+*
+* Arguments:   - uint8_t *out: pointer to output
+*              - size_t outlen: number of requested output bytes
+*              - const uint8_t *key: pointer to the key (of length KYBER_SYMBYTES)
+*              - uint8_t nonce: single-byte nonce (public PRF input)
+**************************************************/
+void kyber_shake256_prf(uint8_t *out, size_t outlen, const uint8_t key[KYBER_SYMBYTES], uint8_t nonce)
+{
+  uint8_t extkey[KYBER_SYMBYTES+1];
+
+  memcpy(extkey, key, KYBER_SYMBYTES);
+  extkey[KYBER_SYMBYTES] = nonce;
+
+  shake256(out, outlen, extkey, sizeof(extkey));
+}
+
+/*************************************************
+* Name:        kyber_shake256_prf
+*
+* Description: Usage of SHAKE256 as a PRF, concatenates secret and public input
+*              and then generates outlen bytes of SHAKE256 output
+*
+* Arguments:   - uint8_t *out: pointer to output
+*              - size_t outlen: number of requested output bytes
+*              - const uint8_t *key: pointer to the key (of length KYBER_SYMBYTES)
+*              - uint8_t nonce: single-byte nonce (public PRF input)
+**************************************************/
+void kyber_shake256_rkprf(uint8_t out[KYBER_SSBYTES], const uint8_t key[KYBER_SYMBYTES], const uint8_t input[KYBER_CIPHERTEXTBYTES])
+{
+  keccak_state s;
+
+  shake256_init(&s);
+  shake256_absorb(&s, key, KYBER_SYMBYTES);
+  shake256_absorb(&s, input, KYBER_CIPHERTEXTBYTES);
+  shake256_finalize(&s);
+  shake256_squeeze(out, KYBER_SSBYTES, &s);
+}
diff --git a/nimble/host/src/kyber/symmetric.h b/nimble/host/src/kyber/symmetric.h
new file mode 100644
index 00000000..58e6ece8
--- /dev/null
+++ b/nimble/host/src/kyber/symmetric.h
@@ -0,0 +1,33 @@
+#ifndef SYMMETRIC_H
+#define SYMMETRIC_H
+
+#include <stddef.h>
+#include <stdint.h>
+#include "params.h"
+
+#include "fips202.h"
+
+typedef keccak_state xof_state;
+
+#define kyber_shake128_absorb KYBER_NAMESPACE(kyber_shake128_absorb)
+void kyber_shake128_absorb(keccak_state *s,
+                           const uint8_t seed[KYBER_SYMBYTES],
+                           uint8_t x,
+                           uint8_t y);
+
+#define kyber_shake256_prf KYBER_NAMESPACE(kyber_shake256_prf)
+void kyber_shake256_prf(uint8_t *out, size_t outlen, const uint8_t key[KYBER_SYMBYTES], uint8_t nonce);
+
+#define kyber_shake256_rkprf KYBER_NAMESPACE(kyber_shake256_rkprf)
+void kyber_shake256_rkprf(uint8_t out[KYBER_SSBYTES], const uint8_t key[KYBER_SYMBYTES], const uint8_t input[KYBER_CIPHERTEXTBYTES]);
+
+#define XOF_BLOCKBYTES SHAKE128_RATE
+
+#define hash_h(OUT, IN, INBYTES) sha3_256(OUT, IN, INBYTES)
+#define hash_g(OUT, IN, INBYTES) sha3_512(OUT, IN, INBYTES)
+#define xof_absorb(STATE, SEED, X, Y) kyber_shake128_absorb(STATE, SEED, X, Y)
+#define xof_squeezeblocks(OUT, OUTBLOCKS, STATE) shake128_squeezeblocks(OUT, OUTBLOCKS, STATE)
+#define prf(OUT, OUTBYTES, KEY, NONCE) kyber_shake256_prf(OUT, OUTBYTES, KEY, NONCE)
+#define rkprf(OUT, KEY, INPUT) kyber_shake256_rkprf(OUT, KEY, INPUT)
+
+#endif /* SYMMETRIC_H */
diff --git a/nimble/host/src/kyber/verify.c b/nimble/host/src/kyber/verify.c
new file mode 100644
index 00000000..914ccd44
--- /dev/null
+++ b/nimble/host/src/kyber/verify.c
@@ -0,0 +1,75 @@
+#include <stddef.h>
+#include <stdint.h>
+#include "verify.h"
+
+/*************************************************
+* Name:        verify
+*
+* Description: Compare two arrays for equality in constant time.
+*
+* Arguments:   const uint8_t *a: pointer to first byte array
+*              const uint8_t *b: pointer to second byte array
+*              size_t len:       length of the byte arrays
+*
+* Returns 0 if the byte arrays are equal, 1 otherwise
+**************************************************/
+int verify(const uint8_t *a, const uint8_t *b, size_t len)
+{
+  size_t i;
+  uint8_t r = 0;
+
+  for(i=0;i<len;i++)
+    r |= a[i] ^ b[i];
+
+  return (-(uint64_t)r) >> 63;
+}
+
+/*************************************************
+* Name:        cmov
+*
+* Description: Copy len bytes from x to r if b is 1;
+*              don't modify x if b is 0. Requires b to be in {0,1};
+*              assumes two's complement representation of negative integers.
+*              Runs in constant time.
+*
+* Arguments:   uint8_t *r:       pointer to output byte array
+*              const uint8_t *x: pointer to input byte array
+*              size_t len:       Amount of bytes to be copied
+*              uint8_t b:        Condition bit; has to be in {0,1}
+**************************************************/
+void cmov(uint8_t *r, const uint8_t *x, size_t len, uint8_t b)
+{
+  size_t i;
+
+#if defined(__GNUC__) || defined(__clang__)
+  // Prevent the compiler from
+  //    1) inferring that b is 0/1-valued, and
+  //    2) handling the two cases with a branch.
+  // This is not necessary when verify.c and kem.c are separate translation
+  // units, but we expect that downstream consumers will copy this code and/or
+  // change how it is built.
+  __asm__("" : "+r"(b) : /* no inputs */);
+#endif
+
+  b = -b;
+  for(i=0;i<len;i++)
+    r[i] ^= b & (r[i] ^ x[i]);
+}
+
+
+/*************************************************
+* Name:        cmov_int16
+*
+* Description: Copy input v to *r if b is 1, don't modify *r if b is 0. 
+*              Requires b to be in {0,1};
+*              Runs in constant time.
+*
+* Arguments:   int16_t *r:       pointer to output int16_t
+*              int16_t v:        input int16_t 
+*              uint8_t b:        Condition bit; has to be in {0,1}
+**************************************************/
+void cmov_int16(int16_t *r, int16_t v, uint16_t b)
+{
+  b = -b;
+  *r ^= b & ((*r) ^ v);
+}
diff --git a/nimble/host/src/kyber/verify.h b/nimble/host/src/kyber/verify.h
new file mode 100644
index 00000000..09f0ad50
--- /dev/null
+++ b/nimble/host/src/kyber/verify.h
@@ -0,0 +1,17 @@
+#ifndef VERIFY_H
+#define VERIFY_H
+
+#include <stddef.h>
+#include <stdint.h>
+#include "params.h"
+
+#define verify KYBER_NAMESPACE(verify)
+int verify(const uint8_t *a, const uint8_t *b, size_t len);
+
+#define cmov KYBER_NAMESPACE(cmov)
+void cmov(uint8_t *r, const uint8_t *x, size_t len, uint8_t b);
+
+#define cmov_int16 KYBER_NAMESPACE(cmov_int16)
+void cmov_int16(int16_t *r, int16_t v, uint16_t b);
+
+#endif
diff --git a/nimble/host/src/newhope/LICENSE b/nimble/host/src/newhope/LICENSE
new file mode 100644
index 00000000..70fab8a5
--- /dev/null
+++ b/nimble/host/src/newhope/LICENSE
@@ -0,0 +1,2 @@
+Authors: Erdem Alkim, Léo Ducas, Thomas Pöppelmann, Peter Schwabe
+Public domain.
diff --git a/nimble/host/src/newhope/batcher.c b/nimble/host/src/newhope/batcher.c
new file mode 100644
index 00000000..cf690a7d
--- /dev/null
+++ b/nimble/host/src/newhope/batcher.c
@@ -0,0 +1,924 @@
+#include "batcher.h"
+#include "params.h"
+
+
+#define compare_and_swap(x,i,j) \
+  c = _5q - 1 - x[16*i];\
+  c >>= 31;\
+  t = x[16*i] ^ x[16*j];\
+  t &= c;\
+  x[16*i] ^= t;\
+  x[16*j] ^= t;
+
+
+void batcher84(uint16_t *x)
+{    
+  const uint16_t _5q = 5*PARAM_Q;
+  int32_t c;
+  uint16_t t;
+
+  compare_and_swap(x, 0, 1);
+  compare_and_swap(x, 2, 3);
+  compare_and_swap(x, 0, 2);
+  compare_and_swap(x, 1, 3);
+  compare_and_swap(x, 1, 2);
+  compare_and_swap(x, 4, 5);
+  compare_and_swap(x, 6, 7);
+  compare_and_swap(x, 4, 6);
+  compare_and_swap(x, 5, 7);
+  compare_and_swap(x, 5, 6);
+  compare_and_swap(x, 0, 4);
+  compare_and_swap(x, 2, 6);
+  compare_and_swap(x, 2, 4);
+  compare_and_swap(x, 1, 5);
+  compare_and_swap(x, 3, 7);
+  compare_and_swap(x, 3, 5);
+  compare_and_swap(x, 1, 2);
+  compare_and_swap(x, 3, 4);
+  compare_and_swap(x, 5, 6);
+  compare_and_swap(x, 8, 9);
+  compare_and_swap(x, 10, 11);
+  compare_and_swap(x, 8, 10);
+  compare_and_swap(x, 9, 11);
+  compare_and_swap(x, 9, 10);
+  compare_and_swap(x, 12, 13);
+  compare_and_swap(x, 14, 15);
+  compare_and_swap(x, 12, 14);
+  compare_and_swap(x, 13, 15);
+  compare_and_swap(x, 13, 14);
+  compare_and_swap(x, 8, 12);
+  compare_and_swap(x, 10, 14);
+  compare_and_swap(x, 10, 12);
+  compare_and_swap(x, 9, 13);
+  compare_and_swap(x, 11, 15);
+  compare_and_swap(x, 11, 13);
+  compare_and_swap(x, 9, 10);
+  compare_and_swap(x, 11, 12);
+  compare_and_swap(x, 13, 14);
+  compare_and_swap(x, 0, 8);
+  compare_and_swap(x, 4, 12);
+  compare_and_swap(x, 4, 8);
+  compare_and_swap(x, 2, 10);
+  compare_and_swap(x, 6, 14);
+  compare_and_swap(x, 6, 10);
+  compare_and_swap(x, 2, 4);
+  compare_and_swap(x, 6, 8);
+  compare_and_swap(x, 10, 12);
+  compare_and_swap(x, 1, 9);
+  compare_and_swap(x, 5, 13);
+  compare_and_swap(x, 5, 9);
+  compare_and_swap(x, 3, 11);
+  compare_and_swap(x, 7, 15);
+  compare_and_swap(x, 7, 11);
+  compare_and_swap(x, 3, 5);
+  compare_and_swap(x, 7, 9);
+  compare_and_swap(x, 11, 13);
+  compare_and_swap(x, 1, 2);
+  compare_and_swap(x, 3, 4);
+  compare_and_swap(x, 5, 6);
+  compare_and_swap(x, 7, 8);
+  compare_and_swap(x, 9, 10);
+  compare_and_swap(x, 11, 12);
+  compare_and_swap(x, 13, 14);
+  compare_and_swap(x, 16, 17);
+  compare_and_swap(x, 18, 19);
+  compare_and_swap(x, 16, 18);
+  compare_and_swap(x, 17, 19);
+  compare_and_swap(x, 17, 18);
+  compare_and_swap(x, 20, 21);
+  compare_and_swap(x, 22, 23);
+  compare_and_swap(x, 20, 22);
+  compare_and_swap(x, 21, 23);
+  compare_and_swap(x, 21, 22);
+  compare_and_swap(x, 16, 20);
+  compare_and_swap(x, 18, 22);
+  compare_and_swap(x, 18, 20);
+  compare_and_swap(x, 17, 21);
+  compare_and_swap(x, 19, 23);
+  compare_and_swap(x, 19, 21);
+  compare_and_swap(x, 17, 18);
+  compare_and_swap(x, 19, 20);
+  compare_and_swap(x, 21, 22);
+  compare_and_swap(x, 24, 25);
+  compare_and_swap(x, 26, 27);
+  compare_and_swap(x, 24, 26);
+  compare_and_swap(x, 25, 27);
+  compare_and_swap(x, 25, 26);
+  compare_and_swap(x, 28, 29);
+  compare_and_swap(x, 30, 31);
+  compare_and_swap(x, 28, 30);
+  compare_and_swap(x, 29, 31);
+  compare_and_swap(x, 29, 30);
+  compare_and_swap(x, 24, 28);
+  compare_and_swap(x, 26, 30);
+  compare_and_swap(x, 26, 28);
+  compare_and_swap(x, 25, 29);
+  compare_and_swap(x, 27, 31);
+  compare_and_swap(x, 27, 29);
+  compare_and_swap(x, 25, 26);
+  compare_and_swap(x, 27, 28);
+  compare_and_swap(x, 29, 30);
+  compare_and_swap(x, 16, 24);
+  compare_and_swap(x, 20, 28);
+  compare_and_swap(x, 20, 24);
+  compare_and_swap(x, 18, 26);
+  compare_and_swap(x, 22, 30);
+  compare_and_swap(x, 22, 26);
+  compare_and_swap(x, 18, 20);
+  compare_and_swap(x, 22, 24);
+  compare_and_swap(x, 26, 28);
+  compare_and_swap(x, 17, 25);
+  compare_and_swap(x, 21, 29);
+  compare_and_swap(x, 21, 25);
+  compare_and_swap(x, 19, 27);
+  compare_and_swap(x, 23, 31);
+  compare_and_swap(x, 23, 27);
+  compare_and_swap(x, 19, 21);
+  compare_and_swap(x, 23, 25);
+  compare_and_swap(x, 27, 29);
+  compare_and_swap(x, 17, 18);
+  compare_and_swap(x, 19, 20);
+  compare_and_swap(x, 21, 22);
+  compare_and_swap(x, 23, 24);
+  compare_and_swap(x, 25, 26);
+  compare_and_swap(x, 27, 28);
+  compare_and_swap(x, 29, 30);
+  compare_and_swap(x, 0, 16);
+  compare_and_swap(x, 8, 24);
+  compare_and_swap(x, 8, 16);
+  compare_and_swap(x, 4, 20);
+  compare_and_swap(x, 12, 28);
+  compare_and_swap(x, 12, 20);
+  compare_and_swap(x, 4, 8);
+  compare_and_swap(x, 12, 16);
+  compare_and_swap(x, 20, 24);
+  compare_and_swap(x, 2, 18);
+  compare_and_swap(x, 10, 26);
+  compare_and_swap(x, 10, 18);
+  compare_and_swap(x, 6, 22);
+  compare_and_swap(x, 14, 30);
+  compare_and_swap(x, 14, 22);
+  compare_and_swap(x, 6, 10);
+  compare_and_swap(x, 14, 18);
+  compare_and_swap(x, 22, 26);
+  compare_and_swap(x, 2, 4);
+  compare_and_swap(x, 6, 8);
+  compare_and_swap(x, 10, 12);
+  compare_and_swap(x, 14, 16);
+  compare_and_swap(x, 18, 20);
+  compare_and_swap(x, 22, 24);
+  compare_and_swap(x, 26, 28);
+  compare_and_swap(x, 1, 17);
+  compare_and_swap(x, 9, 25);
+  compare_and_swap(x, 9, 17);
+  compare_and_swap(x, 5, 21);
+  compare_and_swap(x, 13, 29);
+  compare_and_swap(x, 13, 21);
+  compare_and_swap(x, 5, 9);
+  compare_and_swap(x, 13, 17);
+  compare_and_swap(x, 21, 25);
+  compare_and_swap(x, 3, 19);
+  compare_and_swap(x, 11, 27);
+  compare_and_swap(x, 11, 19);
+  compare_and_swap(x, 7, 23);
+  compare_and_swap(x, 15, 31);
+  compare_and_swap(x, 15, 23);
+  compare_and_swap(x, 7, 11);
+  compare_and_swap(x, 15, 19);
+  compare_and_swap(x, 23, 27);
+  compare_and_swap(x, 3, 5);
+  compare_and_swap(x, 7, 9);
+  compare_and_swap(x, 11, 13);
+  compare_and_swap(x, 15, 17);
+  compare_and_swap(x, 19, 21);
+  compare_and_swap(x, 23, 25);
+  compare_and_swap(x, 27, 29);
+  compare_and_swap(x, 1, 2);
+  compare_and_swap(x, 3, 4);
+  compare_and_swap(x, 5, 6);
+  compare_and_swap(x, 7, 8);
+  compare_and_swap(x, 9, 10);
+  compare_and_swap(x, 11, 12);
+  compare_and_swap(x, 13, 14);
+  compare_and_swap(x, 15, 16);
+  compare_and_swap(x, 17, 18);
+  compare_and_swap(x, 19, 20);
+  compare_and_swap(x, 21, 22);
+  compare_and_swap(x, 23, 24);
+  compare_and_swap(x, 25, 26);
+  compare_and_swap(x, 27, 28);
+  compare_and_swap(x, 29, 30);
+  compare_and_swap(x, 32, 33);
+  compare_and_swap(x, 34, 35);
+  compare_and_swap(x, 32, 34);
+  compare_and_swap(x, 33, 35);
+  compare_and_swap(x, 33, 34);
+  compare_and_swap(x, 36, 37);
+  compare_and_swap(x, 38, 39);
+  compare_and_swap(x, 36, 38);
+  compare_and_swap(x, 37, 39);
+  compare_and_swap(x, 37, 38);
+  compare_and_swap(x, 32, 36);
+  compare_and_swap(x, 34, 38);
+  compare_and_swap(x, 34, 36);
+  compare_and_swap(x, 33, 37);
+  compare_and_swap(x, 35, 39);
+  compare_and_swap(x, 35, 37);
+  compare_and_swap(x, 33, 34);
+  compare_and_swap(x, 35, 36);
+  compare_and_swap(x, 37, 38);
+  compare_and_swap(x, 40, 41);
+  compare_and_swap(x, 42, 43);
+  compare_and_swap(x, 40, 42);
+  compare_and_swap(x, 41, 43);
+  compare_and_swap(x, 41, 42);
+  compare_and_swap(x, 44, 45);
+  compare_and_swap(x, 46, 47);
+  compare_and_swap(x, 44, 46);
+  compare_and_swap(x, 45, 47);
+  compare_and_swap(x, 45, 46);
+  compare_and_swap(x, 40, 44);
+  compare_and_swap(x, 42, 46);
+  compare_and_swap(x, 42, 44);
+  compare_and_swap(x, 41, 45);
+  compare_and_swap(x, 43, 47);
+  compare_and_swap(x, 43, 45);
+  compare_and_swap(x, 41, 42);
+  compare_and_swap(x, 43, 44);
+  compare_and_swap(x, 45, 46);
+  compare_and_swap(x, 32, 40);
+  compare_and_swap(x, 36, 44);
+  compare_and_swap(x, 36, 40);
+  compare_and_swap(x, 34, 42);
+  compare_and_swap(x, 38, 46);
+  compare_and_swap(x, 38, 42);
+  compare_and_swap(x, 34, 36);
+  compare_and_swap(x, 38, 40);
+  compare_and_swap(x, 42, 44);
+  compare_and_swap(x, 33, 41);
+  compare_and_swap(x, 37, 45);
+  compare_and_swap(x, 37, 41);
+  compare_and_swap(x, 35, 43);
+  compare_and_swap(x, 39, 47);
+  compare_and_swap(x, 39, 43);
+  compare_and_swap(x, 35, 37);
+  compare_and_swap(x, 39, 41);
+  compare_and_swap(x, 43, 45);
+  compare_and_swap(x, 33, 34);
+  compare_and_swap(x, 35, 36);
+  compare_and_swap(x, 37, 38);
+  compare_and_swap(x, 39, 40);
+  compare_and_swap(x, 41, 42);
+  compare_and_swap(x, 43, 44);
+  compare_and_swap(x, 45, 46);
+  compare_and_swap(x, 48, 49);
+  compare_and_swap(x, 50, 51);
+  compare_and_swap(x, 48, 50);
+  compare_and_swap(x, 49, 51);
+  compare_and_swap(x, 49, 50);
+  compare_and_swap(x, 52, 53);
+  compare_and_swap(x, 54, 55);
+  compare_and_swap(x, 52, 54);
+  compare_and_swap(x, 53, 55);
+  compare_and_swap(x, 53, 54);
+  compare_and_swap(x, 48, 52);
+  compare_and_swap(x, 50, 54);
+  compare_and_swap(x, 50, 52);
+  compare_and_swap(x, 49, 53);
+  compare_and_swap(x, 51, 55);
+  compare_and_swap(x, 51, 53);
+  compare_and_swap(x, 49, 50);
+  compare_and_swap(x, 51, 52);
+  compare_and_swap(x, 53, 54);
+  compare_and_swap(x, 56, 57);
+  compare_and_swap(x, 58, 59);
+  compare_and_swap(x, 56, 58);
+  compare_and_swap(x, 57, 59);
+  compare_and_swap(x, 57, 58);
+  compare_and_swap(x, 60, 61);
+  compare_and_swap(x, 62, 63);
+  compare_and_swap(x, 60, 62);
+  compare_and_swap(x, 61, 63);
+  compare_and_swap(x, 61, 62);
+  compare_and_swap(x, 56, 60);
+  compare_and_swap(x, 58, 62);
+  compare_and_swap(x, 58, 60);
+  compare_and_swap(x, 57, 61);
+  compare_and_swap(x, 59, 63);
+  compare_and_swap(x, 59, 61);
+  compare_and_swap(x, 57, 58);
+  compare_and_swap(x, 59, 60);
+  compare_and_swap(x, 61, 62);
+  compare_and_swap(x, 48, 56);
+  compare_and_swap(x, 52, 60);
+  compare_and_swap(x, 52, 56);
+  compare_and_swap(x, 50, 58);
+  compare_and_swap(x, 54, 62);
+  compare_and_swap(x, 54, 58);
+  compare_and_swap(x, 50, 52);
+  compare_and_swap(x, 54, 56);
+  compare_and_swap(x, 58, 60);
+  compare_and_swap(x, 49, 57);
+  compare_and_swap(x, 53, 61);
+  compare_and_swap(x, 53, 57);
+  compare_and_swap(x, 51, 59);
+  compare_and_swap(x, 55, 63);
+  compare_and_swap(x, 55, 59);
+  compare_and_swap(x, 51, 53);
+  compare_and_swap(x, 55, 57);
+  compare_and_swap(x, 59, 61);
+  compare_and_swap(x, 49, 50);
+  compare_and_swap(x, 51, 52);
+  compare_and_swap(x, 53, 54);
+  compare_and_swap(x, 55, 56);
+  compare_and_swap(x, 57, 58);
+  compare_and_swap(x, 59, 60);
+  compare_and_swap(x, 61, 62);
+  compare_and_swap(x, 32, 48);
+  compare_and_swap(x, 40, 56);
+  compare_and_swap(x, 40, 48);
+  compare_and_swap(x, 36, 52);
+  compare_and_swap(x, 44, 60);
+  compare_and_swap(x, 44, 52);
+  compare_and_swap(x, 36, 40);
+  compare_and_swap(x, 44, 48);
+  compare_and_swap(x, 52, 56);
+  compare_and_swap(x, 34, 50);
+  compare_and_swap(x, 42, 58);
+  compare_and_swap(x, 42, 50);
+  compare_and_swap(x, 38, 54);
+  compare_and_swap(x, 46, 62);
+  compare_and_swap(x, 46, 54);
+  compare_and_swap(x, 38, 42);
+  compare_and_swap(x, 46, 50);
+  compare_and_swap(x, 54, 58);
+  compare_and_swap(x, 34, 36);
+  compare_and_swap(x, 38, 40);
+  compare_and_swap(x, 42, 44);
+  compare_and_swap(x, 46, 48);
+  compare_and_swap(x, 50, 52);
+  compare_and_swap(x, 54, 56);
+  compare_and_swap(x, 58, 60);
+  compare_and_swap(x, 33, 49);
+  compare_and_swap(x, 41, 57);
+  compare_and_swap(x, 41, 49);
+  compare_and_swap(x, 37, 53);
+  compare_and_swap(x, 45, 61);
+  compare_and_swap(x, 45, 53);
+  compare_and_swap(x, 37, 41);
+  compare_and_swap(x, 45, 49);
+  compare_and_swap(x, 53, 57);
+  compare_and_swap(x, 35, 51);
+  compare_and_swap(x, 43, 59);
+  compare_and_swap(x, 43, 51);
+  compare_and_swap(x, 39, 55);
+  compare_and_swap(x, 47, 63);
+  compare_and_swap(x, 47, 55);
+  compare_and_swap(x, 39, 43);
+  compare_and_swap(x, 47, 51);
+  compare_and_swap(x, 55, 59);
+  compare_and_swap(x, 35, 37);
+  compare_and_swap(x, 39, 41);
+  compare_and_swap(x, 43, 45);
+  compare_and_swap(x, 47, 49);
+  compare_and_swap(x, 51, 53);
+  compare_and_swap(x, 55, 57);
+  compare_and_swap(x, 59, 61);
+  compare_and_swap(x, 33, 34);
+  compare_and_swap(x, 35, 36);
+  compare_and_swap(x, 37, 38);
+  compare_and_swap(x, 39, 40);
+  compare_and_swap(x, 41, 42);
+  compare_and_swap(x, 43, 44);
+  compare_and_swap(x, 45, 46);
+  compare_and_swap(x, 47, 48);
+  compare_and_swap(x, 49, 50);
+  compare_and_swap(x, 51, 52);
+  compare_and_swap(x, 53, 54);
+  compare_and_swap(x, 55, 56);
+  compare_and_swap(x, 57, 58);
+  compare_and_swap(x, 59, 60);
+  compare_and_swap(x, 61, 62);
+  compare_and_swap(x, 0, 32);
+  compare_and_swap(x, 16, 48);
+  compare_and_swap(x, 16, 32);
+  compare_and_swap(x, 8, 40);
+  compare_and_swap(x, 24, 56);
+  compare_and_swap(x, 24, 40);
+  compare_and_swap(x, 8, 16);
+  compare_and_swap(x, 24, 32);
+  compare_and_swap(x, 40, 48);
+  compare_and_swap(x, 4, 36);
+  compare_and_swap(x, 20, 52);
+  compare_and_swap(x, 20, 36);
+  compare_and_swap(x, 12, 44);
+  compare_and_swap(x, 28, 60);
+  compare_and_swap(x, 28, 44);
+  compare_and_swap(x, 12, 20);
+  compare_and_swap(x, 28, 36);
+  compare_and_swap(x, 44, 52);
+  compare_and_swap(x, 4, 8);
+  compare_and_swap(x, 12, 16);
+  compare_and_swap(x, 20, 24);
+  compare_and_swap(x, 28, 32);
+  compare_and_swap(x, 36, 40);
+  compare_and_swap(x, 44, 48);
+  compare_and_swap(x, 52, 56);
+  compare_and_swap(x, 2, 34);
+  compare_and_swap(x, 18, 50);
+  compare_and_swap(x, 18, 34);
+  compare_and_swap(x, 10, 42);
+  compare_and_swap(x, 26, 58);
+  compare_and_swap(x, 26, 42);
+  compare_and_swap(x, 10, 18);
+  compare_and_swap(x, 26, 34);
+  compare_and_swap(x, 42, 50);
+  compare_and_swap(x, 6, 38);
+  compare_and_swap(x, 22, 54);
+  compare_and_swap(x, 22, 38);
+  compare_and_swap(x, 14, 46);
+  compare_and_swap(x, 30, 62);
+  compare_and_swap(x, 30, 46);
+  compare_and_swap(x, 14, 22);
+  compare_and_swap(x, 30, 38);
+  compare_and_swap(x, 46, 54);
+  compare_and_swap(x, 6, 10);
+  compare_and_swap(x, 14, 18);
+  compare_and_swap(x, 22, 26);
+  compare_and_swap(x, 30, 34);
+  compare_and_swap(x, 38, 42);
+  compare_and_swap(x, 46, 50);
+  compare_and_swap(x, 54, 58);
+  compare_and_swap(x, 2, 4);
+  compare_and_swap(x, 6, 8);
+  compare_and_swap(x, 10, 12);
+  compare_and_swap(x, 14, 16);
+  compare_and_swap(x, 18, 20);
+  compare_and_swap(x, 22, 24);
+  compare_and_swap(x, 26, 28);
+  compare_and_swap(x, 30, 32);
+  compare_and_swap(x, 34, 36);
+  compare_and_swap(x, 38, 40);
+  compare_and_swap(x, 42, 44);
+  compare_and_swap(x, 46, 48);
+  compare_and_swap(x, 50, 52);
+  compare_and_swap(x, 54, 56);
+  compare_and_swap(x, 58, 60);
+  compare_and_swap(x, 1, 33);
+  compare_and_swap(x, 17, 49);
+  compare_and_swap(x, 17, 33);
+  compare_and_swap(x, 9, 41);
+  compare_and_swap(x, 25, 57);
+  compare_and_swap(x, 25, 41);
+  compare_and_swap(x, 9, 17);
+  compare_and_swap(x, 25, 33);
+  compare_and_swap(x, 41, 49);
+  compare_and_swap(x, 5, 37);
+  compare_and_swap(x, 21, 53);
+  compare_and_swap(x, 21, 37);
+  compare_and_swap(x, 13, 45);
+  compare_and_swap(x, 29, 61);
+  compare_and_swap(x, 29, 45);
+  compare_and_swap(x, 13, 21);
+  compare_and_swap(x, 29, 37);
+  compare_and_swap(x, 45, 53);
+  compare_and_swap(x, 5, 9);
+  compare_and_swap(x, 13, 17);
+  compare_and_swap(x, 21, 25);
+  compare_and_swap(x, 29, 33);
+  compare_and_swap(x, 37, 41);
+  compare_and_swap(x, 45, 49);
+  compare_and_swap(x, 53, 57);
+  compare_and_swap(x, 3, 35);
+  compare_and_swap(x, 19, 51);
+  compare_and_swap(x, 19, 35);
+  compare_and_swap(x, 11, 43);
+  compare_and_swap(x, 27, 59);
+  compare_and_swap(x, 27, 43);
+  compare_and_swap(x, 11, 19);
+  compare_and_swap(x, 27, 35);
+  compare_and_swap(x, 43, 51);
+  compare_and_swap(x, 7, 39);
+  compare_and_swap(x, 23, 55);
+  compare_and_swap(x, 23, 39);
+  compare_and_swap(x, 15, 47);
+  compare_and_swap(x, 31, 63);
+  compare_and_swap(x, 31, 47);
+  compare_and_swap(x, 15, 23);
+  compare_and_swap(x, 31, 39);
+  compare_and_swap(x, 47, 55);
+  compare_and_swap(x, 7, 11);
+  compare_and_swap(x, 15, 19);
+  compare_and_swap(x, 23, 27);
+  compare_and_swap(x, 31, 35);
+  compare_and_swap(x, 39, 43);
+  compare_and_swap(x, 47, 51);
+  compare_and_swap(x, 55, 59);
+  compare_and_swap(x, 3, 5);
+  compare_and_swap(x, 7, 9);
+  compare_and_swap(x, 11, 13);
+  compare_and_swap(x, 15, 17);
+  compare_and_swap(x, 19, 21);
+  compare_and_swap(x, 23, 25);
+  compare_and_swap(x, 27, 29);
+  compare_and_swap(x, 31, 33);
+  compare_and_swap(x, 35, 37);
+  compare_and_swap(x, 39, 41);
+  compare_and_swap(x, 43, 45);
+  compare_and_swap(x, 47, 49);
+  compare_and_swap(x, 51, 53);
+  compare_and_swap(x, 55, 57);
+  compare_and_swap(x, 59, 61);
+  compare_and_swap(x, 1, 2);
+  compare_and_swap(x, 3, 4);
+  compare_and_swap(x, 5, 6);
+  compare_and_swap(x, 7, 8);
+  compare_and_swap(x, 9, 10);
+  compare_and_swap(x, 11, 12);
+  compare_and_swap(x, 13, 14);
+  compare_and_swap(x, 15, 16);
+  compare_and_swap(x, 17, 18);
+  compare_and_swap(x, 19, 20);
+  compare_and_swap(x, 21, 22);
+  compare_and_swap(x, 23, 24);
+  compare_and_swap(x, 25, 26);
+  compare_and_swap(x, 27, 28);
+  compare_and_swap(x, 29, 30);
+  compare_and_swap(x, 31, 32);
+  compare_and_swap(x, 33, 34);
+  compare_and_swap(x, 35, 36);
+  compare_and_swap(x, 37, 38);
+  compare_and_swap(x, 39, 40);
+  compare_and_swap(x, 41, 42);
+  compare_and_swap(x, 43, 44);
+  compare_and_swap(x, 45, 46);
+  compare_and_swap(x, 47, 48);
+  compare_and_swap(x, 49, 50);
+  compare_and_swap(x, 51, 52);
+  compare_and_swap(x, 53, 54);
+  compare_and_swap(x, 55, 56);
+  compare_and_swap(x, 57, 58);
+  compare_and_swap(x, 59, 60);
+  compare_and_swap(x, 61, 62);
+  compare_and_swap(x, 64, 65);
+  compare_and_swap(x, 66, 67);
+  compare_and_swap(x, 64, 66);
+  compare_and_swap(x, 65, 67);
+  compare_and_swap(x, 65, 66);
+  compare_and_swap(x, 68, 69);
+  compare_and_swap(x, 70, 71);
+  compare_and_swap(x, 68, 70);
+  compare_and_swap(x, 69, 71);
+  compare_and_swap(x, 69, 70);
+  compare_and_swap(x, 64, 68);
+  compare_and_swap(x, 66, 70);
+  compare_and_swap(x, 66, 68);
+  compare_and_swap(x, 65, 69);
+  compare_and_swap(x, 67, 71);
+  compare_and_swap(x, 67, 69);
+  compare_and_swap(x, 65, 66);
+  compare_and_swap(x, 67, 68);
+  compare_and_swap(x, 69, 70);
+  compare_and_swap(x, 72, 73);
+  compare_and_swap(x, 74, 75);
+  compare_and_swap(x, 72, 74);
+  compare_and_swap(x, 73, 75);
+  compare_and_swap(x, 73, 74);
+  compare_and_swap(x, 76, 77);
+  compare_and_swap(x, 78, 79);
+  compare_and_swap(x, 76, 78);
+  compare_and_swap(x, 77, 79);
+  compare_and_swap(x, 77, 78);
+  compare_and_swap(x, 72, 76);
+  compare_and_swap(x, 74, 78);
+  compare_and_swap(x, 74, 76);
+  compare_and_swap(x, 73, 77);
+  compare_and_swap(x, 75, 79);
+  compare_and_swap(x, 75, 77);
+  compare_and_swap(x, 73, 74);
+  compare_and_swap(x, 75, 76);
+  compare_and_swap(x, 77, 78);
+  compare_and_swap(x, 64, 72);
+  compare_and_swap(x, 68, 76);
+  compare_and_swap(x, 68, 72);
+  compare_and_swap(x, 66, 74);
+  compare_and_swap(x, 70, 78);
+  compare_and_swap(x, 70, 74);
+  compare_and_swap(x, 66, 68);
+  compare_and_swap(x, 70, 72);
+  compare_and_swap(x, 74, 76);
+  compare_and_swap(x, 65, 73);
+  compare_and_swap(x, 69, 77);
+  compare_and_swap(x, 69, 73);
+  compare_and_swap(x, 67, 75);
+  compare_and_swap(x, 71, 79);
+  compare_and_swap(x, 71, 75);
+  compare_and_swap(x, 67, 69);
+  compare_and_swap(x, 71, 73);
+  compare_and_swap(x, 75, 77);
+  compare_and_swap(x, 65, 66);
+  compare_and_swap(x, 67, 68);
+  compare_and_swap(x, 69, 70);
+  compare_and_swap(x, 71, 72);
+  compare_and_swap(x, 73, 74);
+  compare_and_swap(x, 75, 76);
+  compare_and_swap(x, 77, 78);
+  compare_and_swap(x, 80, 81);
+  compare_and_swap(x, 82, 83);
+  compare_and_swap(x, 80, 82);
+  compare_and_swap(x, 81, 83);
+  compare_and_swap(x, 81, 82);
+  compare_and_swap(x, 81, 82);
+  compare_and_swap(x, 81, 82);
+  compare_and_swap(x, 64, 80);
+  compare_and_swap(x, 72, 80);
+  compare_and_swap(x, 68, 72);
+  compare_and_swap(x, 76, 80);
+  compare_and_swap(x, 66, 82);
+  compare_and_swap(x, 74, 82);
+  compare_and_swap(x, 70, 74);
+  compare_and_swap(x, 78, 82);
+  compare_and_swap(x, 66, 68);
+  compare_and_swap(x, 70, 72);
+  compare_and_swap(x, 74, 76);
+  compare_and_swap(x, 78, 80);
+  compare_and_swap(x, 65, 81);
+  compare_and_swap(x, 73, 81);
+  compare_and_swap(x, 69, 73);
+  compare_and_swap(x, 77, 81);
+  compare_and_swap(x, 67, 83);
+  compare_and_swap(x, 75, 83);
+  compare_and_swap(x, 71, 75);
+  compare_and_swap(x, 79, 83);
+  compare_and_swap(x, 67, 69);
+  compare_and_swap(x, 71, 73);
+  compare_and_swap(x, 75, 77);
+  compare_and_swap(x, 79, 81);
+  compare_and_swap(x, 65, 66);
+  compare_and_swap(x, 67, 68);
+  compare_and_swap(x, 69, 70);
+  compare_and_swap(x, 71, 72);
+  compare_and_swap(x, 73, 74);
+  compare_and_swap(x, 75, 76);
+  compare_and_swap(x, 77, 78);
+  compare_and_swap(x, 79, 80);
+  compare_and_swap(x, 81, 82);
+  compare_and_swap(x, 72, 80);
+  compare_and_swap(x, 68, 72);
+  compare_and_swap(x, 76, 80);
+  compare_and_swap(x, 74, 82);
+  compare_and_swap(x, 70, 74);
+  compare_and_swap(x, 78, 82);
+  compare_and_swap(x, 66, 68);
+  compare_and_swap(x, 70, 72);
+  compare_and_swap(x, 74, 76);
+  compare_and_swap(x, 78, 80);
+  compare_and_swap(x, 73, 81);
+  compare_and_swap(x, 69, 73);
+  compare_and_swap(x, 77, 81);
+  compare_and_swap(x, 75, 83);
+  compare_and_swap(x, 71, 75);
+  compare_and_swap(x, 79, 83);
+  compare_and_swap(x, 67, 69);
+  compare_and_swap(x, 71, 73);
+  compare_and_swap(x, 75, 77);
+  compare_and_swap(x, 79, 81);
+  compare_and_swap(x, 65, 66);
+  compare_and_swap(x, 67, 68);
+  compare_and_swap(x, 69, 70);
+  compare_and_swap(x, 71, 72);
+  compare_and_swap(x, 73, 74);
+  compare_and_swap(x, 75, 76);
+  compare_and_swap(x, 77, 78);
+  compare_and_swap(x, 79, 80);
+  compare_and_swap(x, 81, 82);
+  compare_and_swap(x, 0, 64);
+  compare_and_swap(x, 32, 64);
+  compare_and_swap(x, 16, 80);
+  compare_and_swap(x, 48, 80);
+  compare_and_swap(x, 16, 32);
+  compare_and_swap(x, 48, 64);
+  compare_and_swap(x, 8, 72);
+  compare_and_swap(x, 40, 72);
+  compare_and_swap(x, 24, 40);
+  compare_and_swap(x, 56, 72);
+  compare_and_swap(x, 8, 16);
+  compare_and_swap(x, 24, 32);
+  compare_and_swap(x, 40, 48);
+  compare_and_swap(x, 56, 64);
+  compare_and_swap(x, 72, 80);
+  compare_and_swap(x, 4, 68);
+  compare_and_swap(x, 36, 68);
+  compare_and_swap(x, 20, 36);
+  compare_and_swap(x, 52, 68);
+  compare_and_swap(x, 12, 76);
+  compare_and_swap(x, 44, 76);
+  compare_and_swap(x, 28, 44);
+  compare_and_swap(x, 60, 76);
+  compare_and_swap(x, 12, 20);
+  compare_and_swap(x, 28, 36);
+  compare_and_swap(x, 44, 52);
+  compare_and_swap(x, 60, 68);
+  compare_and_swap(x, 4, 8);
+  compare_and_swap(x, 12, 16);
+  compare_and_swap(x, 20, 24);
+  compare_and_swap(x, 28, 32);
+  compare_and_swap(x, 36, 40);
+  compare_and_swap(x, 44, 48);
+  compare_and_swap(x, 52, 56);
+  compare_and_swap(x, 60, 64);
+  compare_and_swap(x, 68, 72);
+  compare_and_swap(x, 76, 80);
+  compare_and_swap(x, 2, 66);
+  compare_and_swap(x, 34, 66);
+  compare_and_swap(x, 18, 82);
+  compare_and_swap(x, 50, 82);
+  compare_and_swap(x, 18, 34);
+  compare_and_swap(x, 50, 66);
+  compare_and_swap(x, 10, 74);
+  compare_and_swap(x, 42, 74);
+  compare_and_swap(x, 26, 42);
+  compare_and_swap(x, 58, 74);
+  compare_and_swap(x, 10, 18);
+  compare_and_swap(x, 26, 34);
+  compare_and_swap(x, 42, 50);
+  compare_and_swap(x, 58, 66);
+  compare_and_swap(x, 74, 82);
+  compare_and_swap(x, 6, 70);
+  compare_and_swap(x, 38, 70);
+  compare_and_swap(x, 22, 38);
+  compare_and_swap(x, 54, 70);
+  compare_and_swap(x, 14, 78);
+  compare_and_swap(x, 46, 78);
+  compare_and_swap(x, 30, 46);
+  compare_and_swap(x, 62, 78);
+  compare_and_swap(x, 14, 22);
+  compare_and_swap(x, 30, 38);
+  compare_and_swap(x, 46, 54);
+  compare_and_swap(x, 62, 70);
+  compare_and_swap(x, 6, 10);
+  compare_and_swap(x, 14, 18);
+  compare_and_swap(x, 22, 26);
+  compare_and_swap(x, 30, 34);
+  compare_and_swap(x, 38, 42);
+  compare_and_swap(x, 46, 50);
+  compare_and_swap(x, 54, 58);
+  compare_and_swap(x, 62, 66);
+  compare_and_swap(x, 70, 74);
+  compare_and_swap(x, 78, 82);
+  compare_and_swap(x, 2, 4);
+  compare_and_swap(x, 6, 8);
+  compare_and_swap(x, 10, 12);
+  compare_and_swap(x, 14, 16);
+  compare_and_swap(x, 18, 20);
+  compare_and_swap(x, 22, 24);
+  compare_and_swap(x, 26, 28);
+  compare_and_swap(x, 30, 32);
+  compare_and_swap(x, 34, 36);
+  compare_and_swap(x, 38, 40);
+  compare_and_swap(x, 42, 44);
+  compare_and_swap(x, 46, 48);
+  compare_and_swap(x, 50, 52);
+  compare_and_swap(x, 54, 56);
+  compare_and_swap(x, 58, 60);
+  compare_and_swap(x, 62, 64);
+  compare_and_swap(x, 66, 68);
+  compare_and_swap(x, 70, 72);
+  compare_and_swap(x, 74, 76);
+  compare_and_swap(x, 78, 80);
+  compare_and_swap(x, 1, 65);
+  compare_and_swap(x, 33, 65);
+  compare_and_swap(x, 17, 81);
+  compare_and_swap(x, 49, 81);
+  compare_and_swap(x, 17, 33);
+  compare_and_swap(x, 49, 65);
+  compare_and_swap(x, 9, 73);
+  compare_and_swap(x, 41, 73);
+  compare_and_swap(x, 25, 41);
+  compare_and_swap(x, 57, 73);
+  compare_and_swap(x, 9, 17);
+  compare_and_swap(x, 25, 33);
+  compare_and_swap(x, 41, 49);
+  compare_and_swap(x, 57, 65);
+  compare_and_swap(x, 73, 81);
+  compare_and_swap(x, 5, 69);
+  compare_and_swap(x, 37, 69);
+  compare_and_swap(x, 21, 37);
+  compare_and_swap(x, 53, 69);
+  compare_and_swap(x, 13, 77);
+  compare_and_swap(x, 45, 77);
+  compare_and_swap(x, 29, 45);
+  compare_and_swap(x, 61, 77);
+  compare_and_swap(x, 13, 21);
+  compare_and_swap(x, 29, 37);
+  compare_and_swap(x, 45, 53);
+  compare_and_swap(x, 61, 69);
+  compare_and_swap(x, 5, 9);
+  compare_and_swap(x, 13, 17);
+  compare_and_swap(x, 21, 25);
+  compare_and_swap(x, 29, 33);
+  compare_and_swap(x, 37, 41);
+  compare_and_swap(x, 45, 49);
+  compare_and_swap(x, 53, 57);
+  compare_and_swap(x, 61, 65);
+  compare_and_swap(x, 69, 73);
+  compare_and_swap(x, 77, 81);
+  compare_and_swap(x, 3, 67);
+  compare_and_swap(x, 35, 67);
+  compare_and_swap(x, 19, 83);
+  compare_and_swap(x, 51, 83);
+  compare_and_swap(x, 19, 35);
+  compare_and_swap(x, 51, 67);
+  compare_and_swap(x, 11, 75);
+  compare_and_swap(x, 43, 75);
+  compare_and_swap(x, 27, 43);
+  compare_and_swap(x, 59, 75);
+  compare_and_swap(x, 11, 19);
+  compare_and_swap(x, 27, 35);
+  compare_and_swap(x, 43, 51);
+  compare_and_swap(x, 59, 67);
+  compare_and_swap(x, 75, 83);
+  compare_and_swap(x, 7, 71);
+  compare_and_swap(x, 39, 71);
+  compare_and_swap(x, 23, 39);
+  compare_and_swap(x, 55, 71);
+  compare_and_swap(x, 15, 79);
+  compare_and_swap(x, 47, 79);
+  compare_and_swap(x, 31, 47);
+  compare_and_swap(x, 63, 79);
+  compare_and_swap(x, 15, 23);
+  compare_and_swap(x, 31, 39);
+  compare_and_swap(x, 47, 55);
+  compare_and_swap(x, 63, 71);
+  compare_and_swap(x, 7, 11);
+  compare_and_swap(x, 15, 19);
+  compare_and_swap(x, 23, 27);
+  compare_and_swap(x, 31, 35);
+  compare_and_swap(x, 39, 43);
+  compare_and_swap(x, 47, 51);
+  compare_and_swap(x, 55, 59);
+  compare_and_swap(x, 63, 67);
+  compare_and_swap(x, 71, 75);
+  compare_and_swap(x, 79, 83);
+  compare_and_swap(x, 3, 5);
+  compare_and_swap(x, 7, 9);
+  compare_and_swap(x, 11, 13);
+  compare_and_swap(x, 15, 17);
+  compare_and_swap(x, 19, 21);
+  compare_and_swap(x, 23, 25);
+  compare_and_swap(x, 27, 29);
+  compare_and_swap(x, 31, 33);
+  compare_and_swap(x, 35, 37);
+  compare_and_swap(x, 39, 41);
+  compare_and_swap(x, 43, 45);
+  compare_and_swap(x, 47, 49);
+  compare_and_swap(x, 51, 53);
+  compare_and_swap(x, 55, 57);
+  compare_and_swap(x, 59, 61);
+  compare_and_swap(x, 63, 65);
+  compare_and_swap(x, 67, 69);
+  compare_and_swap(x, 71, 73);
+  compare_and_swap(x, 75, 77);
+  compare_and_swap(x, 79, 81);
+  compare_and_swap(x, 1, 2);
+  compare_and_swap(x, 3, 4);
+  compare_and_swap(x, 5, 6);
+  compare_and_swap(x, 7, 8);
+  compare_and_swap(x, 9, 10);
+  compare_and_swap(x, 11, 12);
+  compare_and_swap(x, 13, 14);
+  compare_and_swap(x, 15, 16);
+  compare_and_swap(x, 17, 18);
+  compare_and_swap(x, 19, 20);
+  compare_and_swap(x, 21, 22);
+  compare_and_swap(x, 23, 24);
+  compare_and_swap(x, 25, 26);
+  compare_and_swap(x, 27, 28);
+  compare_and_swap(x, 29, 30);
+  compare_and_swap(x, 31, 32);
+  compare_and_swap(x, 33, 34);
+  compare_and_swap(x, 35, 36);
+  compare_and_swap(x, 37, 38);
+  compare_and_swap(x, 39, 40);
+  compare_and_swap(x, 41, 42);
+  compare_and_swap(x, 43, 44);
+  compare_and_swap(x, 45, 46);
+  compare_and_swap(x, 47, 48);
+  compare_and_swap(x, 49, 50);
+  compare_and_swap(x, 51, 52);
+  compare_and_swap(x, 53, 54);
+  compare_and_swap(x, 55, 56);
+  compare_and_swap(x, 57, 58);
+  compare_and_swap(x, 59, 60);
+  compare_and_swap(x, 61, 62);
+  compare_and_swap(x, 63, 64);
+  compare_and_swap(x, 65, 66);
+  compare_and_swap(x, 67, 68);
+  compare_and_swap(x, 69, 70);
+  compare_and_swap(x, 71, 72);
+  compare_and_swap(x, 73, 74);
+  compare_and_swap(x, 75, 76);
+  compare_and_swap(x, 77, 78);
+  compare_and_swap(x, 79, 80);
+  compare_and_swap(x, 81, 82);
+}
diff --git a/nimble/host/src/newhope/batcher.h b/nimble/host/src/newhope/batcher.h
new file mode 100644
index 00000000..8697dc9f
--- /dev/null
+++ b/nimble/host/src/newhope/batcher.h
@@ -0,0 +1,8 @@
+#ifndef BATCHER_H
+#define BATCHER_H
+
+#include <stdint.h>
+
+void batcher84(uint16_t *x);
+
+#endif
diff --git a/nimble/host/src/newhope/cpucycles.c b/nimble/host/src/newhope/cpucycles.c
new file mode 100644
index 00000000..235efc22
--- /dev/null
+++ b/nimble/host/src/newhope/cpucycles.c
@@ -0,0 +1,9 @@
+// #include "cpucycles.h"
+
+// long long cpucycles(void)
+// {
+//   unsigned long long result;
+//   asm volatile(".byte 15;.byte 49;shlq $32,%%rdx;orq %%rdx,%%rax"
+//     : "=a" (result) ::  "%rdx");
+//   return result;
+// }
diff --git a/nimble/host/src/newhope/cpucycles.h b/nimble/host/src/newhope/cpucycles.h
new file mode 100644
index 00000000..7aac8a45
--- /dev/null
+++ b/nimble/host/src/newhope/cpucycles.h
@@ -0,0 +1,6 @@
+#ifndef CPUCYCLES_H
+#define CPUCYCLES_H
+
+long long cpucycles(void);
+
+#endif
diff --git a/nimble/host/src/newhope/crypto_stream_chacha20.c b/nimble/host/src/newhope/crypto_stream_chacha20.c
new file mode 100644
index 00000000..9394d6ba
--- /dev/null
+++ b/nimble/host/src/newhope/crypto_stream_chacha20.c
@@ -0,0 +1,151 @@
+/* Based on the public domain implemntation in
+ * crypto_stream/chacha20/e/ref from http://bench.cr.yp.to/supercop.html
+ * by Daniel J. Bernstein */
+
+#include <stdint.h>
+
+#define ROUNDS 20
+
+typedef uint32_t uint32;
+
+static uint32 load_littleendian(const unsigned char *x)
+{
+  return
+      (uint32) (x[0]) \
+  | (((uint32) (x[1])) << 8) \
+  | (((uint32) (x[2])) << 16) \
+  | (((uint32) (x[3])) << 24);
+}
+
+static void store_littleendian(unsigned char *x,uint32 u)
+{
+  x[0] = u; u >>= 8;
+  x[1] = u; u >>= 8;
+  x[2] = u; u >>= 8;
+  x[3] = u;
+}
+
+#define ROTATE(v,c) ((v << c) | (v >> (32-c)))
+#define XOR(v,w) ((v) ^ (w))
+#define PLUS(v,w) ((v) + (w))
+#define PLUSONE(v) (PLUS((v),1))
+
+#define QUARTERROUND(a,b,c,d) \
+  a = PLUS(a,b); d = ROTATE(XOR(d,a),16); \
+  c = PLUS(c,d); b = ROTATE(XOR(b,c),12); \
+  a = PLUS(a,b); d = ROTATE(XOR(d,a), 8); \
+  c = PLUS(c,d); b = ROTATE(XOR(b,c), 7);
+
+
+static int crypto_core_chacha20(
+        unsigned char *out,
+  const unsigned char *in,
+  const unsigned char *k,
+  const unsigned char *c
+)
+{
+  uint32 x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15;
+  uint32 j0, j1, j2, j3, j4, j5, j6, j7, j8, j9, j10, j11, j12, j13, j14, j15;
+  int i;
+
+  j0  = x0  = load_littleendian(c +  0);
+  j1  = x1  = load_littleendian(c +  4);
+  j2  = x2  = load_littleendian(c +  8);
+  j3  = x3  = load_littleendian(c + 12);
+  j4  = x4  = load_littleendian(k +  0);
+  j5  = x5  = load_littleendian(k +  4);
+  j6  = x6  = load_littleendian(k +  8);
+  j7  = x7  = load_littleendian(k + 12);
+  j8  = x8  = load_littleendian(k + 16);
+  j9  = x9  = load_littleendian(k + 20);
+  j10 = x10 = load_littleendian(k + 24);
+  j11 = x11 = load_littleendian(k + 28);
+  j12 = x12 = load_littleendian(in+  8);
+  j13 = x13 = load_littleendian(in+ 12);
+  j14 = x14 = load_littleendian(in+  0);
+  j15 = x15 = load_littleendian(in+  4);
+
+  for (i = ROUNDS;i > 0;i -= 2) {
+    QUARTERROUND(x0, x4, x8,x12);
+    QUARTERROUND(x1, x5, x9,x13);
+    QUARTERROUND(x2, x6,x10,x14);
+    QUARTERROUND(x3, x7,x11,x15);
+    QUARTERROUND(x0, x5,x10,x15);
+    QUARTERROUND(x1, x6,x11,x12);
+    QUARTERROUND(x2, x7, x8,x13);
+    QUARTERROUND(x3, x4, x9,x14);
+  }
+
+  x0 += j0;
+  x1 += j1;
+  x2 += j2;
+  x3 += j3;
+  x4 += j4;
+  x5 += j5;
+  x6 += j6;
+  x7 += j7;
+  x8 += j8;
+  x9 += j9;
+  x10 += j10;
+  x11 += j11;
+  x12 += j12;
+  x13 += j13;
+  x14 += j14;
+  x15 += j15;
+
+  store_littleendian(out + 0,x0);
+  store_littleendian(out + 4,x1);
+  store_littleendian(out + 8,x2);
+  store_littleendian(out + 12,x3);
+  store_littleendian(out + 16,x4);
+  store_littleendian(out + 20,x5);
+  store_littleendian(out + 24,x6);
+  store_littleendian(out + 28,x7);
+  store_littleendian(out + 32,x8);
+  store_littleendian(out + 36,x9);
+  store_littleendian(out + 40,x10);
+  store_littleendian(out + 44,x11);
+  store_littleendian(out + 48,x12);
+  store_littleendian(out + 52,x13);
+  store_littleendian(out + 56,x14);
+  store_littleendian(out + 60,x15);
+
+  return 0;
+}
+
+static const unsigned char sigma[16] = "expand 32-byte k";
+
+int crypto_stream_chacha20(unsigned char *c,unsigned long long clen, const unsigned char *n, const unsigned char *k)
+{
+  unsigned char in[16];
+  unsigned char block[64];
+  unsigned char kcopy[32];
+  unsigned long long i;
+  unsigned int u;
+
+  if (!clen) return 0;
+
+  for (i = 0;i < 32;++i) kcopy[i] = k[i];
+  for (i = 0;i < 8;++i) in[i] = n[i];
+  for (i = 8;i < 16;++i) in[i] = 0;
+
+  while (clen >= 64) {
+    crypto_core_chacha20(c,in,kcopy,sigma);
+
+    u = 1;
+    for (i = 8;i < 16;++i) {
+      u += (unsigned int) in[i];
+      in[i] = u;
+      u >>= 8;
+    }
+
+    clen -= 64;
+    c += 64;
+  }
+
+  if (clen) {
+    crypto_core_chacha20(block,in,kcopy,sigma);
+    for (i = 0;i < clen;++i) c[i] = block[i];
+  }
+  return 0;
+}
diff --git a/nimble/host/src/newhope/crypto_stream_chacha20.h b/nimble/host/src/newhope/crypto_stream_chacha20.h
new file mode 100644
index 00000000..9782cd1b
--- /dev/null
+++ b/nimble/host/src/newhope/crypto_stream_chacha20.h
@@ -0,0 +1,6 @@
+#ifndef CRYPTO_STREAM_CHACHA20
+#define CRYPTO_STREAM_CHACHA20
+
+int crypto_stream_chacha20(unsigned char *c,unsigned long long clen, const unsigned char *n, const unsigned char *k);
+
+#endif
diff --git a/nimble/host/src/newhope/error_correction.c b/nimble/host/src/newhope/error_correction.c
new file mode 100644
index 00000000..88b9fe56
--- /dev/null
+++ b/nimble/host/src/newhope/error_correction.c
@@ -0,0 +1,126 @@
+#include "error_correction.h"
+
+//See paper for details on the error reconciliation
+
+static int32_t abs(int32_t v)
+{
+  int32_t mask = v >> 31;
+  return (v ^ mask) - mask;
+}
+
+
+static int32_t f(int32_t *v0, int32_t *v1, uint32_t x)
+{
+  int32_t xit, t, r, b;
+  
+  // Next 6 lines compute t = x/PARAM_Q;
+  b = x*2730;
+  t = b >> 25;
+  b = x - t*12289;
+  b = 12288 - b;
+  b >>= 31;
+  t -= b;
+
+  r = t & 1;
+  xit = (t>>1);
+  *v0 = xit+r; // v0 = round(x/(2*PARAM_Q))
+
+  t -= 1;
+  r = t & 1;
+  *v1 = (t>>1)+r;
+
+  return abs(x-((*v0)*2*PARAM_Q));
+}
+
+static int32_t g(int32_t x)
+{
+  int32_t t,c,b;
+
+  // Next 6 lines compute t = x/(4*PARAM_Q);
+  b = x*2730;
+  t = b >> 27;
+  b = x - t*49156;
+  b = 49155 - b;
+  b >>= 31;
+  t -= b;
+
+  c = t & 1;
+  t = (t >> 1) + c; // t = round(x/(8*PARAM_Q))
+
+  t *= 8*PARAM_Q;
+
+  return abs(t - x);
+}
+
+
+static int16_t LDDecode(int32_t xi0, int32_t xi1, int32_t xi2, int32_t xi3)
+{
+  int32_t t;
+
+  t  = g(xi0);
+  t += g(xi1);
+  t += g(xi2);
+  t += g(xi3);
+
+  t -= 8*PARAM_Q;
+  t >>= 31;
+  return t&1;
+}
+
+
+void helprec(poly *c, const poly *v, const unsigned char *seed, unsigned char nonce)
+{
+  int32_t v0[4], v1[4], v_tmp[4], k;
+  unsigned char rbit;
+  unsigned char rand[32];
+  unsigned char n[8];
+  int i;
+
+  for(i=0;i<7;i++)
+    n[i] = 0;
+  n[7] = nonce;
+
+  crypto_stream_chacha20(rand,32,n,seed);
+ 
+  for(i=0; i<256; i++)
+  {
+    rbit = (rand[i>>3] >> (i&7)) & 1;
+
+    k  = f(v0+0, v1+0, 8*v->coeffs[  0+i] + 4*rbit);
+    k += f(v0+1, v1+1, 8*v->coeffs[256+i] + 4*rbit);
+    k += f(v0+2, v1+2, 8*v->coeffs[512+i] + 4*rbit);
+    k += f(v0+3, v1+3, 8*v->coeffs[768+i] + 4*rbit);
+
+    k = (2*PARAM_Q-1-k) >> 31;
+
+    v_tmp[0] = ((~k) & v0[0]) ^ (k & v1[0]);
+    v_tmp[1] = ((~k) & v0[1]) ^ (k & v1[1]);
+    v_tmp[2] = ((~k) & v0[2]) ^ (k & v1[2]);
+    v_tmp[3] = ((~k) & v0[3]) ^ (k & v1[3]);
+
+    c->coeffs[  0+i] = (v_tmp[0] -   v_tmp[3]) & 3;  
+    c->coeffs[256+i] = (v_tmp[1] -   v_tmp[3]) & 3;
+    c->coeffs[512+i] = (v_tmp[2] -   v_tmp[3]) & 3;
+    c->coeffs[768+i] = (   -k    + 2*v_tmp[3]) & 3;
+  }
+}
+
+
+void rec(unsigned char *key, const poly *v, const poly *c)
+{
+  int i;
+  int32_t tmp[4];
+
+  for(i=0;i<32;i++)
+    key[i] = 0;
+
+  for(i=0; i<256; i++)
+  {
+    tmp[0] = 16*PARAM_Q + 8*(int32_t)v->coeffs[  0+i] - PARAM_Q * (2*c->coeffs[  0+i]+c->coeffs[768+i]);
+    tmp[1] = 16*PARAM_Q + 8*(int32_t)v->coeffs[256+i] - PARAM_Q * (2*c->coeffs[256+i]+c->coeffs[768+i]);
+    tmp[2] = 16*PARAM_Q + 8*(int32_t)v->coeffs[512+i] - PARAM_Q * (2*c->coeffs[512+i]+c->coeffs[768+i]);
+    tmp[3] = 16*PARAM_Q + 8*(int32_t)v->coeffs[768+i] - PARAM_Q * (              c->coeffs[768+i]);
+
+    key[i>>3] |= LDDecode(tmp[0], tmp[1], tmp[2], tmp[3]) << (i & 7);
+  }
+}
diff --git a/nimble/host/src/newhope/error_correction.h b/nimble/host/src/newhope/error_correction.h
new file mode 100644
index 00000000..488c1058
--- /dev/null
+++ b/nimble/host/src/newhope/error_correction.h
@@ -0,0 +1,15 @@
+#ifndef ERROR_CORRECTION_H
+#define ERROR_CORRECTION_H
+
+#include "inttypes.h"
+#include "params.h"
+#include "randombytes.h"
+#include "crypto_stream_chacha20.h"
+#include "math.h"
+#include "poly.h"
+#include <stdio.h>
+
+void helprec(poly *c, const poly *v, const unsigned char *seed, unsigned char nonce);
+void rec(unsigned char *key, const poly *v, const poly *c);
+
+#endif
diff --git a/nimble/host/src/newhope/fips202.c b/nimble/host/src/newhope/fips202.c
new file mode 100644
index 00000000..4d3baeff
--- /dev/null
+++ b/nimble/host/src/newhope/fips202.c
@@ -0,0 +1,417 @@
+/* Based on the public domain implementation in
+ * crypto_hash/keccakc512/simple/ from http://bench.cr.yp.to/supercop.html
+ * by Ronny Van Keer 
+ * and the public domain "TweetFips202" implementation
+ * from https://twitter.com/tweetfips202
+ * by Gilles Van Assche, Daniel J. Bernstein, and Peter Schwabe */
+
+#include <stdint.h>
+#include <assert.h>
+#include "fips202.h"
+
+#define NROUNDS 24
+#define ROL(a, offset) ((a << offset) ^ (a >> (64-offset)))
+
+static uint64_t load64(const unsigned char *x)
+{
+  unsigned long long r = 0, i;
+
+  for (i = 0; i < 8; ++i) {
+    r |= (unsigned long long)x[i] << 8 * i;
+  }
+  return r;
+}
+
+static void store64(uint8_t *x, uint64_t u)
+{
+  unsigned int i;
+
+  for(i=0; i<8; ++i) {
+    x[i] = u;
+    u >>= 8;
+  }
+}
+
+static const uint64_t KeccakF_RoundConstants[NROUNDS] = 
+{
+    (uint64_t)0x0000000000000001ULL,
+    (uint64_t)0x0000000000008082ULL,
+    (uint64_t)0x800000000000808aULL,
+    (uint64_t)0x8000000080008000ULL,
+    (uint64_t)0x000000000000808bULL,
+    (uint64_t)0x0000000080000001ULL,
+    (uint64_t)0x8000000080008081ULL,
+    (uint64_t)0x8000000000008009ULL,
+    (uint64_t)0x000000000000008aULL,
+    (uint64_t)0x0000000000000088ULL,
+    (uint64_t)0x0000000080008009ULL,
+    (uint64_t)0x000000008000000aULL,
+    (uint64_t)0x000000008000808bULL,
+    (uint64_t)0x800000000000008bULL,
+    (uint64_t)0x8000000000008089ULL,
+    (uint64_t)0x8000000000008003ULL,
+    (uint64_t)0x8000000000008002ULL,
+    (uint64_t)0x8000000000000080ULL,
+    (uint64_t)0x000000000000800aULL,
+    (uint64_t)0x800000008000000aULL,
+    (uint64_t)0x8000000080008081ULL,
+    (uint64_t)0x8000000000008080ULL,
+    (uint64_t)0x0000000080000001ULL,
+    (uint64_t)0x8000000080008008ULL
+};
+
+void KeccakF1600_StatePermute(uint64_t * state)
+{
+  int round;
+
+        uint64_t Aba, Abe, Abi, Abo, Abu;
+        uint64_t Aga, Age, Agi, Ago, Agu;
+        uint64_t Aka, Ake, Aki, Ako, Aku;
+        uint64_t Ama, Ame, Ami, Amo, Amu;
+        uint64_t Asa, Ase, Asi, Aso, Asu;
+        uint64_t BCa, BCe, BCi, BCo, BCu;
+        uint64_t Da, De, Di, Do, Du;
+        uint64_t Eba, Ebe, Ebi, Ebo, Ebu;
+        uint64_t Ega, Ege, Egi, Ego, Egu;
+        uint64_t Eka, Eke, Eki, Eko, Eku;
+        uint64_t Ema, Eme, Emi, Emo, Emu;
+        uint64_t Esa, Ese, Esi, Eso, Esu;
+
+        //copyFromState(A, state)
+        Aba = state[ 0];
+        Abe = state[ 1];
+        Abi = state[ 2];
+        Abo = state[ 3];
+        Abu = state[ 4];
+        Aga = state[ 5];
+        Age = state[ 6];
+        Agi = state[ 7];
+        Ago = state[ 8];
+        Agu = state[ 9];
+        Aka = state[10];
+        Ake = state[11];
+        Aki = state[12];
+        Ako = state[13];
+        Aku = state[14];
+        Ama = state[15];
+        Ame = state[16];
+        Ami = state[17];
+        Amo = state[18];
+        Amu = state[19];
+        Asa = state[20];
+        Ase = state[21];
+        Asi = state[22];
+        Aso = state[23];
+        Asu = state[24];
+
+        for( round = 0; round < NROUNDS; round += 2 )
+        {
+            //    prepareTheta
+            BCa = Aba^Aga^Aka^Ama^Asa;
+            BCe = Abe^Age^Ake^Ame^Ase;
+            BCi = Abi^Agi^Aki^Ami^Asi;
+            BCo = Abo^Ago^Ako^Amo^Aso;
+            BCu = Abu^Agu^Aku^Amu^Asu;
+
+            //thetaRhoPiChiIotaPrepareTheta(round  , A, E)
+            Da = BCu^ROL(BCe, 1);
+            De = BCa^ROL(BCi, 1);
+            Di = BCe^ROL(BCo, 1);
+            Do = BCi^ROL(BCu, 1);
+            Du = BCo^ROL(BCa, 1);
+
+            Aba ^= Da;
+            BCa = Aba;
+            Age ^= De;
+            BCe = ROL(Age, 44);
+            Aki ^= Di;
+            BCi = ROL(Aki, 43);
+            Amo ^= Do;
+            BCo = ROL(Amo, 21);
+            Asu ^= Du;
+            BCu = ROL(Asu, 14);
+            Eba =   BCa ^((~BCe)&  BCi );
+            Eba ^= (uint64_t)KeccakF_RoundConstants[round];
+            Ebe =   BCe ^((~BCi)&  BCo );
+            Ebi =   BCi ^((~BCo)&  BCu );
+            Ebo =   BCo ^((~BCu)&  BCa );
+            Ebu =   BCu ^((~BCa)&  BCe );
+
+            Abo ^= Do;
+            BCa = ROL(Abo, 28);
+            Agu ^= Du;
+            BCe = ROL(Agu, 20);
+            Aka ^= Da;
+            BCi = ROL(Aka,  3);
+            Ame ^= De;
+            BCo = ROL(Ame, 45);
+            Asi ^= Di;
+            BCu = ROL(Asi, 61);
+            Ega =   BCa ^((~BCe)&  BCi );
+            Ege =   BCe ^((~BCi)&  BCo );
+            Egi =   BCi ^((~BCo)&  BCu );
+            Ego =   BCo ^((~BCu)&  BCa );
+            Egu =   BCu ^((~BCa)&  BCe );
+
+            Abe ^= De;
+            BCa = ROL(Abe,  1);
+            Agi ^= Di;
+            BCe = ROL(Agi,  6);
+            Ako ^= Do;
+            BCi = ROL(Ako, 25);
+            Amu ^= Du;
+            BCo = ROL(Amu,  8);
+            Asa ^= Da;
+            BCu = ROL(Asa, 18);
+            Eka =   BCa ^((~BCe)&  BCi );
+            Eke =   BCe ^((~BCi)&  BCo );
+            Eki =   BCi ^((~BCo)&  BCu );
+            Eko =   BCo ^((~BCu)&  BCa );
+            Eku =   BCu ^((~BCa)&  BCe );
+
+            Abu ^= Du;
+            BCa = ROL(Abu, 27);
+            Aga ^= Da;
+            BCe = ROL(Aga, 36);
+            Ake ^= De;
+            BCi = ROL(Ake, 10);
+            Ami ^= Di;
+            BCo = ROL(Ami, 15);
+            Aso ^= Do;
+            BCu = ROL(Aso, 56);
+            Ema =   BCa ^((~BCe)&  BCi );
+            Eme =   BCe ^((~BCi)&  BCo );
+            Emi =   BCi ^((~BCo)&  BCu );
+            Emo =   BCo ^((~BCu)&  BCa );
+            Emu =   BCu ^((~BCa)&  BCe );
+
+            Abi ^= Di;
+            BCa = ROL(Abi, 62);
+            Ago ^= Do;
+            BCe = ROL(Ago, 55);
+            Aku ^= Du;
+            BCi = ROL(Aku, 39);
+            Ama ^= Da;
+            BCo = ROL(Ama, 41);
+            Ase ^= De;
+            BCu = ROL(Ase,  2);
+            Esa =   BCa ^((~BCe)&  BCi );
+            Ese =   BCe ^((~BCi)&  BCo );
+            Esi =   BCi ^((~BCo)&  BCu );
+            Eso =   BCo ^((~BCu)&  BCa );
+            Esu =   BCu ^((~BCa)&  BCe );
+
+            //    prepareTheta
+            BCa = Eba^Ega^Eka^Ema^Esa;
+            BCe = Ebe^Ege^Eke^Eme^Ese;
+            BCi = Ebi^Egi^Eki^Emi^Esi;
+            BCo = Ebo^Ego^Eko^Emo^Eso;
+            BCu = Ebu^Egu^Eku^Emu^Esu;
+
+            //thetaRhoPiChiIotaPrepareTheta(round+1, E, A)
+            Da = BCu^ROL(BCe, 1);
+            De = BCa^ROL(BCi, 1);
+            Di = BCe^ROL(BCo, 1);
+            Do = BCi^ROL(BCu, 1);
+            Du = BCo^ROL(BCa, 1);
+
+            Eba ^= Da;
+            BCa = Eba;
+            Ege ^= De;
+            BCe = ROL(Ege, 44);
+            Eki ^= Di;
+            BCi = ROL(Eki, 43);
+            Emo ^= Do;
+            BCo = ROL(Emo, 21);
+            Esu ^= Du;
+            BCu = ROL(Esu, 14);
+            Aba =   BCa ^((~BCe)&  BCi );
+            Aba ^= (uint64_t)KeccakF_RoundConstants[round+1];
+            Abe =   BCe ^((~BCi)&  BCo );
+            Abi =   BCi ^((~BCo)&  BCu );
+            Abo =   BCo ^((~BCu)&  BCa );
+            Abu =   BCu ^((~BCa)&  BCe );
+
+            Ebo ^= Do;
+            BCa = ROL(Ebo, 28);
+            Egu ^= Du;
+            BCe = ROL(Egu, 20);
+            Eka ^= Da;
+            BCi = ROL(Eka, 3);
+            Eme ^= De;
+            BCo = ROL(Eme, 45);
+            Esi ^= Di;
+            BCu = ROL(Esi, 61);
+            Aga =   BCa ^((~BCe)&  BCi );
+            Age =   BCe ^((~BCi)&  BCo );
+            Agi =   BCi ^((~BCo)&  BCu );
+            Ago =   BCo ^((~BCu)&  BCa );
+            Agu =   BCu ^((~BCa)&  BCe );
+
+            Ebe ^= De;
+            BCa = ROL(Ebe, 1);
+            Egi ^= Di;
+            BCe = ROL(Egi, 6);
+            Eko ^= Do;
+            BCi = ROL(Eko, 25);
+            Emu ^= Du;
+            BCo = ROL(Emu, 8);
+            Esa ^= Da;
+            BCu = ROL(Esa, 18);
+            Aka =   BCa ^((~BCe)&  BCi );
+            Ake =   BCe ^((~BCi)&  BCo );
+            Aki =   BCi ^((~BCo)&  BCu );
+            Ako =   BCo ^((~BCu)&  BCa );
+            Aku =   BCu ^((~BCa)&  BCe );
+
+            Ebu ^= Du;
+            BCa = ROL(Ebu, 27);
+            Ega ^= Da;
+            BCe = ROL(Ega, 36);
+            Eke ^= De;
+            BCi = ROL(Eke, 10);
+            Emi ^= Di;
+            BCo = ROL(Emi, 15);
+            Eso ^= Do;
+            BCu = ROL(Eso, 56);
+            Ama =   BCa ^((~BCe)&  BCi );
+            Ame =   BCe ^((~BCi)&  BCo );
+            Ami =   BCi ^((~BCo)&  BCu );
+            Amo =   BCo ^((~BCu)&  BCa );
+            Amu =   BCu ^((~BCa)&  BCe );
+
+            Ebi ^= Di;
+            BCa = ROL(Ebi, 62);
+            Ego ^= Do;
+            BCe = ROL(Ego, 55);
+            Eku ^= Du;
+            BCi = ROL(Eku, 39);
+            Ema ^= Da;
+            BCo = ROL(Ema, 41);
+            Ese ^= De;
+            BCu = ROL(Ese, 2);
+            Asa =   BCa ^((~BCe)&  BCi );
+            Ase =   BCe ^((~BCi)&  BCo );
+            Asi =   BCi ^((~BCo)&  BCu );
+            Aso =   BCo ^((~BCu)&  BCa );
+            Asu =   BCu ^((~BCa)&  BCe );
+        }
+
+        //copyToState(state, A)
+        state[ 0] = Aba;
+        state[ 1] = Abe;
+        state[ 2] = Abi;
+        state[ 3] = Abo;
+        state[ 4] = Abu;
+        state[ 5] = Aga;
+        state[ 6] = Age;
+        state[ 7] = Agi;
+        state[ 8] = Ago;
+        state[ 9] = Agu;
+        state[10] = Aka;
+        state[11] = Ake;
+        state[12] = Aki;
+        state[13] = Ako;
+        state[14] = Aku;
+        state[15] = Ama;
+        state[16] = Ame;
+        state[17] = Ami;
+        state[18] = Amo;
+        state[19] = Amu;
+        state[20] = Asa;
+        state[21] = Ase;
+        state[22] = Asi;
+        state[23] = Aso;
+        state[24] = Asu;
+
+        #undef    round
+}
+
+#include <string.h>
+#define MIN(a, b) ((a) < (b) ? (a) : (b))
+
+
+static void keccak_absorb(uint64_t *s,
+                          unsigned int r,
+                          const unsigned char *m, unsigned long long int mlen,
+                          unsigned char p)
+{
+  unsigned long long i;
+  unsigned char t[200];
+
+  for (i = 0; i < 25; ++i)
+    s[i] = 0;
+  
+  while (mlen >= r) 
+  {
+    for (i = 0; i < r / 8; ++i)
+      s[i] ^= load64(m + 8 * i);
+    
+    KeccakF1600_StatePermute(s);
+    mlen -= r;
+    m += r;
+  }
+
+  for (i = 0; i < r; ++i)
+    t[i] = 0;
+  for (i = 0; i < mlen; ++i)
+    t[i] = m[i];
+  t[i] = p;
+  t[r - 1] |= 128;
+  for (i = 0; i < r / 8; ++i)
+    s[i] ^= load64(t + 8 * i);
+}
+
+
+static void keccak_squeezeblocks(unsigned char *h, unsigned long long int nblocks,
+                                 uint64_t *s, 
+                                 unsigned int r)
+{
+  unsigned int i;
+  while(nblocks > 0) 
+  {
+    KeccakF1600_StatePermute(s);
+    for(i=0;i<(r>>3);i++)
+    {
+      store64(h+8*i, s[i]);
+    }
+    h += r;
+    nblocks--;
+  }
+}
+
+
+void shake128_absorb(uint64_t *s, const unsigned char *input, unsigned int inputByteLen)
+{
+  keccak_absorb(s, SHAKE128_RATE, input, inputByteLen, 0x1F);
+}
+
+
+void shake128_squeezeblocks(unsigned char *output, unsigned long long nblocks, uint64_t *s)
+{
+  keccak_squeezeblocks(output, nblocks, s, SHAKE128_RATE);
+}
+
+
+/*
+void shake128(unsigned char *output, unsigned int outputByteLen, const unsigned char *input, unsigned int inputByteLen)
+{
+  uint64_t s[25];
+  assert(!(outputByteLen%SHAKE128_RATE));
+  shake128_absorb(s, input, inputByteLen);
+  shake128_squeezeblocks(output, outputByteLen/SHAKE128_RATE, s);
+}
+*/
+
+
+void sha3256(unsigned char *output, const unsigned char *input, unsigned int inputByteLen)
+{
+  uint64_t s[25];
+  unsigned char t[SHA3_256_RATE];
+  int i;
+
+  keccak_absorb(s, SHA3_256_RATE, input, inputByteLen, 0x06);
+  keccak_squeezeblocks(t, 1, s, SHA3_256_RATE);
+  for(i=0;i<32;i++)
+    output[i] = t[i];
+}
diff --git a/nimble/host/src/newhope/fips202.h b/nimble/host/src/newhope/fips202.h
new file mode 100644
index 00000000..b5644345
--- /dev/null
+++ b/nimble/host/src/newhope/fips202.h
@@ -0,0 +1,12 @@
+#ifndef FIPS202_H
+#define FIPS202_H
+
+#define SHAKE128_RATE 168
+#define SHA3_256_RATE 136
+
+void shake128_absorb(uint64_t *s, const unsigned char *input, unsigned int inputByteLen);
+void shake128_squeezeblocks(unsigned char *output, unsigned long long nblocks, uint64_t *s);
+void shake128(unsigned char *output, unsigned int outputByteLen, const unsigned char *input, unsigned int inputByteLen);
+void sha3256(unsigned char *output, const unsigned char *input, unsigned int inputByteLen);
+
+#endif
diff --git a/nimble/host/src/newhope/newhope.c b/nimble/host/src/newhope/newhope.c
new file mode 100644
index 00000000..304d5781
--- /dev/null
+++ b/nimble/host/src/newhope/newhope.c
@@ -0,0 +1,127 @@
+#include "poly.h"
+#include "randombytes.h"
+#include "error_correction.h"
+#include "fips202.h"
+#include <string.h>
+
+static void encode_a(unsigned char *r, const poly *pk, const unsigned char *seed)
+{
+  int i;
+  poly_tobytes(r, pk);
+  for(i=0;i<NEWHOPE_SEEDBYTES;i++)
+    r[POLY_BYTES+i] = seed[i];
+}
+
+static void decode_a(poly *pk, unsigned char *seed, const unsigned char *r)
+{
+  int i;
+  poly_frombytes(pk, r);
+  for(i=0;i<NEWHOPE_SEEDBYTES;i++)
+    seed[i] = r[POLY_BYTES+i];
+}
+
+static void encode_b(unsigned char *r, const poly *b, const poly *c)
+{
+  int i;
+  poly_tobytes(r,b);
+  for(i=0;i<PARAM_N/4;i++)
+    r[POLY_BYTES+i] = c->coeffs[4*i] | (c->coeffs[4*i+1] << 2) | (c->coeffs[4*i+2] << 4) | (c->coeffs[4*i+3] << 6);
+}
+
+static void decode_b(poly *b, poly *c, const unsigned char *r)
+{
+  int i;
+  poly_frombytes(b, r);
+  for(i=0;i<PARAM_N/4;i++)
+  {
+    c->coeffs[4*i+0] =  r[POLY_BYTES+i]       & 0x03;
+    c->coeffs[4*i+1] = (r[POLY_BYTES+i] >> 2) & 0x03;
+    c->coeffs[4*i+2] = (r[POLY_BYTES+i] >> 4) & 0x03;
+    c->coeffs[4*i+3] = (r[POLY_BYTES+i] >> 6);
+  }
+}
+
+static void gen_a(poly *a, const unsigned char *seed)
+{
+    poly_uniform(a,seed);
+}
+
+
+// API FUNCTIONS 
+
+void newhope_keygen(unsigned char *send, poly *sk, const unsigned char *random_data)
+{
+  poly a, e, r, pk;
+  unsigned char seed[NEWHOPE_SEEDBYTES];
+  unsigned char noiseseed[32];
+
+  sha3256(seed, random_data, NEWHOPE_SEEDBYTES);
+  memcpy(noiseseed, random_data + NEWHOPE_SEEDBYTES, 32);
+
+  gen_a(&a, seed);
+
+  poly_getnoise(sk,noiseseed,0);
+  poly_ntt(sk);
+  
+  poly_getnoise(&e,noiseseed,1);
+  poly_ntt(&e);
+
+  poly_pointwise(&r,sk,&a);
+  poly_add(&pk,&e,&r);
+
+  encode_a(send, &pk, seed);
+}
+
+
+void newhope_sharedb(unsigned char *sharedkey, unsigned char *send, const unsigned char *received, const unsigned char *random_data)
+{
+  poly sp, ep, v, a, pka, c, epp, bp;
+  unsigned char seed[NEWHOPE_SEEDBYTES];
+  unsigned char noiseseed[32];
+  
+  memcpy(noiseseed, random_data, 32);
+
+  decode_a(&pka, seed, received);
+  gen_a(&a, seed);
+
+  poly_getnoise(&sp,noiseseed,0);
+  poly_ntt(&sp);
+  poly_getnoise(&ep,noiseseed,1);
+  poly_ntt(&ep);
+
+  poly_pointwise(&bp, &a, &sp);
+  poly_add(&bp, &bp, &ep);
+  
+  poly_pointwise(&v, &pka, &sp);
+  poly_invntt(&v);
+
+  poly_getnoise(&epp,noiseseed,2);
+  poly_add(&v, &v, &epp);
+
+  helprec(&c, &v, noiseseed, 3);
+
+  encode_b(send, &bp, &c);
+  
+  rec(sharedkey, &v, &c);
+
+#ifndef STATISTICAL_TEST 
+  sha3256(sharedkey, sharedkey, 32);
+#endif
+}
+
+
+void newhope_shareda(unsigned char *sharedkey, const poly *sk, const unsigned char *received)
+{
+  poly v,bp, c;
+
+  decode_b(&bp, &c, received);
+
+  poly_pointwise(&v,sk,&bp);
+  poly_invntt(&v);
+ 
+  rec(sharedkey, &v, &c);
+
+#ifndef STATISTICAL_TEST 
+  sha3256(sharedkey, sharedkey, 32); 
+#endif
+}
diff --git a/nimble/host/src/newhope/newhope.h b/nimble/host/src/newhope/newhope.h
new file mode 100644
index 00000000..88fa67ad
--- /dev/null
+++ b/nimble/host/src/newhope/newhope.h
@@ -0,0 +1,15 @@
+#ifndef NEWHOPE_H
+#define NEWHOPE_H
+
+#include "poly.h"
+#include "randombytes.h"
+#include "crypto_stream_chacha20.h"
+#include "error_correction.h"
+#include <math.h>
+#include <stdio.h>
+
+void newhope_keygen(unsigned char *send, poly *sk, const unsigned char *random_data);
+void newhope_sharedb(unsigned char *sharedkey, unsigned char *send, const unsigned char *received, const unsigned char *random_data);
+void newhope_shareda(unsigned char *sharedkey, const poly *ska, const unsigned char *received);
+
+#endif
diff --git a/nimble/host/src/newhope/ntt.c b/nimble/host/src/newhope/ntt.c
new file mode 100644
index 00000000..963fb027
--- /dev/null
+++ b/nimble/host/src/newhope/ntt.c
@@ -0,0 +1,105 @@
+#include "inttypes.h"
+#include "ntt.h"
+#include "params.h"
+#include "reduce.h"
+
+static uint16_t bitrev_table[PARAM_N] = {
+  0,512,256,768,128,640,384,896,64,576,320,832,192,704,448,960,32,544,288,800,160,672,416,928,96,608,352,864,224,736,480,992,
+  16,528,272,784,144,656,400,912,80,592,336,848,208,720,464,976,48,560,304,816,176,688,432,944,112,624,368,880,240,752,496,1008,
+  8,520,264,776,136,648,392,904,72,584,328,840,200,712,456,968,40,552,296,808,168,680,424,936,104,616,360,872,232,744,488,1000,
+  24,536,280,792,152,664,408,920,88,600,344,856,216,728,472,984,56,568,312,824,184,696,440,952,120,632,376,888,248,760,504,1016,
+  4,516,260,772,132,644,388,900,68,580,324,836,196,708,452,964,36,548,292,804,164,676,420,932,100,612,356,868,228,740,484,996,
+  20,532,276,788,148,660,404,916,84,596,340,852,212,724,468,980,52,564,308,820,180,692,436,948,116,628,372,884,244,756,500,1012,
+  12,524,268,780,140,652,396,908,76,588,332,844,204,716,460,972,44,556,300,812,172,684,428,940,108,620,364,876,236,748,492,1004,
+  28,540,284,796,156,668,412,924,92,604,348,860,220,732,476,988,60,572,316,828,188,700,444,956,124,636,380,892,252,764,508,1020,
+  2,514,258,770,130,642,386,898,66,578,322,834,194,706,450,962,34,546,290,802,162,674,418,930,98,610,354,866,226,738,482,994,
+  18,530,274,786,146,658,402,914,82,594,338,850,210,722,466,978,50,562,306,818,178,690,434,946,114,626,370,882,242,754,498,1010,
+  10,522,266,778,138,650,394,906,74,586,330,842,202,714,458,970,42,554,298,810,170,682,426,938,106,618,362,874,234,746,490,1002,
+  26,538,282,794,154,666,410,922,90,602,346,858,218,730,474,986,58,570,314,826,186,698,442,954,122,634,378,890,250,762,506,1018,
+  6,518,262,774,134,646,390,902,70,582,326,838,198,710,454,966,38,550,294,806,166,678,422,934,102,614,358,870,230,742,486,998,
+  22,534,278,790,150,662,406,918,86,598,342,854,214,726,470,982,54,566,310,822,182,694,438,950,118,630,374,886,246,758,502,1014,
+  14,526,270,782,142,654,398,910,78,590,334,846,206,718,462,974,46,558,302,814,174,686,430,942,110,622,366,878,238,750,494,1006,
+  30,542,286,798,158,670,414,926,94,606,350,862,222,734,478,990,62,574,318,830,190,702,446,958,126,638,382,894,254,766,510,1022,
+  1,513,257,769,129,641,385,897,65,577,321,833,193,705,449,961,33,545,289,801,161,673,417,929,97,609,353,865,225,737,481,993,
+  17,529,273,785,145,657,401,913,81,593,337,849,209,721,465,977,49,561,305,817,177,689,433,945,113,625,369,881,241,753,497,1009,
+  9,521,265,777,137,649,393,905,73,585,329,841,201,713,457,969,41,553,297,809,169,681,425,937,105,617,361,873,233,745,489,1001,
+  25,537,281,793,153,665,409,921,89,601,345,857,217,729,473,985,57,569,313,825,185,697,441,953,121,633,377,889,249,761,505,1017,
+  5,517,261,773,133,645,389,901,69,581,325,837,197,709,453,965,37,549,293,805,165,677,421,933,101,613,357,869,229,741,485,997,
+  21,533,277,789,149,661,405,917,85,597,341,853,213,725,469,981,53,565,309,821,181,693,437,949,117,629,373,885,245,757,501,1013,
+  13,525,269,781,141,653,397,909,77,589,333,845,205,717,461,973,45,557,301,813,173,685,429,941,109,621,365,877,237,749,493,1005,
+  29,541,285,797,157,669,413,925,93,605,349,861,221,733,477,989,61,573,317,829,189,701,445,957,125,637,381,893,253,765,509,1021,
+  3,515,259,771,131,643,387,899,67,579,323,835,195,707,451,963,35,547,291,803,163,675,419,931,99,611,355,867,227,739,483,995,
+  19,531,275,787,147,659,403,915,83,595,339,851,211,723,467,979,51,563,307,819,179,691,435,947,115,627,371,883,243,755,499,1011,
+  11,523,267,779,139,651,395,907,75,587,331,843,203,715,459,971,43,555,299,811,171,683,427,939,107,619,363,875,235,747,491,1003,
+  27,539,283,795,155,667,411,923,91,603,347,859,219,731,475,987,59,571,315,827,187,699,443,955,123,635,379,891,251,763,507,1019,
+  7,519,263,775,135,647,391,903,71,583,327,839,199,711,455,967,39,551,295,807,167,679,423,935,103,615,359,871,231,743,487,999,
+  23,535,279,791,151,663,407,919,87,599,343,855,215,727,471,983,55,567,311,823,183,695,439,951,119,631,375,887,247,759,503,1015,
+  15,527,271,783,143,655,399,911,79,591,335,847,207,719,463,975,47,559,303,815,175,687,431,943,111,623,367,879,239,751,495,1007,
+  31,543,287,799,159,671,415,927,95,607,351,863,223,735,479,991,63,575,319,831,191,703,447,959,127,639,383,895,255,767,511,1023
+};
+
+void bitrev_vector(uint16_t* poly)
+{
+    unsigned int i,r;
+    uint16_t tmp;
+
+    for(i = 0; i < PARAM_N; i++)
+    {
+        r = bitrev_table[i];
+        if (i < r)
+        {
+          tmp = poly[i];
+          poly[i] = poly[r];
+          poly[r] = tmp;
+        }
+    }
+}
+ 
+void mul_coefficients(uint16_t* poly, const uint16_t* factors)
+{
+    unsigned int i;
+
+    for(i = 0; i < PARAM_N; i++)
+      poly[i] = montgomery_reduce((poly[i] * factors[i]));
+}
+
+
+
+/* GS_bo_to_no; omegas need to be in Montgomery domain */
+void ntt(uint16_t * a, const uint16_t* omega)
+{
+  int i, start, j, jTwiddle, distance;
+  uint16_t temp, W;
+
+
+  for(i=0;i<10;i+=2)
+  {
+    // Even level
+    distance = (1<<i);
+    for(start = 0; start < distance;start++)
+    {
+      jTwiddle = 0;
+      for(j=start;j<PARAM_N-1;j+=2*distance)
+      {
+        W = omega[jTwiddle++];
+        temp = a[j];
+        a[j] = (temp + a[j + distance]); // Omit reduction (be lazy)
+        a[j + distance] = montgomery_reduce((W * ((uint32_t)temp + 3*PARAM_Q - a[j + distance])));
+      }
+    }
+
+    // Odd level
+    distance <<= 1;
+    for(start = 0; start < distance;start++)
+    {
+      jTwiddle = 0;
+      for(j=start;j<PARAM_N-1;j+=2*distance)
+      {
+        W = omega[jTwiddle++];
+        temp = a[j];
+        a[j] = barrett_reduce((temp + a[j + distance]));
+        a[j + distance] = montgomery_reduce((W * ((uint32_t)temp + 3*PARAM_Q - a[j + distance])));
+      }
+    }
+  }
+}
diff --git a/nimble/host/src/newhope/ntt.h b/nimble/host/src/newhope/ntt.h
new file mode 100644
index 00000000..d6b4e8a0
--- /dev/null
+++ b/nimble/host/src/newhope/ntt.h
@@ -0,0 +1,16 @@
+#ifndef NTT_H
+#define NTT_H
+
+#include "inttypes.h"
+
+extern uint16_t omegas_montgomery[];
+extern uint16_t omegas_inv_montgomery[];
+
+extern uint16_t psis_bitrev_montgomery[];
+extern uint16_t psis_inv_montgomery[];
+
+void bitrev_vector(uint16_t* poly);
+void mul_coefficients(uint16_t* poly, const uint16_t* factors);
+void ntt(uint16_t* poly, const uint16_t* omegas);
+
+#endif
diff --git a/nimble/host/src/newhope/params.h b/nimble/host/src/newhope/params.h
new file mode 100644
index 00000000..b98bf2b5
--- /dev/null
+++ b/nimble/host/src/newhope/params.h
@@ -0,0 +1,16 @@
+#ifndef PARAMS_H
+#define PARAMS_H
+
+#define PARAM_N 1024
+
+#define PARAM_K 16 /* used in sampler */
+#define PARAM_Q 12289 
+
+#define POLY_BYTES 1792
+#define NEWHOPE_SEEDBYTES 32
+#define NEWHOPE_RECBYTES 256
+
+#define NEWHOPE_SENDABYTES (POLY_BYTES + NEWHOPE_SEEDBYTES)
+#define NEWHOPE_SENDBBYTES (POLY_BYTES + NEWHOPE_RECBYTES)
+
+#endif
diff --git a/nimble/host/src/newhope/poly.c b/nimble/host/src/newhope/poly.c
new file mode 100644
index 00000000..9dd7d9ae
--- /dev/null
+++ b/nimble/host/src/newhope/poly.c
@@ -0,0 +1,160 @@
+#include "poly.h"
+#include "ntt.h"
+#include "randombytes.h"
+#include "reduce.h"
+#include "fips202.h"
+#include "crypto_stream_chacha20.h"
+#include "batcher.h"
+
+void poly_frombytes(poly *r, const unsigned char *a)
+{
+  int i;
+  for(i=0;i<PARAM_N/4;i++)
+  {
+    r->coeffs[4*i+0] =                               a[7*i+0]        | (((uint16_t)a[7*i+1] & 0x3f) << 8);
+    r->coeffs[4*i+1] = (a[7*i+1] >> 6) | (((uint16_t)a[7*i+2]) << 2) | (((uint16_t)a[7*i+3] & 0x0f) << 10);
+    r->coeffs[4*i+2] = (a[7*i+3] >> 4) | (((uint16_t)a[7*i+4]) << 4) | (((uint16_t)a[7*i+5] & 0x03) << 12);
+    r->coeffs[4*i+3] = (a[7*i+5] >> 2) | (((uint16_t)a[7*i+6]) << 6); 
+  }
+}
+
+void poly_tobytes(unsigned char *r, const poly *p)
+{
+  int i;
+  uint16_t t0,t1,t2,t3,m;
+  int16_t c;
+  for(i=0;i<PARAM_N/4;i++)
+  {
+    t0 = barrett_reduce(p->coeffs[4*i+0]); //Make sure that coefficients have only 14 bits
+    t1 = barrett_reduce(p->coeffs[4*i+1]);
+    t2 = barrett_reduce(p->coeffs[4*i+2]);
+    t3 = barrett_reduce(p->coeffs[4*i+3]);
+
+    m = t0 - PARAM_Q;
+    c = m;
+    c >>= 15;
+    t0 = m ^ ((t0^m)&c); // <Make sure that coefficients are in [0,q]
+
+    m = t1 - PARAM_Q;
+    c = m;
+    c >>= 15;
+    t1 = m ^ ((t1^m)&c); // <Make sure that coefficients are in [0,q]
+
+    m = t2 - PARAM_Q;
+    c = m;
+    c >>= 15;
+    t2 = m ^ ((t2^m)&c); // <Make sure that coefficients are in [0,q]
+
+    m = t3 - PARAM_Q;
+    c = m;
+    c >>= 15;
+    t3 = m ^ ((t3^m)&c); // <Make sure that coefficients are in [0,q]
+
+    r[7*i+0] =  t0 & 0xff;
+    r[7*i+1] = (t0 >> 8) | (t1 << 6);
+    r[7*i+2] = (t1 >> 2);
+    r[7*i+3] = (t1 >> 10) | (t2 << 4);
+    r[7*i+4] = (t2 >> 4);
+    r[7*i+5] = (t2 >> 12) | (t3 << 2);
+    r[7*i+6] = (t3 >> 6);
+  }
+}
+
+static int discardtopoly(poly* a, unsigned char *buf, unsigned int nblocks)
+{
+  int r=0;
+  unsigned int i;
+  uint16_t x[SHAKE128_RATE*nblocks/2];
+
+  for(i=0;i<SHAKE128_RATE*nblocks/2;i++)
+    x[i] = buf[2*i] | (uint16_t)buf[2*i+1] << 8; //handle endianess
+
+  for(i=0;i<16;i++)
+  batcher84(x+i);
+
+  // Check whether we're safe:
+  for(i=1008;i<1024;i++)
+    r |= 61444 - x[i];
+  if(r >>= 31) return -1;
+
+  // If we are, copy coefficients to polynomial:
+  for(i=0;i<PARAM_N;i++)
+    a->coeffs[i] = x[i];
+  
+  return 0;
+}
+
+void poly_uniform(poly *a, const unsigned char *seed)
+{
+  uint64_t state[25];
+  unsigned int nblocks=16;
+  uint8_t buf[SHAKE128_RATE*nblocks];
+
+  shake128_absorb(state, seed, NEWHOPE_SEEDBYTES);
+
+  do
+  {
+    shake128_squeezeblocks((unsigned char *) buf, nblocks, state);
+  }
+  while (discardtopoly(a, buf, nblocks));
+}
+
+void poly_getnoise(poly *r, unsigned char *seed, unsigned char nonce)
+{
+#if PARAM_K != 16
+#error "poly_getnoise in poly.c only supports k=16"
+#endif
+
+  uint32_t buf[PARAM_N];
+  uint32_t t,d, a, b;
+  unsigned char n[8];
+  int i,j;
+
+  for(i=1;i<8;i++)
+    n[i] = 0;
+  n[0] = nonce;
+
+  crypto_stream_chacha20((unsigned char *)buf,4*PARAM_N,n,seed);
+
+  for(i=0;i<PARAM_N;i++)
+  {
+    t = buf[i];
+    d = 0;
+    for(j=0;j<8;j++)
+      d += (t >> j) & 0x01010101;
+    a = ((d >> 8) & 0xff) + (d & 0xff);
+    b = (d >> 24) + ((d >> 16) & 0xff);
+    r->coeffs[i] = a + PARAM_Q - b;
+  }
+}
+
+void poly_pointwise(poly *r, const poly *a, const poly *b)
+{
+  int i;
+  uint16_t t;
+  for(i=0;i<PARAM_N;i++)
+  {
+    t       = montgomery_reduce(3186*b->coeffs[i]); /* t is now in Montgomery domain */
+    r->coeffs[i] = montgomery_reduce(a->coeffs[i] * t); /* r->coeffs[i] is back in normal domain */
+  }
+}
+
+void poly_add(poly *r, const poly *a, const poly *b)
+{
+  int i;
+  for(i=0;i<PARAM_N;i++)
+    r->coeffs[i] = barrett_reduce(a->coeffs[i] + b->coeffs[i]);
+}
+
+void poly_ntt(poly *r)
+{
+  mul_coefficients(r->coeffs, psis_bitrev_montgomery); 
+  ntt((uint16_t *)r->coeffs, omegas_montgomery);
+}
+
+void poly_invntt(poly *r)
+{
+  bitrev_vector(r->coeffs);
+  ntt((uint16_t *)r->coeffs, omegas_inv_montgomery);
+  mul_coefficients(r->coeffs, psis_inv_montgomery);
+}
diff --git a/nimble/host/src/newhope/poly.h b/nimble/host/src/newhope/poly.h
new file mode 100644
index 00000000..33214076
--- /dev/null
+++ b/nimble/host/src/newhope/poly.h
@@ -0,0 +1,22 @@
+#ifndef POLY_H
+#define POLY_H
+
+#include <stdint.h>
+#include "params.h"
+
+typedef struct {
+  uint16_t coeffs[PARAM_N];
+} poly __attribute__ ((aligned (32)));
+
+void poly_uniform(poly *a, const unsigned char *seed);
+void poly_getnoise(poly *r, unsigned char *seed, unsigned char nonce);
+void poly_add(poly *r, const poly *a, const poly *b);
+
+void poly_ntt(poly *r);
+void poly_invntt(poly *r);
+void poly_pointwise(poly *r, const poly *a, const poly *b);
+
+void poly_frombytes(poly *r, const unsigned char *a);
+void poly_tobytes(unsigned char *r, const poly *p);
+
+#endif
diff --git a/nimble/host/src/newhope/precomp.c b/nimble/host/src/newhope/precomp.c
new file mode 100644
index 00000000..f885d9fc
--- /dev/null
+++ b/nimble/host/src/newhope/precomp.c
@@ -0,0 +1,11 @@
+#include "inttypes.h"
+#include "ntt.h"
+#include "params.h"
+
+uint16_t omegas_montgomery[PARAM_N/2] = {4075,6974,7373,7965,3262,5079,522,2169,6364,1018,1041,8775,2344,11011,5574,1973,4536,1050,6844,3860,3818,6118,2683,1190,4789,7822,7540,6752,5456,4449,3789,12142,11973,382,3988,468,6843,5339,6196,3710,11316,1254,5435,10930,3998,10256,10367,3879,11889,1728,6137,4948,5862,6136,3643,6874,8724,654,10302,1702,7083,6760,56,3199,9987,605,11785,8076,5594,9260,6403,4782,6212,4624,9026,8689,4080,11868,6221,3602,975,8077,8851,9445,5681,3477,1105,142,241,12231,1003,3532,5009,1956,6008,11404,7377,2049,10968,12097,7591,5057,3445,4780,2920,7048,3127,8120,11279,6821,11502,8807,12138,2127,2839,3957,431,1579,6383,9784,5874,677,3336,6234,2766,1323,9115,12237,2031,6956,6413,2281,3969,3991,12133,9522,4737,10996,4774,5429,11871,3772,453,5908,2882,1805,2051,1954,11713,3963,2447,6142,8174,3030,1843,2361,12071,2908,3529,3434,3202,7796,2057,5369,11939,1512,6906,10474,11026,49,10806,5915,1489,9789,5942,10706,10431,7535,426,8974,3757,10314,9364,347,5868,9551,9634,6554,10596,9280,11566,174,2948,2503,6507,10723,11606,2459,64,3656,8455,5257,5919,7856,1747,9166,5486,9235,6065,835,3570,4240,11580,4046,10970,9139,1058,8210,11848,922,7967,1958,10211,1112,3728,4049,11130,5990,1404,325,948,11143,6190,295,11637,5766,8212,8273,2919,8527,6119,6992,8333,1360,2555,6167,1200,7105,7991,3329,9597,12121,5106,5961,10695,10327,3051,9923,4896,9326,81,3091,1000,7969,4611,726,1853,12149,4255,11112,2768,10654,1062,2294,3553,4805,2747,4846,8577,9154,1170,2319,790,11334,9275,9088,1326,5086,9094,6429,11077,10643,3504,3542,8668,9744,1479,1,8246,7143,11567,10984,4134,5736,4978,10938,5777,8961,4591,5728,6461,5023,9650,7468,949,9664,2975,11726,2744,9283,10092,5067,12171,2476,3748,11336,6522,827,9452,5374,12159,7935,3296,3949,9893,4452,10908,2525,3584,8112,8011,10616,4989,6958,11809,9447,12280,1022,11950,9821,11745,5791,5092,2089,9005,2881,3289,2013,9048,729,7901,1260,5755,4632,11955,2426,10593,1428,4890,5911,3932,9558,8830,3637,5542,145,5179,8595,3707,10530,355,3382,4231,9741,1207,9041,7012,1168,10146,11224,4645,11885,10911,10377,435,7952,4096,493,9908,6845,6039,2422,2187,9723,8643,9852,9302,6022,7278,1002,4284,5088,1607,7313,875,8509,9430,1045,2481,5012,7428,354,6591,9377,11847,2401,1067,7188,11516,390,8511,8456,7270,545,8585,9611,12047,1537,4143,4714,4885,1017,5084,1632,3066,27,1440,8526,9273,12046,11618,9289,3400,9890,3136,7098,8758,11813,7384,3985,11869,6730,10745,10111,2249,4048,2884,11136,2126,1630,9103,5407,2686,9042,2969,8311,9424,9919,8779,5332,10626,1777,4654,10863,7351,3636,9585,5291,8374,2166,4919,12176,9140,12129,7852,12286,4895,10805,2780,5195,2305,7247,9644,4053,10600,3364,3271,4057,4414,9442,7917,2174};
+  
+uint16_t omegas_inv_montgomery[PARAM_N/2]	= {4075,5315,4324,4916,10120,11767,7210,9027,10316,6715,1278,9945,3514,11248,11271,5925,147,8500,7840,6833,5537,4749,4467,7500,11099,9606,6171,8471,8429,5445,11239,7753,9090,12233,5529,5206,10587,1987,11635,3565,5415,8646,6153,6427,7341,6152,10561,400,8410,1922,2033,8291,1359,6854,11035,973,8579,6093,6950,5446,11821,8301,11907,316,52,3174,10966,9523,6055,8953,11612,6415,2505,5906,10710,11858,8332,9450,10162,151,3482,787,5468,1010,4169,9162,5241,9369,7509,8844,7232,4698,192,1321,10240,4912,885,6281,10333,7280,8757,11286,58,12048,12147,11184,8812,6608,2844,3438,4212,11314,8687,6068,421,8209,3600,3263,7665,6077,7507,5886,3029,6695,4213,504,11684,2302,1962,1594,6328,7183,168,2692,8960,4298,5184,11089,6122,9734,10929,3956,5297,6170,3762,9370,4016,4077,6523,652,11994,6099,1146,11341,11964,10885,6299,1159,8240,8561,11177,2078,10331,4322,11367,441,4079,11231,3150,1319,8243,709,8049,8719,11454,6224,3054,6803,3123,10542,4433,6370,7032,3834,8633,12225,9830,683,1566,5782,9786,9341,12115,723,3009,1693,5735,2655,2738,6421,11942,2925,1975,8532,3315,11863,4754,1858,1583,6347,2500,10800,6374,1483,12240,1263,1815,5383,10777,350,6920,10232,4493,9087,8855,8760,9381,218,9928,10446,9259,4115,6147,9842,8326,576,10335,10238,10484,9407,6381,11836,8517,418,6860,7515,1293,7552,2767,156,8298,8320,10008,5876,5333,10258,10115,4372,2847,7875,8232,9018,8925,1689,8236,2645,5042,9984,7094,9509,1484,7394,3,4437,160,3149,113,7370,10123,3915,6998,2704,8653,4938,1426,7635,10512,1663,6957,3510,2370,2865,3978,9320,3247,9603,6882,3186,10659,10163,1153,9405,8241,10040,2178,1544,5559,420,8304,4905,476,3531,5191,9153,2399,8889,3000,671,243,3016,3763,10849,12262,9223,10657,7205,11272,7404,7575,8146,10752,242,2678,3704,11744,5019,3833,3778,11899,773,5101,11222,9888,442,2912,5698,11935,4861,7277,9808,11244,2859,3780,11414,4976,10682,7201,8005,11287,5011,6267,2987,2437,3646,2566,10102,9867,6250,5444,2381,11796,8193,4337,11854,1912,1378,404,7644,1065,2143,11121,5277,3248,11082,2548,8058,8907,11934,1759,8582,3694,7110,12144,6747,8652,3459,2731,8357,6378,7399,10861,1696,9863,334,7657,6534,11029,4388,11560,3241,10276,9000,9408,3284,10200,7197,6498,544,2468,339,11267,9,2842,480,5331,7300,1673,4278,4177,8705,9764,1381,7837,2396,8340,8993,4354,130,6915,2837,11462,5767,953,8541,9813,118,7222,2197,3006,9545,563,9314,2625,11340,4821,2639,7266,5828,6561,7698,3328,6512,1351,7311,6553,8155,1305,722,5146,4043,12288,10810,2545,3621,8747,8785,1646,1212,5860,3195,7203,10963,3201,3014,955,11499,9970,11119,3135,3712,7443,9542,7484,8736,9995,11227,1635,9521,1177,8034,140,10436,11563,7678,4320,11289,9198,12208,2963,7393,2366,9238};
+
+uint16_t psis_bitrev_montgomery[PARAM_N] = {4075,6974,7373,7965,3262,5079,522,2169,6364,1018,1041,8775,2344,11011,5574,1973,4536,1050,6844,3860,3818,6118,2683,1190,4789,7822,7540,6752,5456,4449,3789,12142,11973,382,3988,468,6843,5339,6196,3710,11316,1254,5435,10930,3998,10256,10367,3879,11889,1728,6137,4948,5862,6136,3643,6874,8724,654,10302,1702,7083,6760,56,3199,9987,605,11785,8076,5594,9260,6403,4782,6212,4624,9026,8689,4080,11868,6221,3602,975,8077,8851,9445,5681,3477,1105,142,241,12231,1003,3532,5009,1956,6008,11404,7377,2049,10968,12097,7591,5057,3445,4780,2920,7048,3127,8120,11279,6821,11502,8807,12138,2127,2839,3957,431,1579,6383,9784,5874,677,3336,6234,2766,1323,9115,12237,2031,6956,6413,2281,3969,3991,12133,9522,4737,10996,4774,5429,11871,3772,453,5908,2882,1805,2051,1954,11713,3963,2447,6142,8174,3030,1843,2361,12071,2908,3529,3434,3202,7796,2057,5369,11939,1512,6906,10474,11026,49,10806,5915,1489,9789,5942,10706,10431,7535,426,8974,3757,10314,9364,347,5868,9551,9634,6554,10596,9280,11566,174,2948,2503,6507,10723,11606,2459,64,3656,8455,5257,5919,7856,1747,9166,5486,9235,6065,835,3570,4240,11580,4046,10970,9139,1058,8210,11848,922,7967,1958,10211,1112,3728,4049,11130,5990,1404,325,948,11143,6190,295,11637,5766,8212,8273,2919,8527,6119,6992,8333,1360,2555,6167,1200,7105,7991,3329,9597,12121,5106,5961,10695,10327,3051,9923,4896,9326,81,3091,1000,7969,4611,726,1853,12149,4255,11112,2768,10654,1062,2294,3553,4805,2747,4846,8577,9154,1170,2319,790,11334,9275,9088,1326,5086,9094,6429,11077,10643,3504,3542,8668,9744,1479,1,8246,7143,11567,10984,4134,5736,4978,10938,5777,8961,4591,5728,6461,5023,9650,7468,949,9664,2975,11726,2744,9283,10092,5067,12171,2476,3748,11336,6522,827,9452,5374,12159,7935,3296,3949,9893,4452,10908,2525,3584,8112,8011,10616,4989,6958,11809,9447,12280,1022,11950,9821,11745,5791,5092,2089,9005,2881,3289,2013,9048,729,7901,1260,5755,4632,11955,2426,10593,1428,4890,5911,3932,9558,8830,3637,5542,145,5179,8595,3707,10530,355,3382,4231,9741,1207,9041,7012,1168,10146,11224,4645,11885,10911,10377,435,7952,4096,493,9908,6845,6039,2422,2187,9723,8643,9852,9302,6022,7278,1002,4284,5088,1607,7313,875,8509,9430,1045,2481,5012,7428,354,6591,9377,11847,2401,1067,7188,11516,390,8511,8456,7270,545,8585,9611,12047,1537,4143,4714,4885,1017,5084,1632,3066,27,1440,8526,9273,12046,11618,9289,3400,9890,3136,7098,8758,11813,7384,3985,11869,6730,10745,10111,2249,4048,2884,11136,2126,1630,9103,5407,2686,9042,2969,8311,9424,9919,8779,5332,10626,1777,4654,10863,7351,3636,9585,5291,8374,2166,4919,12176,9140,12129,7852,12286,4895,10805,2780,5195,2305,7247,9644,4053,10600,3364,3271,4057,4414,9442,7917,2174,3947,11951,2455,6599,10545,10975,3654,2894,7681,7126,7287,12269,4119,3343,2151,1522,7174,7350,11041,2442,2148,5959,6492,8330,8945,5598,3624,10397,1325,6565,1945,11260,10077,2674,3338,3276,11034,506,6505,1392,5478,8778,1178,2776,3408,10347,11124,2575,9489,12096,6092,10058,4167,6085,923,11251,11912,4578,10669,11914,425,10453,392,10104,8464,4235,8761,7376,2291,3375,7954,8896,6617,7790,1737,11667,3982,9342,6680,636,6825,7383,512,4670,2900,12050,7735,994,1687,11883,7021,146,10485,1403,5189,6094,2483,2054,3042,10945,3981,10821,11826,8882,8151,180,9600,7684,5219,10880,6780,204,11232,2600,7584,3121,3017,11053,7814,7043,4251,4739,11063,6771,7073,9261,2360,11925,1928,11825,8024,3678,3205,3359,11197,5209,8581,3238,8840,1136,9363,1826,3171,4489,7885,346,2068,1389,8257,3163,4840,6127,8062,8921,612,4238,10763,8067,125,11749,10125,5416,2110,716,9839,10584,11475,11873,3448,343,1908,4538,10423,7078,4727,1208,11572,3589,2982,1373,1721,10753,4103,2429,4209,5412,5993,9011,438,3515,7228,1218,8347,5232,8682,1327,7508,4924,448,1014,10029,12221,4566,5836,12229,2717,1535,3200,5588,5845,412,5102,7326,3744,3056,2528,7406,8314,9202,6454,6613,1417,10032,7784,1518,3765,4176,5063,9828,2275,6636,4267,6463,2065,7725,3495,8328,8755,8144,10533,5966,12077,9175,9520,5596,6302,8400,579,6781,11014,5734,11113,11164,4860,1131,10844,9068,8016,9694,3837,567,9348,7000,6627,7699,5082,682,11309,5207,4050,7087,844,7434,3769,293,9057,6940,9344,10883,2633,8190,3944,5530,5604,3480,2171,9282,11024,2213,8136,3805,767,12239,216,11520,6763,10353,7,8566,845,7235,3154,4360,3285,10268,2832,3572,1282,7559,3229,8360,10583,6105,3120,6643,6203,8536,8348,6919,3536,9199,10891,11463,5043,1658,5618,8787,5789,4719,751,11379,6389,10783,3065,7806,6586,2622,5386,510,7628,6921,578,10345,11839,8929,4684,12226,7154,9916,7302,8481,3670,11066,2334,1590,7878,10734,1802,1891,5103,6151,8820,3418,7846,9951,4693,417,9996,9652,4510,2946,5461,365,881,1927,1015,11675,11009,1371,12265,2485,11385,5039,6742,8449,1842,12217,8176,9577,4834,7937,9461,2643,11194,3045,6508,4094,3451,7911,11048,5406,4665,3020,6616,11345,7519,3669,5287,1790,7014,5410,11038,11249,2035,6125,10407,4565,7315,5078,10506,2840,2478,9270,4194,9195,4518,7469,1160,6878,2730,10421,10036,1734,3815,10939,5832,10595,10759,4423,8420,9617,7119,11010,11424,9173,189,10080,10526,3466,10588,7592,3578,11511,7785,9663,530,12150,8957,2532,3317,9349,10243,1481,9332,3454,3758,7899,4218,2593,11410,2276,982,6513,1849,8494,9021,4523,7988,8,457,648,150,8000,2307,2301,874,5650,170,9462,2873,9855,11498,2535,11169,5808,12268,9687,1901,7171,11787,3846,1573,6063,3793,466,11259,10608,3821,6320,4649,6263,2929};
+
+uint16_t psis_inv_montgomery[PARAM_N] = {256,10570,1510,7238,1034,7170,6291,7921,11665,3422,4000,2327,2088,5565,795,10647,1521,5484,2539,7385,1055,7173,8047,11683,1669,1994,3796,5809,4341,9398,11876,12230,10525,12037,12253,3506,4012,9351,4847,2448,7372,9831,3160,2207,5582,2553,7387,6322,9681,1383,10731,1533,219,5298,4268,7632,6357,9686,8406,4712,9451,10128,4958,5975,11387,8649,11769,6948,11526,12180,1740,10782,6807,2728,7412,4570,4164,4106,11120,12122,8754,11784,3439,5758,11356,6889,9762,11928,1704,1999,10819,12079,12259,7018,11536,1648,1991,2040,2047,2048,10826,12080,8748,8272,8204,1172,1923,7297,2798,7422,6327,4415,7653,6360,11442,12168,7005,8023,9924,8440,8228,2931,7441,1063,3663,5790,9605,10150,1450,8985,11817,10466,10273,12001,3470,7518,1074,1909,7295,9820,4914,702,5367,7789,8135,9940,1420,3714,11064,12114,12264,1752,5517,9566,11900,1700,3754,5803,829,1874,7290,2797,10933,5073,7747,8129,6428,6185,11417,1631,233,5300,9535,10140,11982,8734,8270,2937,10953,8587,8249,2934,9197,4825,5956,4362,9401,1343,3703,529,10609,12049,6988,6265,895,3639,4031,4087,4095,585,10617,8539,4731,4187,9376,3095,9220,10095,10220,1460,10742,12068,1724,5513,11321,6884,2739,5658,6075,4379,11159,10372,8504,4726,9453,3106,7466,11600,10435,8513,9994,8450,9985,3182,10988,8592,2983,9204,4826,2445,5616,6069,867,3635,5786,11360,5134,2489,10889,12089,1727,7269,2794,9177,1311,5454,9557,6632,2703,9164,10087,1441,3717,531,3587,2268,324,5313,759,1864,5533,2546,7386,9833,8427,4715,11207,1601,7251,4547,11183,12131,1733,10781,10318,1474,10744,5046,4232,11138,10369,6748,964,7160,4534,7670,8118,8182,4680,11202,6867,981,8918,1274,182,26,7026,8026,11680,12202,10521,1503,7237,4545,5916,9623,8397,11733,10454,3249,9242,6587,941,1890,270,10572,6777,9746,6659,6218,6155,6146,878,1881,7291,11575,12187,1741,7271,8061,11685,6936,4502,9421,4857,4205,7623,1089,10689,1527,8996,10063,11971,10488,6765,2722,3900,9335,11867,6962,11528,5158,4248,4118,5855,2592,5637,6072,2623,7397,8079,9932,4930,5971,853,3633,519,8852,11798,3441,11025,1575,225,8810,11792,12218,3501,9278,3081,9218,4828,7712,8124,11694,12204,3499,4011,573,3593,5780,7848,9899,10192,1456,208,7052,2763,7417,11593,10434,12024,8740,11782,10461,3250,5731,7841,9898,1414,202,3540,7528,2831,2160,10842,5060,4234,4116,588,84,12,7024,2759,9172,6577,11473,1639,9012,3043,7457,6332,11438,1634,1989,9062,11828,8712,11778,12216,10523,6770,9745,10170,4964,9487,6622,946,8913,6540,6201,4397,9406,8366,9973,8447,8229,11709,8695,10020,3187,5722,2573,10901,6824,4486,4152,9371,8361,2950,2177,311,1800,9035,8313,11721,3430,490,70,10,1757,251,3547,7529,11609,3414,7510,4584,4166,9373,1339,5458,7802,11648,1664,7260,9815,10180,6721,9738,10169,8475,8233,9954,1422,8981,1283,5450,11312,1616,3742,11068,10359,4991,713,3613,9294,8350,4704,672,96,7036,9783,11931,3460,5761,823,10651,12055,10500,1500,5481,783,3623,11051,8601,8251,8201,11705,10450,5004,4226,7626,2845,2162,3820,7568,9859,3164,452,10598,1514,5483,6050,6131,4387,7649,8115,6426,918,8909,8295,1185,5436,11310,8638,1234,5443,11311,5127,2488,2111,10835,5059,7745,2862,3920,560,80,1767,2008,3798,11076,6849,2734,10924,12094,8750,1250,10712,6797,971,7161,1023,8924,4786,7706,4612,4170,7618,6355,4419,5898,11376,10403,10264,6733,4473,639,5358,2521,9138,3061,5704,4326,618,5355,765,5376,768,7132,4530,9425,3102,9221,6584,11474,10417,10266,12000,6981,6264,4406,2385,7363,4563,4163,7617,9866,3165,9230,11852,10471,5007,5982,11388,5138,734,3616,11050,12112,6997,11533,12181,10518,12036,3475,2252,7344,9827,4915,9480,6621,4457,7659,9872,6677,4465,4149,7615,4599,657,3605,515,10607,6782,4480,640,1847,3775,5806,2585,5636,9583,1369,10729,8555,10000,11962,5220,7768,8132,8184,9947,1421,203,29,8782,11788,1684,10774,10317,4985,9490,8378,4708,11206,5112,5997,7879,11659,12199,8765,10030,4944,5973,6120,6141,6144,7900,11662,1666,238,34,3516,5769,9602,8394,9977,6692,956,10670,6791,9748,11926,8726,11780,5194,742,106,8793,10034,3189,10989,5081,4237,5872,4350,2377,10873,6820,6241,11425,10410,10265,3222,5727,9596,4882,2453,2106,3812,11078,12116,5242,4260,11142,8614,11764,12214,5256,4262,4120,11122,5100,11262,5120,2487,5622,9581,8391,8221,2930,10952,12098,6995,6266,9673,4893,699,3611,4027,5842,11368,1624,232,8811,8281,1183,169,8802,3013,2186,5579,797,3625,4029,11109,1587,7249,11569,8675,6506,2685,10917,12093,12261,12285,1755,7273,1039,1904,272,3550,9285,3082,5707,6082,4380,7648,11626,5172,4250,9385,8363,8217,4685,5936,848,8899,6538,934,1889,3781,9318,10109,10222,6727,961,5404,772,5377,9546,8386,1198,8949,3034,2189,7335,4559,5918,2601,10905,5069,9502,3113,7467,8089,11689,5181,9518,8382,2953,3933,4073,4093,7607,8109,2914,5683,4323,11151,1593,10761,6804,972,3650,2277,5592,4310,7638,9869,4921,703,1856,9043,4803,9464,1352,8971,11815,5199,7765,6376,4422,7654,2849,407,8836,6529,7955,2892,9191,1313,10721,12065,12257,1751,9028,8312,2943,2176,3822,546,78,8789,11789,10462,12028,6985,4509,9422,1346,5459,4291,613,10621,6784,9747,3148,7472,2823,5670,810,7138,8042,4660,7688,6365,6176,6149,2634,5643,9584,10147,11983,5223,9524,11894,10477,8519,1217,3685,2282,326,10580,3267,7489,4581,2410,5611,11335,6886,8006,8166,11700,3427,11023,8597,10006,3185,455,65,5276,7776,4622,5927,7869,9902,11948,5218,2501,5624,2559,10899,1557,1978,10816,10323,8497,4725,675,1852,10798,12076,10503,3256,9243,3076,2195,10847,12083,10504,12034,10497};
diff --git a/nimble/host/src/newhope/randombytes.c b/nimble/host/src/newhope/randombytes.c
new file mode 100644
index 00000000..291353f3
--- /dev/null
+++ b/nimble/host/src/newhope/randombytes.c
@@ -0,0 +1,34 @@
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include "randombytes.h"
+
+static int fd = -1;
+
+void randombytes(unsigned char *x,unsigned long long xlen)
+{
+  int i;
+
+  if (fd == -1) {
+    for (;;) {
+      fd = open("/dev/urandom",O_RDONLY);
+      if (fd != -1) break;
+      sleep(1);
+    }
+  }
+
+  while (xlen > 0) {
+    if (xlen < 1048576) i = xlen; else i = 1048576;
+
+    i = read(fd,x,i);
+    if (i < 1) {
+      sleep(1);
+      continue;
+    }
+
+    x += i;
+    xlen -= i;
+  }
+}
+
diff --git a/nimble/host/src/newhope/randombytes.h b/nimble/host/src/newhope/randombytes.h
new file mode 100644
index 00000000..7ea0b803
--- /dev/null
+++ b/nimble/host/src/newhope/randombytes.h
@@ -0,0 +1,6 @@
+#ifndef RANDOMBYTES_H
+#define RANDOMBYTES_H
+
+void randombytes(unsigned char *x,unsigned long long xlen);
+
+#endif
diff --git a/nimble/host/src/newhope/reduce.c b/nimble/host/src/newhope/reduce.c
new file mode 100644
index 00000000..292086aa
--- /dev/null
+++ b/nimble/host/src/newhope/reduce.c
@@ -0,0 +1,33 @@
+#include "reduce.h"
+#include "params.h"
+
+/* Incomplete-reduction routines; for details on allowed input ranges
+ * and produced output ranges, see the description in the paper: 
+ * https://cryptojedi.org/papers/#newhope */
+
+
+static const uint32_t qinv = 12287; // -inverse_mod(p,2^18)
+static const uint32_t rlog = 18;
+
+uint16_t montgomery_reduce(uint32_t a)
+{
+  uint32_t u;
+
+  u = (a * qinv);
+  u &= ((1<<rlog)-1);
+  u *= PARAM_Q;
+  a = a + u;
+  return a >> 18;
+}
+
+
+uint16_t barrett_reduce(uint16_t a)
+{
+  uint32_t u;
+
+  u = ((uint32_t) a * 5) >> 16;
+  u *= PARAM_Q;
+  a -= u;
+  return a;
+}
+
diff --git a/nimble/host/src/newhope/reduce.h b/nimble/host/src/newhope/reduce.h
new file mode 100644
index 00000000..ca190fda
--- /dev/null
+++ b/nimble/host/src/newhope/reduce.h
@@ -0,0 +1,10 @@
+#ifndef REDUCE_H
+#define REDUCE_H
+
+#include <stdint.h>
+
+uint16_t montgomery_reduce(uint32_t a);
+
+uint16_t barrett_reduce(uint16_t a);
+
+#endif
diff --git a/nimble/host/src/x25519.c b/nimble/host/src/x25519.c
new file mode 100644
index 00000000..b78bb156
--- /dev/null
+++ b/nimble/host/src/x25519.c
@@ -0,0 +1,513 @@
+// Taken from https://sourceforge.net/p/strobe (MIT Licence)
+/**
+ * @cond internal
+ * @file x25519.c
+ * @copyright
+ *   Copyright (c) 2015-2016 Cryptography Research, Inc.  \n
+ *   Released under the MIT License.  See LICENSE.txt for license information.
+ * @author Mike Hamburg
+ * @brief Key exchange and signatures based on X25519.
+ */
+#include <stdint.h>
+#include "x25519.h"
+// Need os for the rand()
+#include "os/os.h"
+// #include "strobe.h"
+// #include "strobe_config.h"
+//  STROBE header replacement
+#include <string.h>
+#define X25519_WBITS 32
+#define X25519_SUPPORT_SIGN 0
+#define X25519_MEMCPY_PARAMS 1
+#define X25519_USE_POWER_CHAIN 1
+#if BYTE_ORDER == LITTLE_ENDIAN
+static inline uint32_t
+eswap_letoh_32(uint32_t w)
+{
+    return w;
+}
+#else
+#error "Fix eswap() on non-little-endian machine"
+#endif
+
+#if X25519_WBITS == 64
+typedef uint64_t limb_t;
+typedef __uint128_t dlimb_t;
+typedef __int128_t sdlimb_t;
+#define eswap_limb eswap_letoh_64
+#define LIMB(x) x##ull
+#elif X25519_WBITS == 32
+typedef uint32_t limb_t;
+typedef uint64_t dlimb_t;
+typedef int64_t sdlimb_t;
+#define eswap_limb eswap_letoh_32
+#define LIMB(x) (uint32_t)(x##ull), (uint32_t)((x##ull) >> 32)
+#else
+#error "Need to know X25519_WBITS"
+#endif
+
+#define NLIMBS (256 / X25519_WBITS)
+typedef limb_t fe[NLIMBS];
+
+#if X25519_SUPPORT_SIGN
+typedef limb_t scalar_t[NLIMBS];
+static const limb_t MONTGOMERY_FACTOR = (limb_t)0xd2b51da312547e1bull;
+static const scalar_t sc_p = {LIMB(0x5812631a5cf5d3ed),
+                              LIMB(0x14def9dea2f79cd6),
+                              LIMB(0x0000000000000000),
+                              LIMB(0x1000000000000000)},
+                      sc_r2 = {
+                          LIMB(0xa40611e3449c0f01), LIMB(0xd00e1ba768859347),
+                          LIMB(0xceec73d217f5be65), LIMB(0x0399411b7c309a3d)};
+#endif
+
+static inline limb_t
+umaal(limb_t* carry, limb_t acc, limb_t mand, limb_t mier)
+{
+    dlimb_t tmp = (dlimb_t)mand * mier + acc + *carry;
+    *carry = tmp >> X25519_WBITS;
+    return tmp;
+}
+
+/* These functions are implemented in terms of umaal on ARM */
+static inline limb_t
+adc(limb_t* carry, limb_t acc, limb_t mand)
+{
+    dlimb_t total = (dlimb_t)*carry + acc + mand;
+    *carry = total >> X25519_WBITS;
+    return total;
+}
+
+static inline limb_t
+adc0(limb_t* carry, limb_t acc)
+{
+    dlimb_t total = (dlimb_t)*carry + acc;
+    *carry = total >> X25519_WBITS;
+    return total;
+}
+
+/* Precondition: carry is small.
+ * Invariant: result of propagate is < 2^255 + 1 word
+ * In particular, always less than 2p.
+ * Also, output x >= min(x,19)
+ */
+static void
+propagate(fe x, limb_t over)
+{
+    unsigned i;
+    over = x[NLIMBS - 1] >> (X25519_WBITS - 1) | over << 1;
+    x[NLIMBS - 1] &= ~((limb_t)1 << (X25519_WBITS - 1));
+
+    limb_t carry = over * 19;
+    for (i = 0; i < NLIMBS; i++) {
+        x[i] = adc0(&carry, x[i]);
+    }
+}
+
+static void
+add(fe out, const fe a, const fe b)
+{
+    unsigned i;
+    limb_t carry = 0;
+    for (i = 0; i < NLIMBS; i++) {
+        out[i] = adc(&carry, a[i], b[i]);
+    }
+    propagate(out, carry);
+}
+
+static void
+sub(fe out, const fe a, const fe b)
+{
+    unsigned i;
+    sdlimb_t carry = -38;
+    for (i = 0; i < NLIMBS; i++) {
+        out[i] = carry = carry + a[i] - b[i];
+        carry >>= X25519_WBITS;
+    }
+    propagate(out, 1 + carry);
+}
+
+static void __attribute__((unused))
+swapin(limb_t* x, const uint8_t* in)
+{
+    memcpy(x, in, sizeof(fe));
+    unsigned i;
+    for (i = 0; i < NLIMBS; i++) {
+        x[i] = eswap_limb(x[i]);
+    }
+}
+
+static void __attribute__((unused))
+swapout(uint8_t* out, limb_t* x)
+{
+    unsigned i;
+    for (i = 0; i < NLIMBS; i++) {
+        x[i] = eswap_limb(x[i]);
+    }
+    memcpy(out, x, sizeof(fe));
+}
+
+static void
+mul(fe out, const fe a, const fe b, unsigned nb)
+{
+    /* GCC at least produces pretty decent asm for this, so don't need to have dedicated asm. */
+    limb_t accum[2 * NLIMBS] = {0};
+    unsigned i, j;
+
+    limb_t carry2;
+    for (i = 0; i < nb; i++) {
+        carry2 = 0;
+        limb_t mand = b[i];
+        for (j = 0; j < NLIMBS; j++) {
+            accum[i + j] = umaal(&carry2, accum[i + j], mand, a[j]);
+        }
+        accum[i + j] = carry2;
+    }
+
+    carry2 = 0;
+    const limb_t mand = 38;
+    for (j = 0; j < NLIMBS; j++) {
+        out[j] = umaal(&carry2, accum[j], mand, accum[j + NLIMBS]);
+    }
+    propagate(out, carry2);
+}
+
+static void
+sqr(fe out, const fe a)
+{
+    mul(out, a, a, NLIMBS);
+}
+static void
+mul1(fe out, const fe a)
+{
+    mul(out, a, out, NLIMBS);
+}
+static void
+sqr1(fe a)
+{
+    mul1(a, a);
+}
+
+static void
+condswap(limb_t a[2 * NLIMBS], limb_t b[2 * NLIMBS], limb_t doswap)
+{
+    unsigned i;
+    for (i = 0; i < 2 * NLIMBS; i++) {
+        limb_t xor = (a[i] ^ b[i]) & doswap;
+        a[i] ^= xor;
+        b[i] ^= xor;
+    }
+}
+
+static limb_t
+canon(fe x)
+{
+    /* Canonicalize a field element x, reducing it to the least residue
+     * which is congruent to it mod 2^255-19.
+     *
+     * Precondition: x < 2^255 + 1 word
+     */
+
+    /* First, add 19. */
+    unsigned i;
+    limb_t carry0 = 19;
+    for (i = 0; i < NLIMBS; i++) {
+        x[i] = adc0(&carry0, x[i]);
+    }
+    propagate(x, carry0);
+
+    /* Here, 19 <= x2 < 2^255
+     *
+     * This is because we added 19, so before propagate it can't be less than 19.
+     * After propagate, it still can't be less than 19, because if propagate does
+     * anything it adds 19.
+     *
+     * We know that the high bit must be clear, because either the input was
+     * ~ 2^255 + one word + 19 (in which case it propagates to at most 2 words)
+     * or it was < 2^255.
+     *
+     * So now, if we subtract 19, we will get back to something in [0,2^255-19).
+     */
+    sdlimb_t carry = -19;
+    limb_t res = 0;
+    for (i = 0; i < NLIMBS; i++) {
+        res |= x[i] = carry += x[i];
+        carry >>= X25519_WBITS;
+    }
+    return ((dlimb_t)res - 1) >> X25519_WBITS;
+}
+
+static const limb_t a24[1] = {121665};
+
+static void
+ladder_part1(fe xs[5])
+{
+    limb_t *x2 = xs[0], *z2 = xs[1], *x3 = xs[2], *z3 = xs[3], *t1 = xs[4];
+    add(t1, x2, z2);                                // t1 = A
+    sub(z2, x2, z2);                                // z2 = B
+    add(x2, x3, z3);                                // x2 = C
+    sub(z3, x3, z3);                                // z3 = D
+    mul1(z3, t1);                                   // z3 = DA
+    mul1(x2, z2);                                   // x3 = BC
+    add(x3, z3, x2);                                // x3 = DA+CB
+    sub(z3, z3, x2);                                // z3 = DA-CB
+    sqr1(t1);                                       // t1 = AA
+    sqr1(z2);                                       // z2 = BB
+    sub(x2, t1, z2);                                // x2 = E = AA-BB
+    mul(z2, x2, a24, sizeof(a24) / sizeof(a24[0])); // z2 = E*a24
+    add(z2, z2, t1);                                // z2 = E*a24 + AA
+}
+static void
+ladder_part2(fe xs[5], const fe x1)
+{
+    limb_t *x2 = xs[0], *z2 = xs[1], *x3 = xs[2], *z3 = xs[3], *t1 = xs[4];
+    sqr1(z3);        // z3 = (DA-CB)^2
+    mul1(z3, x1);    // z3 = x1 * (DA-CB)^2
+    sqr1(x3);        // x3 = (DA+CB)^2
+    mul1(z2, x2);    // z2 = AA*(E*a24+AA)
+    sub(x2, t1, x2); // x2 = BB again
+    mul1(x2, t1);    // x2 = AA*BB
+}
+
+static void
+x25519_core(fe xs[5], const uint8_t scalar[X25519_BYTES], const uint8_t* x1,
+            int clamp)
+{
+    int i;
+#if X25519_MEMCPY_PARAMS
+    fe x1i;
+    swapin(x1i, x1);
+    x1 = (const uint8_t*)x1;
+#endif
+    limb_t swap = 0;
+    limb_t *x2 = xs[0], *x3 = xs[2], *z3 = xs[3];
+    memset(xs, 0, 4 * sizeof(fe));
+    x2[0] = z3[0] = 1;
+    memcpy(x3, x1, sizeof(fe));
+
+    for (i = 255; i >= 0; i--) {
+        uint8_t bytei = scalar[i / 8];
+        if (clamp) {
+            if (i / 8 == 0) {
+                bytei &= ~7;
+            }
+            else if (i / 8 == X25519_BYTES - 1) {
+                bytei &= 0x7F;
+                bytei |= 0x40;
+            }
+        }
+        limb_t doswap = -(limb_t)((bytei >> (i % 8)) & 1);
+        condswap(x2, x3, swap ^ doswap);
+        swap = doswap;
+
+        ladder_part1(xs);
+        ladder_part2(xs, (const limb_t*)x1);
+    }
+    condswap(x2, x3, swap);
+}
+
+int
+x25519(uint8_t out[X25519_BYTES], const uint8_t scalar[X25519_BYTES],
+       const uint8_t x1[X25519_BYTES], int clamp)
+{
+    fe xs[5];
+    x25519_core(xs, scalar, x1, clamp);
+
+    /* Precomputed inversion chain */
+    limb_t *x2 = xs[0], *z2 = xs[1], *z3 = xs[3];
+    int i;
+
+    limb_t* prev = z2;
+#if X25519_USE_POWER_CHAIN
+    static const struct
+    {
+        uint8_t a, c, n;
+    } steps[13] = {{2, 1, 1},  {2, 1, 1},  {4, 2, 3},  {2, 4, 6},  {3, 1, 1},
+                   {3, 2, 12}, {4, 3, 25}, {2, 3, 25}, {2, 4, 50}, {3, 2, 125},
+                   {3, 1, 2},  {3, 1, 2},  {3, 1, 1}};
+    for (i = 0; i < 13; i++) {
+        int j;
+        limb_t* a = xs[steps[i].a];
+        for (j = steps[i].n; j > 0; j--) {
+            sqr(a, prev);
+            prev = a;
+        }
+        mul1(a, xs[steps[i].c]);
+    }
+#else
+    /* Raise to the p-2 = 0x7f..ffeb */
+    for (i = 253; i >= 0; i--) {
+        sqr(z3, prev);
+        prev = z3;
+        if (i >= 8 || (0xeb >> i & 1)) {
+            mul1(z3, z2);
+        }
+    }
+#endif
+
+    /* Here prev = z3 */
+    /* x2 /= z2 */
+#if X25519_MEMCPY_PARAMS
+    mul1(x2, z3);
+    int ret = canon(x2);
+    swapout(out, x2);
+#else
+    mul((limb_t*)out, x2, z3, NLIMBS);
+    int ret = canon((limb_t*)out);
+#endif
+    if (clamp)
+        return ret;
+    else
+        return 0;
+}
+
+const uint8_t X25519_BASE_POINT[X25519_BYTES] = {9};
+
+#if X25519_SUPPORT_VERIFY
+static limb_t
+x25519_verify_core(fe xs[5], const limb_t* other1,
+                   const uint8_t other2[X25519_BYTES])
+{
+    limb_t *z2 = xs[1], *x3 = xs[2], *z3 = xs[3];
+#if X25519_MEMCPY_PARAMS
+    fe xo2;
+    swapin(xo2, other2);
+#else
+    const limb_t* xo2 = (const limb_t*)other2;
+#endif
+
+    memcpy(x3, other1, 2 * sizeof(fe));
+
+    ladder_part1(xs);
+
+    /* Here z2 = t2^2 */
+    mul1(z2, other1);
+    mul1(z2, other1 + NLIMBS);
+    mul1(z2, xo2);
+    const limb_t sixteen = 16;
+    mul(z2, z2, &sixteen, 1);
+
+    mul1(z3, xo2);
+    sub(z3, z3, x3);
+    sqr1(z3);
+
+    /* check equality */
+    sub(z3, z3, z2);
+
+    /* If canon(z2) then both sides are zero.
+     * If canon(z3) then the two sides are equal.
+     *
+     * Reject sigs where both sides are zero, because
+     * that can happen if an input causes the ladder to
+     * return 0/0.
+     */
+    return canon(z2) | ~canon(z3);
+}
+
+int
+x25519_verify_p2(const uint8_t response[X25519_BYTES],
+                 const uint8_t challenge[X25519_BYTES],
+                 const uint8_t eph[X25519_BYTES],
+                 const uint8_t pub[X25519_BYTES])
+{
+    fe xs[7];
+    x25519_core(&xs[0], challenge, pub, 0);
+    x25519_core(&xs[2], response, X25519_BASE_POINT, 0);
+    return x25519_verify_core(&xs[2], xs[0], eph);
+}
+#endif // X25519_SUPPORT_VERIFY
+
+#if X25519_SUPPORT_SIGN
+static void
+sc_montmul(scalar_t out, const scalar_t a, const scalar_t b)
+{
+    /**
+     * OK, so carry bounding.  We're using a high carry, so that the
+     * inputs don't have to be reduced.
+     *
+     * First montmul: output < (M^2 + Mp)/M = M+p, subtract p, < M.  This gets rid of high carry.
+     * Second montmul, by r^2 mod p < p: output < (Mp + Mp)/M = 2p, subtract p, < p, done.
+     */
+    unsigned i, j;
+    limb_t hic = 0;
+    for (i = 0; i < NLIMBS; i++) {
+        limb_t carry = 0, carry2 = 0, mand = a[i], mand2 = MONTGOMERY_FACTOR;
+
+        for (j = 0; j < NLIMBS; j++) {
+            limb_t acc = out[j];
+            acc = umaal(&carry, acc, mand, b[j]);
+            if (j == 0)
+                mand2 *= acc;
+            acc = umaal(&carry2, acc, mand2, sc_p[j]);
+            if (j > 0)
+                out[j - 1] = acc;
+        }
+
+        /* Add two carry registers and high carry */
+        out[NLIMBS - 1] = adc(&hic, carry, carry2);
+    }
+
+    /* Reduce */
+    sdlimb_t scarry = 0;
+    for (i = 0; i < NLIMBS; i++) {
+        out[i] = scarry = scarry + out[i] - sc_p[i];
+        scarry >>= X25519_WBITS;
+    }
+    limb_t need_add = -(scarry + hic);
+
+    limb_t carry = 0;
+    for (i = 0; i < NLIMBS; i++) {
+        out[i] = umaal(&carry, out[i], need_add, sc_p[i]);
+    }
+}
+
+void
+x25519_sign_p2(uint8_t response[X25519_BYTES],
+               const uint8_t challenge[X25519_BYTES],
+               const uint8_t eph_secret[X25519_BYTES],
+               const uint8_t secret[X25519_BYTES])
+{
+    /* FUTURE memory/code size: just make eph_secret non-const? */
+    scalar_t scalar1;
+    swapin(scalar1, eph_secret);
+
+#if X25519_MEMCPY_PARAMS
+    scalar_t scalar2, scalar3;
+    swapin(scalar2, secret);
+    swapin(scalar3, challenge);
+    sc_montmul(scalar1, scalar2, scalar3);
+    memset(scalar2, 0, sizeof(scalar2));
+    sc_montmul(scalar2, scalar1, sc_r2);
+    swapout(response, scalar2);
+#else
+    sc_montmul(scalar1, (const limb_t*)secret, (const limb_t*)challenge);
+    memset(response, 0, X25519_BYTES);
+    sc_montmul((limb_t*)response, scalar1, sc_r2);
+#endif
+}
+#endif // X25519_SUPPORT_SIGN
+
+// Only for testing
+// void random_buf(uint8_t *buf, size_t buf_len) {
+//     int x;
+//     uint8_t *out = (uint8_t *)buf;
+//     for (x = 0; x < buf_len; x++) {
+//         out[x] = rand() % 0xFF;
+//     }
+// }
+
+// int x25519_make_keypair(unsigned char *pub, unsigned char *priv){
+//     random_buf(priv, EC_PRIVATE_BYTES);
+
+//     priv[0] &= 248;
+//     priv[31] &= 127;
+//     priv[31] |= 64;
+
+//     x25519(pub, priv, X25519_BASE_POINT, 1);
+//     return 0;
+// }
+
+// int x25519_shared_secret(unsigned char *shared, unsigned char *priv, unsigned char *pub){
+//     x25519(shared, priv, pub, 1);
+//     return 0;
+// }
diff --git a/nimble/host/src/x25519.h b/nimble/host/src/x25519.h
new file mode 100644
index 00000000..50a6b0e5
--- /dev/null
+++ b/nimble/host/src/x25519.h
@@ -0,0 +1,130 @@
+// Taken from https://sourceforge.net/p/strobe (MIT Licence)
+/**
+ * @file x25519.h
+ * @copyright
+ *   Copyright (c) 2016 Cryptography Research, Inc.  \n
+ *   Released under the MIT License.  See LICENSE.txt for license information.
+ * @author Mike Hamburg
+ * @brief X25519 key exchange and signatures.
+ */
+
+#ifndef __X25519_H__
+#define __X25519_H__
+
+#define X25519_BYTES (256 / 8)
+
+/* The base point (9) */
+extern const unsigned char X25519_BASE_POINT[X25519_BYTES];
+
+/** Number of bytes in an EC public key */
+#define EC_PUBLIC_BYTES 32
+
+/** Number of bytes in an EC private key */
+#define EC_PRIVATE_BYTES 32
+
+/**
+ * Number of bytes in a Schnorr challenge.
+ * Could be set to 16 in a pinch.  (FUTURE?)
+ */
+#define EC_CHALLENGE_BYTES 32
+
+/** Enough bytes to get a uniform sample mod #E.  For eg a Brainpool
+ * curve this would need to be more than for a private key, but due
+ * to the special prime used by Curve25519, the same size is enough.
+ */
+#define EC_UNIFORM_BYTES 32
+
+/* x25519 scalar multiplication.  Sets out to scalar*base.
+ *
+ * If clamp is set (and supported by X25519_INTEROP_SUPPORT_CLAMP)
+ * then the scalar will be "clamped" like a Curve25519 secret key.
+ * This adds almost no security, but permits interop with other x25519
+ * implementations without manually clamping the keys.
+ *
+ * Per RFC 7748, this function returns failure (-1) if the output
+ * is zero and clamp is set.  This indicates "non-contributory behavior",
+ * meaning that one party might steer the key so that the other party's
+ * contribution doesn't matter, or contributes only a little entropy.
+ *
+ * WARNING: however, this function differs from RFC 7748 in another way:
+ * it pays attention to the high bit base[EC_PUBLIC_BYTES-1] & 0x80, but
+ * RFC 7748 says to ignore this bit.  For compatibility with RFC 7748,
+ * you must also clear this bit by running base[EC_PUBLIC_BYTES-1] &= 0x7F.
+ * This library won't clear it for you because it takes the base point as
+ * const, and (depending on build flags) dosen't copy it.
+ *
+ * If clamp==0, or if X25519_INTEROP_SUPPORT_CLAMP==0, then this function
+ * always returns 0.
+ */
+int
+x25519(unsigned char out[EC_PUBLIC_BYTES],
+       const unsigned char scalar[EC_PRIVATE_BYTES],
+       const unsigned char base[EC_PUBLIC_BYTES], int clamp);
+
+/**
+ * Returns 0 on success, -1 on failure.
+ *
+ * Per RFC 7748, this function returns failure if the output
+ * is zero and clamp is set.  This usually doesn't matter for
+ * base scalarmuls.
+ *
+ * If clamp==0, or if X25519_INTEROP_SUPPORT_CLAMP==0, then this function
+ * always returns 0.
+ *
+ * Same as x255(out,scalar,X255_BASE_POINT), except that
+ * other implementations may optimize it.
+ */
+static inline int
+x25519_base(unsigned char out[EC_PUBLIC_BYTES],
+            const unsigned char scalar[EC_PRIVATE_BYTES], int clamp)
+{
+    return x25519(out, scalar, X25519_BASE_POINT, clamp);
+}
+
+/**
+ * As x25519_base, but with a scalar that's EC_UNIFORM_BYTES long,
+ * and clamp always 0 (and thus, no return value).
+ *
+ * This is used for signing.  Implementors must replace it for
+ * curves that require more bytes for uniformity (Brainpool).
+ */
+static inline void
+x25519_base_uniform(unsigned char out[EC_PUBLIC_BYTES],
+                    const unsigned char scalar[EC_UNIFORM_BYTES])
+{
+    (void)x25519_base(out, scalar, 0);
+}
+
+/**
+ * STROBE-compatible Schnorr signatures using curve25519 (not ed25519)
+ *
+ * The user will call x25519_base_uniform(eph,eph_secret) to schedule
+ * a random ephemeral secret key.  They then call a Schnorr oracle to
+ * get a challenge, and compute the response using this function.
+ */
+void
+x25519_sign_p2(unsigned char response[EC_PRIVATE_BYTES],
+               const unsigned char challenge[EC_CHALLENGE_BYTES],
+               const unsigned char eph_secret[EC_UNIFORM_BYTES],
+               const unsigned char secret[EC_PRIVATE_BYTES]);
+
+/**
+ * STROBE-compatible signature verification using curve25519 (not ed25519).
+ * This function is the public equivalent x25519_sign_p2, taking the long-term
+ * and ephemeral public keys instead of secret ones.
+ *
+ * Returns -1 on failure and 0 on success.
+ */
+int
+x25519_verify_p2(const unsigned char response[X25519_BYTES],
+                 const unsigned char challenge[X25519_BYTES],
+                 const unsigned char eph[X25519_BYTES],
+                 const unsigned char pub[X25519_BYTES]);
+
+int
+x25519_make_keypair(unsigned char* pub, unsigned char* priv);
+int
+x25519_shared_secret(unsigned char* shared, unsigned char* priv,
+                     unsigned char* pub);
+
+#endif /* __X25519_H__ */
diff --git a/nimble/include/nimble/hci_common.h b/nimble/include/nimble/hci_common.h
index 252b0339..9e21618c 100644
--- a/nimble/include/nimble/hci_common.h
+++ b/nimble/include/nimble/hci_common.h
@@ -27,202 +27,230 @@
 extern "C" {
 #endif
 
-#define BLE_HCI_MAX_DATA_LEN    (MYNEWT_VAL(BLE_TRANSPORT_EVT_SIZE) - \
-                                 sizeof(struct ble_hci_ev))
+#define BLE_HCI_MAX_DATA_LEN                                                   \
+    (MYNEWT_VAL(BLE_TRANSPORT_EVT_SIZE) - sizeof(struct ble_hci_ev))
 
 /* Generic command header */
-struct ble_hci_cmd {
+struct ble_hci_cmd
+{
     uint16_t opcode;
-    uint8_t  length;
-    uint8_t  data[0];
+    uint8_t length;
+    uint8_t data[0];
 } __attribute__((packed));
 
 /* Generic event header */
-struct ble_hci_ev {
+struct ble_hci_ev
+{
     uint8_t opcode;
     uint8_t length;
-    uint8_t  data[0];
+    uint8_t data[0];
 } __attribute__((packed));
 
-#define BLE_HCI_OPCODE_NOP                  (0)
+#define BLE_HCI_OPCODE_NOP (0)
 
 /* Set opcode based on OCF and OGF */
-#define BLE_HCI_OP(ogf, ocf)            ((ocf) | ((ogf) << 10))
+#define BLE_HCI_OP(ogf, ocf) ((ocf) | ((ogf) << 10))
 
 /* Get the OGF and OCF from the opcode in the command */
-#define BLE_HCI_OGF(opcode)                 (((opcode) >> 10) & 0x003F)
-#define BLE_HCI_OCF(opcode)                 ((opcode) & 0x03FF)
+#define BLE_HCI_OGF(opcode) (((opcode) >> 10) & 0x003F)
+#define BLE_HCI_OCF(opcode) ((opcode) & 0x03FF)
 
 /* Opcode Group definitions (note: 0x07 not defined in spec) */
-#define BLE_HCI_OGF_LINK_CTRL               (0x01)
-#define BLE_HCI_OGF_LINK_POLICY             (0x02)
-#define BLE_HCI_OGF_CTLR_BASEBAND           (0x03)
-#define BLE_HCI_OGF_INFO_PARAMS             (0x04)
-#define BLE_HCI_OGF_STATUS_PARAMS           (0x05)
-#define BLE_HCI_OGF_TESTING                 (0x06)
-#define BLE_HCI_OGF_LE                      (0x08)
-#define BLE_HCI_OGF_VENDOR                  (0x3F)
+#define BLE_HCI_OGF_LINK_CTRL (0x01)
+#define BLE_HCI_OGF_LINK_POLICY (0x02)
+#define BLE_HCI_OGF_CTLR_BASEBAND (0x03)
+#define BLE_HCI_OGF_INFO_PARAMS (0x04)
+#define BLE_HCI_OGF_STATUS_PARAMS (0x05)
+#define BLE_HCI_OGF_TESTING (0x06)
+#define BLE_HCI_OGF_LE (0x08)
+#define BLE_HCI_OGF_VENDOR (0x3F)
 
 /*
  * Number of LE commands. NOTE: this is really just used to size the array
  * containing the lengths of the LE commands.
  */
-#define BLE_HCI_NUM_LE_CMDS                 (79)
+#define BLE_HCI_NUM_LE_CMDS (79)
 
 /* List of OCF for Link Control commands (OGF=0x01) */
-#define BLE_HCI_OCF_DISCONNECT_CMD          (0x0006)
-struct ble_hci_lc_disconnect_cp {
+#define BLE_HCI_OCF_DISCONNECT_CMD (0x0006)
+struct ble_hci_lc_disconnect_cp
+{
     uint16_t conn_handle;
-    uint8_t  reason;
+    uint8_t reason;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_RD_REM_VER_INFO         (0x001D)
-struct ble_hci_rd_rem_ver_info_cp {
+#define BLE_HCI_OCF_RD_REM_VER_INFO (0x001D)
+struct ble_hci_rd_rem_ver_info_cp
+{
     uint16_t conn_handle;
 } __attribute__((packed));
 
 /* List of OCF for Controller and Baseband commands (OGF=0x03) */
-#define BLE_HCI_OCF_CB_SET_EVENT_MASK       (0x0001)
-struct ble_hci_cb_set_event_mask_cp {
+#define BLE_HCI_OCF_CB_SET_EVENT_MASK (0x0001)
+struct ble_hci_cb_set_event_mask_cp
+{
     uint64_t event_mask;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_CB_RESET                (0x0003)
+#define BLE_HCI_OCF_CB_RESET (0x0003)
 
-#define BLE_HCI_OCF_CB_READ_TX_PWR          (0x002D)
-struct ble_hci_cb_read_tx_pwr_cp {
+#define BLE_HCI_OCF_CB_READ_TX_PWR (0x002D)
+struct ble_hci_cb_read_tx_pwr_cp
+{
     uint16_t conn_handle;
-    uint8_t  type;
+    uint8_t type;
 } __attribute__((packed));
 
-struct ble_hci_cb_read_tx_pwr_rp {
+struct ble_hci_cb_read_tx_pwr_rp
+{
     uint16_t conn_handle;
-    int8_t   tx_level;
+    int8_t tx_level;
 } __attribute__((packed));
 
-
-#define BLE_HCI_OCF_CB_SET_CTLR_TO_HOST_FC  (0x0031)
-struct ble_hci_cb_ctlr_to_host_fc_cp {
+#define BLE_HCI_OCF_CB_SET_CTLR_TO_HOST_FC (0x0031)
+struct ble_hci_cb_ctlr_to_host_fc_cp
+{
     uint8_t enable;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_CB_HOST_BUF_SIZE        (0x0033)
-struct ble_hci_cb_host_buf_size_cp {
+#define BLE_HCI_OCF_CB_HOST_BUF_SIZE (0x0033)
+struct ble_hci_cb_host_buf_size_cp
+{
     uint16_t acl_data_len;
-    uint8_t  sco_data_len;
+    uint8_t sco_data_len;
     uint16_t acl_num;
     uint16_t sco_num;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_CB_HOST_NUM_COMP_PKTS   (0x0035)
-struct  ble_hci_cb_host_num_comp_pkts_entry {
+#define BLE_HCI_OCF_CB_HOST_NUM_COMP_PKTS (0x0035)
+struct ble_hci_cb_host_num_comp_pkts_entry
+{
     uint16_t handle;
     uint16_t count;
 } __attribute__((packed));
-struct ble_hci_cb_host_num_comp_pkts_cp {
+struct ble_hci_cb_host_num_comp_pkts_cp
+{
     uint8_t handles;
     struct ble_hci_cb_host_num_comp_pkts_entry h[0];
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_CB_SET_EVENT_MASK2      (0x0063)
-struct ble_hci_cb_set_event_mask2_cp {
+#define BLE_HCI_OCF_CB_SET_EVENT_MASK2 (0x0063)
+struct ble_hci_cb_set_event_mask2_cp
+{
     uint64_t event_mask2;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_CB_RD_AUTH_PYLD_TMO     (0x007B)
-struct ble_hci_cb_rd_auth_pyld_tmo_cp {
+#define BLE_HCI_OCF_CB_RD_AUTH_PYLD_TMO (0x007B)
+struct ble_hci_cb_rd_auth_pyld_tmo_cp
+{
     uint16_t conn_handle;
 } __attribute__((packed));
-struct ble_hci_cb_rd_auth_pyld_tmo_rp {
+struct ble_hci_cb_rd_auth_pyld_tmo_rp
+{
     uint16_t conn_handle;
     uint16_t tmo;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_CB_WR_AUTH_PYLD_TMO     (0x007C)
-struct ble_hci_cb_wr_auth_pyld_tmo_cp {
+#define BLE_HCI_OCF_CB_WR_AUTH_PYLD_TMO (0x007C)
+struct ble_hci_cb_wr_auth_pyld_tmo_cp
+{
     uint16_t conn_handle;
     uint16_t tmo;
 } __attribute__((packed));
-struct ble_hci_cb_wr_auth_pyld_tmo_rp {
+struct ble_hci_cb_wr_auth_pyld_tmo_rp
+{
     uint16_t conn_handle;
 } __attribute__((packed));
 
 /* List of OCF for Info Param commands (OGF=0x04) */
-#define BLE_HCI_OCF_IP_RD_LOCAL_VER         (0x0001)
-struct ble_hci_ip_rd_local_ver_rp {
-    uint8_t  hci_ver;
+#define BLE_HCI_OCF_IP_RD_LOCAL_VER (0x0001)
+struct ble_hci_ip_rd_local_ver_rp
+{
+    uint8_t hci_ver;
     uint16_t hci_rev;
-    uint8_t  lmp_ver;
+    uint8_t lmp_ver;
     uint16_t manufacturer;
     uint16_t lmp_subver;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_IP_RD_LOC_SUPP_CMD      (0x0002)
-struct ble_hci_ip_rd_loc_supp_cmd_rp {
+#define BLE_HCI_OCF_IP_RD_LOC_SUPP_CMD (0x0002)
+struct ble_hci_ip_rd_loc_supp_cmd_rp
+{
     uint8_t commands[64];
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_IP_RD_LOC_SUPP_FEAT     (0x0003)
-struct ble_hci_ip_rd_loc_supp_feat_rp {
+#define BLE_HCI_OCF_IP_RD_LOC_SUPP_FEAT (0x0003)
+struct ble_hci_ip_rd_loc_supp_feat_rp
+{
     uint64_t features;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_IP_RD_BUF_SIZE          (0x0005)
-struct ble_hci_ip_rd_buf_size_rp {
+#define BLE_HCI_OCF_IP_RD_BUF_SIZE (0x0005)
+struct ble_hci_ip_rd_buf_size_rp
+{
     uint16_t acl_data_len;
-    uint8_t  sco_data_len;
+    uint8_t sco_data_len;
     uint16_t acl_num;
     uint16_t sco_num;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_IP_RD_BD_ADDR           (0x0009)
-struct ble_hci_ip_rd_bd_addr_rp {
+#define BLE_HCI_OCF_IP_RD_BD_ADDR (0x0009)
+struct ble_hci_ip_rd_bd_addr_rp
+{
     uint8_t addr[6];
 } __attribute__((packed));
 
 /* List of OCF for Status parameters commands (OGF = 0x05) */
-#define BLE_HCI_OCF_RD_RSSI                 (0x0005)
-struct ble_hci_rd_rssi_cp {
+#define BLE_HCI_OCF_RD_RSSI (0x0005)
+struct ble_hci_rd_rssi_cp
+{
     uint16_t handle;
 } __attribute__((packed));
-struct ble_hci_rd_rssi_rp {
+struct ble_hci_rd_rssi_rp
+{
     uint16_t handle;
-    int8_t   rssi;
+    int8_t rssi;
 } __attribute__((packed));
 
 /* List of OCF for LE commands (OGF = 0x08) */
-#define BLE_HCI_OCF_LE_SET_EVENT_MASK               (0x0001)
-struct ble_hci_le_set_event_mask_cp {
+#define BLE_HCI_OCF_LE_SET_EVENT_MASK (0x0001)
+struct ble_hci_le_set_event_mask_cp
+{
     uint64_t event_mask;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_RD_BUF_SIZE                  (0x0002)
-struct ble_hci_le_rd_buf_size_rp {
+#define BLE_HCI_OCF_LE_RD_BUF_SIZE (0x0002)
+struct ble_hci_le_rd_buf_size_rp
+{
     uint16_t data_len;
-    uint8_t  data_packets;
+    uint8_t data_packets;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_RD_BUF_SIZE_V2                    (0x0060)
-struct ble_hci_le_rd_buf_size_v2_rp {
+#define BLE_HCI_OCF_LE_RD_BUF_SIZE_V2 (0x0060)
+struct ble_hci_le_rd_buf_size_v2_rp
+{
     uint16_t data_len;
-    uint8_t  data_packets;
+    uint8_t data_packets;
     uint16_t iso_data_len;
-    uint8_t  iso_data_packets;
+    uint8_t iso_data_packets;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_RD_LOC_SUPP_FEAT             (0x0003)
-struct ble_hci_le_rd_loc_supp_feat_rp {
+#define BLE_HCI_OCF_LE_RD_LOC_SUPP_FEAT (0x0003)
+struct ble_hci_le_rd_loc_supp_feat_rp
+{
     uint64_t features;
 } __attribute__((packed));
 
 /* NOTE: 0x0004 is intentionally left undefined */
-#define BLE_HCI_OCF_LE_SET_RAND_ADDR                (0x0005)
-struct ble_hci_le_set_rand_addr_cp {
+#define BLE_HCI_OCF_LE_SET_RAND_ADDR (0x0005)
+struct ble_hci_le_set_rand_addr_cp
+{
     uint8_t addr[6];
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_SET_ADV_PARAMS               (0x0006)
-struct ble_hci_le_set_adv_params_cp {
+#define BLE_HCI_OCF_LE_SET_ADV_PARAMS (0x0006)
+struct ble_hci_le_set_adv_params_cp
+{
     uint16_t min_interval;
     uint16_t max_interval;
     uint8_t type;
@@ -233,53 +261,60 @@ struct ble_hci_le_set_adv_params_cp {
     uint8_t filter_policy;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_RD_ADV_CHAN_TXPWR            (0x0007)
-struct ble_hci_le_rd_adv_chan_txpwr_rp {
+#define BLE_HCI_OCF_LE_RD_ADV_CHAN_TXPWR (0x0007)
+struct ble_hci_le_rd_adv_chan_txpwr_rp
+{
     int8_t power_level;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_SET_ADV_DATA                 (0x0008)
-#define BLE_HCI_MAX_ADV_DATA_LEN                    (31)
-struct ble_hci_le_set_adv_data_cp {
+#define BLE_HCI_OCF_LE_SET_ADV_DATA (0x0008)
+#define BLE_HCI_MAX_ADV_DATA_LEN (31)
+struct ble_hci_le_set_adv_data_cp
+{
     uint8_t adv_data_len;
     uint8_t adv_data[BLE_HCI_MAX_ADV_DATA_LEN];
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_SET_SCAN_RSP_DATA            (0x0009)
-#define BLE_HCI_MAX_SCAN_RSP_DATA_LEN               (31)
-struct ble_hci_le_set_scan_rsp_data_cp {
+#define BLE_HCI_OCF_LE_SET_SCAN_RSP_DATA (0x0009)
+#define BLE_HCI_MAX_SCAN_RSP_DATA_LEN (31)
+struct ble_hci_le_set_scan_rsp_data_cp
+{
     uint8_t scan_rsp_len;
     uint8_t scan_rsp[BLE_HCI_MAX_SCAN_RSP_DATA_LEN];
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_SET_ADV_ENABLE               (0x000A)
-struct ble_hci_le_set_adv_enable_cp {
+#define BLE_HCI_OCF_LE_SET_ADV_ENABLE (0x000A)
+struct ble_hci_le_set_adv_enable_cp
+{
     uint8_t enable;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_SET_SCAN_PARAMS              (0x000B)
-struct ble_hci_le_set_scan_params_cp {
-    uint8_t  scan_type;
+#define BLE_HCI_OCF_LE_SET_SCAN_PARAMS (0x000B)
+struct ble_hci_le_set_scan_params_cp
+{
+    uint8_t scan_type;
     uint16_t scan_itvl;
     uint16_t scan_window;
-    uint8_t  own_addr_type;
-    uint8_t  filter_policy;
+    uint8_t own_addr_type;
+    uint8_t filter_policy;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_SET_SCAN_ENABLE              (0x000C)
-struct ble_hci_le_set_scan_enable_cp {
+#define BLE_HCI_OCF_LE_SET_SCAN_ENABLE (0x000C)
+struct ble_hci_le_set_scan_enable_cp
+{
     uint8_t enable;
     uint8_t filter_duplicates;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_CREATE_CONN                  (0x000D)
-struct ble_hci_le_create_conn_cp {
+#define BLE_HCI_OCF_LE_CREATE_CONN (0x000D)
+struct ble_hci_le_create_conn_cp
+{
     uint16_t scan_itvl;
     uint16_t scan_window;
-    uint8_t  filter_policy;
-    uint8_t  peer_addr_type;
-    uint8_t  peer_addr[6];
-    uint8_t  own_addr_type;
+    uint8_t filter_policy;
+    uint8_t peer_addr_type;
+    uint8_t peer_addr[6];
+    uint8_t own_addr_type;
     uint16_t min_conn_itvl;
     uint16_t max_conn_itvl;
     uint16_t conn_latency;
@@ -288,29 +323,33 @@ struct ble_hci_le_create_conn_cp {
     uint16_t max_ce;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_CREATE_CONN_CANCEL           (0x000E)
+#define BLE_HCI_OCF_LE_CREATE_CONN_CANCEL (0x000E)
 
-#define BLE_HCI_OCF_LE_RD_WHITE_LIST_SIZE           (0x000F)
-struct ble_hci_le_rd_white_list_rp {
+#define BLE_HCI_OCF_LE_RD_WHITE_LIST_SIZE (0x000F)
+struct ble_hci_le_rd_white_list_rp
+{
     uint8_t size;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_CLEAR_WHITE_LIST             (0x0010)
+#define BLE_HCI_OCF_LE_CLEAR_WHITE_LIST (0x0010)
 
-#define BLE_HCI_OCF_LE_ADD_WHITE_LIST               (0x0011)
-struct ble_hci_le_add_whte_list_cp {
+#define BLE_HCI_OCF_LE_ADD_WHITE_LIST (0x0011)
+struct ble_hci_le_add_whte_list_cp
+{
     uint8_t addr_type;
     uint8_t addr[6];
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_RMV_WHITE_LIST               (0x0012)
-struct ble_hci_le_rmv_white_list_cp {
+#define BLE_HCI_OCF_LE_RMV_WHITE_LIST (0x0012)
+struct ble_hci_le_rmv_white_list_cp
+{
     uint8_t addr_type;
     uint8_t addr[6];
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_CONN_UPDATE                  (0x0013)
-struct ble_hci_le_conn_update_cp {
+#define BLE_HCI_OCF_LE_CONN_UPDATE (0x0013)
+struct ble_hci_le_conn_update_cp
+{
     uint16_t conn_handle;
     uint16_t conn_itvl_min;
     uint16_t conn_itvl_max;
@@ -320,82 +359,98 @@ struct ble_hci_le_conn_update_cp {
     uint16_t max_ce_len;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_SET_HOST_CHAN_CLASS          (0x0014)
-struct ble_hci_le_set_host_chan_class_cp {
+#define BLE_HCI_OCF_LE_SET_HOST_CHAN_CLASS (0x0014)
+struct ble_hci_le_set_host_chan_class_cp
+{
     uint8_t chan_map[5];
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_RD_CHAN_MAP                  (0x0015)
-struct ble_hci_le_rd_chan_map_cp {
+#define BLE_HCI_OCF_LE_RD_CHAN_MAP (0x0015)
+struct ble_hci_le_rd_chan_map_cp
+{
     uint16_t conn_handle;
 } __attribute__((packed));
-struct ble_hci_le_rd_chan_map_rp {
+struct ble_hci_le_rd_chan_map_rp
+{
     uint16_t conn_handle;
     uint8_t chan_map[5];
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_RD_REM_FEAT                  (0x0016)
-struct ble_hci_le_rd_rem_feat_cp {
+#define BLE_HCI_OCF_LE_RD_REM_FEAT (0x0016)
+struct ble_hci_le_rd_rem_feat_cp
+{
     uint16_t conn_handle;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_ENCRYPT                      (0x0017)
-struct ble_hci_le_encrypt_cp {
+#define BLE_HCI_OCF_LE_ENCRYPT (0x0017)
+struct ble_hci_le_encrypt_cp
+{
     uint8_t key[16];
     uint8_t data[16];
 } __attribute__((packed));
-struct ble_hci_le_encrypt_rp {
+struct ble_hci_le_encrypt_rp
+{
     uint8_t data[16];
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_RAND                         (0x0018)
-struct ble_hci_le_rand_rp {
+#define BLE_HCI_OCF_LE_RAND (0x0018)
+struct ble_hci_le_rand_rp
+{
     uint64_t random_number;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_START_ENCRYPT                (0x0019)
-struct ble_hci_le_start_encrypt_cp {
+#define BLE_HCI_OCF_LE_START_ENCRYPT (0x0019)
+struct ble_hci_le_start_encrypt_cp
+{
     uint16_t conn_handle;
     uint64_t rand;
     uint16_t div;
-    uint8_t  ltk[16];
+    uint8_t ltk[16];
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_LT_KEY_REQ_REPLY             (0x001A)
-struct ble_hci_le_lt_key_req_reply_cp {
+#define BLE_HCI_OCF_LE_LT_KEY_REQ_REPLY (0x001A)
+struct ble_hci_le_lt_key_req_reply_cp
+{
     uint16_t conn_handle;
-    uint8_t  ltk[16];
+    uint8_t ltk[16];
 } __attribute__((packed));
-struct ble_hci_le_lt_key_req_reply_rp {
+struct ble_hci_le_lt_key_req_reply_rp
+{
     uint16_t conn_handle;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_LT_KEY_REQ_NEG_REPLY         (0x001B)
-struct ble_hci_le_lt_key_req_neg_reply_cp {
+#define BLE_HCI_OCF_LE_LT_KEY_REQ_NEG_REPLY (0x001B)
+struct ble_hci_le_lt_key_req_neg_reply_cp
+{
     uint16_t conn_handle;
 } __attribute__((packed));
-struct ble_hci_le_lt_key_req_neg_reply_rp {
+struct ble_hci_le_lt_key_req_neg_reply_rp
+{
     uint16_t conn_handle;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_RD_SUPP_STATES               (0x001C)
-struct ble_hci_le_rd_supp_states_rp {
+#define BLE_HCI_OCF_LE_RD_SUPP_STATES (0x001C)
+struct ble_hci_le_rd_supp_states_rp
+{
     uint64_t states;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_RX_TEST                      (0x001D)
-struct ble_hci_le_rx_test_cp {
+#define BLE_HCI_OCF_LE_RX_TEST (0x001D)
+struct ble_hci_le_rx_test_cp
+{
     uint8_t rx_chan;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_TX_TEST                      (0x001E)
-struct ble_hci_le_tx_test_cp {
+#define BLE_HCI_OCF_LE_TX_TEST (0x001E)
+struct ble_hci_le_tx_test_cp
+{
     uint8_t tx_chan;
     uint8_t test_data_len;
     uint8_t payload;
 } __attribute__((packed));
 #if MYNEWT_VAL(BLE_LL_DTM_EXTENSIONS)
-struct ble_hci_le_tx_test_ext_cp {
+struct ble_hci_le_tx_test_ext_cp
+{
     uint8_t tx_chan;
     uint8_t test_data_len;
     uint8_t payload;
@@ -404,13 +459,15 @@ struct ble_hci_le_tx_test_ext_cp {
 } __attribute__((packed));
 #endif
 
-#define BLE_HCI_OCF_LE_TEST_END                     (0x001F)
-struct ble_hci_le_test_end_rp {
+#define BLE_HCI_OCF_LE_TEST_END (0x001F)
+struct ble_hci_le_test_end_rp
+{
     uint16_t num_packets;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_REM_CONN_PARAM_RR            (0x0020)
-struct ble_hci_le_rem_conn_param_rr_cp {
+#define BLE_HCI_OCF_LE_REM_CONN_PARAM_RR (0x0020)
+struct ble_hci_le_rem_conn_param_rr_cp
+{
     uint16_t conn_handle;
     uint16_t conn_itvl_min;
     uint16_t conn_itvl_max;
@@ -419,124 +476,146 @@ struct ble_hci_le_rem_conn_param_rr_cp {
     uint16_t min_ce;
     uint16_t max_ce;
 } __attribute__((packed));
-struct ble_hci_le_rem_conn_param_rr_rp {
+struct ble_hci_le_rem_conn_param_rr_rp
+{
     uint16_t conn_handle;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_REM_CONN_PARAM_NRR           (0x0021)
-struct ble_hci_le_rem_conn_params_nrr_cp {
+#define BLE_HCI_OCF_LE_REM_CONN_PARAM_NRR (0x0021)
+struct ble_hci_le_rem_conn_params_nrr_cp
+{
     uint16_t conn_handle;
-    uint8_t  reason;
+    uint8_t reason;
 } __attribute__((packed));
-struct ble_hci_le_rem_conn_params_nrr_rp {
+struct ble_hci_le_rem_conn_params_nrr_rp
+{
     uint16_t conn_handle;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_SET_DATA_LEN                 (0x0022)
-struct ble_hci_le_set_data_len_cp {
+#define BLE_HCI_OCF_LE_SET_DATA_LEN (0x0022)
+struct ble_hci_le_set_data_len_cp
+{
     uint16_t conn_handle;
     uint16_t tx_octets;
     uint16_t tx_time;
 } __attribute__((packed));
-struct ble_hci_le_set_data_len_rp {
+struct ble_hci_le_set_data_len_rp
+{
     uint16_t conn_handle;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_RD_SUGG_DEF_DATA_LEN         (0x0023)
-struct ble_hci_le_rd_sugg_def_data_len_rp {
+#define BLE_HCI_OCF_LE_RD_SUGG_DEF_DATA_LEN (0x0023)
+struct ble_hci_le_rd_sugg_def_data_len_rp
+{
     uint16_t max_tx_octets;
     uint16_t max_tx_time;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_WR_SUGG_DEF_DATA_LEN         (0x0024)
-struct ble_hci_le_wr_sugg_def_data_len_cp {
+#define BLE_HCI_OCF_LE_WR_SUGG_DEF_DATA_LEN (0x0024)
+struct ble_hci_le_wr_sugg_def_data_len_cp
+{
     uint16_t max_tx_octets;
     uint16_t max_tx_time;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_RD_P256_PUBKEY               (0x0025)
+#define BLE_HCI_OCF_LE_RD_P256_PUBKEY (0x0025)
 
-#define BLE_HCI_OCF_LE_GEN_DHKEY                    (0x0026)
-struct ble_hci_le_gen_dhkey_cp {
+#define BLE_HCI_OCF_LE_GEN_DHKEY (0x0026)
+struct ble_hci_le_gen_dhkey_cp
+{
     uint8_t pkey[64];
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_ADD_RESOLV_LIST              (0x0027)
-struct ble_hci_le_add_resolv_list_cp {
+#define BLE_HCI_OCF_LE_ADD_RESOLV_LIST (0x0027)
+struct ble_hci_le_add_resolv_list_cp
+{
     uint8_t peer_addr_type;
     uint8_t peer_id_addr[6];
     uint8_t peer_irk[16];
     uint8_t local_irk[16];
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_RMV_RESOLV_LIST              (0x0028)
-struct ble_hci_le_rmv_resolve_list_cp {
+#define BLE_HCI_OCF_LE_RMV_RESOLV_LIST (0x0028)
+struct ble_hci_le_rmv_resolve_list_cp
+{
     uint8_t peer_addr_type;
     uint8_t peer_id_addr[6];
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_CLR_RESOLV_LIST              (0x0029)
+#define BLE_HCI_OCF_LE_CLR_RESOLV_LIST (0x0029)
 
-#define BLE_HCI_OCF_LE_RD_RESOLV_LIST_SIZE          (0x002A)
-struct ble_hci_le_rd_resolv_list_size_rp {
+#define BLE_HCI_OCF_LE_RD_RESOLV_LIST_SIZE (0x002A)
+struct ble_hci_le_rd_resolv_list_size_rp
+{
     uint8_t size;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_RD_PEER_RESOLV_ADDR          (0x002B)
-struct ble_hci_le_rd_peer_resolv_addr_cp {
+#define BLE_HCI_OCF_LE_RD_PEER_RESOLV_ADDR (0x002B)
+struct ble_hci_le_rd_peer_resolv_addr_cp
+{
     uint8_t peer_addr_type;
     uint8_t peer_id_addr[6];
 } __attribute__((packed));
-struct ble_hci_le_rd_peer_resolv_addr_rp {
+struct ble_hci_le_rd_peer_resolv_addr_rp
+{
     uint8_t rpa[6];
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_RD_LOCAL_RESOLV_ADDR         (0x002C)
-struct ble_hci_le_rd_local_resolv_addr_cp {
+#define BLE_HCI_OCF_LE_RD_LOCAL_RESOLV_ADDR (0x002C)
+struct ble_hci_le_rd_local_resolv_addr_cp
+{
     uint8_t peer_addr_type;
     uint8_t peer_id_addr[6];
 } __attribute__((packed));
-struct ble_hci_le_rd_local_resolv_addr_rp {
+struct ble_hci_le_rd_local_resolv_addr_rp
+{
     uint8_t rpa[6];
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_SET_ADDR_RES_EN              (0x002D)
-struct ble_hci_le_set_addr_res_en_cp {
+#define BLE_HCI_OCF_LE_SET_ADDR_RES_EN (0x002D)
+struct ble_hci_le_set_addr_res_en_cp
+{
     uint8_t enable;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_SET_RPA_TMO                  (0x002E)
-struct ble_hci_le_set_rpa_tmo_cp {
+#define BLE_HCI_OCF_LE_SET_RPA_TMO (0x002E)
+struct ble_hci_le_set_rpa_tmo_cp
+{
     uint16_t rpa_timeout;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_RD_MAX_DATA_LEN              (0x002F)
-struct ble_hci_le_rd_max_data_len_rp {
+#define BLE_HCI_OCF_LE_RD_MAX_DATA_LEN (0x002F)
+struct ble_hci_le_rd_max_data_len_rp
+{
     uint16_t max_tx_octests;
     uint16_t max_tx_time;
     uint16_t max_rx_octests;
     uint16_t max_rx_time;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_RD_PHY                       (0x0030)
-struct ble_hci_le_rd_phy_cp {
+#define BLE_HCI_OCF_LE_RD_PHY (0x0030)
+struct ble_hci_le_rd_phy_cp
+{
     uint16_t conn_handle;
 } __attribute__((packed));
-struct ble_hci_le_rd_phy_rp {
+struct ble_hci_le_rd_phy_rp
+{
     uint16_t conn_handle;
     uint8_t tx_phy;
     uint8_t rx_phy;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_SET_DEFAULT_PHY              (0x0031)
-struct ble_hci_le_set_default_phy_cp {
+#define BLE_HCI_OCF_LE_SET_DEFAULT_PHY (0x0031)
+struct ble_hci_le_set_default_phy_cp
+{
     uint8_t all_phys;
     uint8_t tx_phys;
     uint8_t rx_phys;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_SET_PHY                      (0x0032)
-struct ble_hci_le_set_phy_cp {
+#define BLE_HCI_OCF_LE_SET_PHY (0x0032)
+struct ble_hci_le_set_phy_cp
+{
     uint16_t conn_handle;
     uint8_t all_phys;
     uint8_t tx_phys;
@@ -544,22 +623,25 @@ struct ble_hci_le_set_phy_cp {
     uint16_t phy_options;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_RX_TEST_V2                  (0x0033)
-struct ble_hci_le_rx_test_v2_cp {
+#define BLE_HCI_OCF_LE_RX_TEST_V2 (0x0033)
+struct ble_hci_le_rx_test_v2_cp
+{
     uint8_t rx_chan;
     uint8_t phy;
     uint8_t index;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_TX_TEST_V2                  (0x0034)
-struct ble_hci_le_tx_test_v2_cp {
+#define BLE_HCI_OCF_LE_TX_TEST_V2 (0x0034)
+struct ble_hci_le_tx_test_v2_cp
+{
     uint8_t tx_chan;
     uint8_t test_data_len;
     uint8_t payload;
     uint8_t phy;
 } __attribute__((packed));
 #if MYNEWT_VAL(BLE_LL_DTM_EXTENSIONS)
-struct ble_hci_le_tx_test_v2_ext_cp {
+struct ble_hci_le_tx_test_v2_ext_cp
+{
     uint8_t tx_chan;
     uint8_t test_data_len;
     uint8_t payload;
@@ -569,18 +651,20 @@ struct ble_hci_le_tx_test_v2_ext_cp {
 } __attribute__((packed));
 #endif
 
-#define BLE_HCI_OCF_LE_SET_ADV_SET_RND_ADDR         (0x0035)
-struct ble_hci_le_set_adv_set_rnd_addr_cp {
+#define BLE_HCI_OCF_LE_SET_ADV_SET_RND_ADDR (0x0035)
+struct ble_hci_le_set_adv_set_rnd_addr_cp
+{
     uint8_t adv_handle;
     uint8_t addr[6];
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_SET_EXT_ADV_PARAM            (0x0036)
-struct ble_hci_le_set_ext_adv_params_cp {
-    uint8_t  adv_handle;
+#define BLE_HCI_OCF_LE_SET_EXT_ADV_PARAM (0x0036)
+struct ble_hci_le_set_ext_adv_params_cp
+{
+    uint8_t adv_handle;
     uint16_t props;
-    uint8_t  pri_itvl_min[3];
-    uint8_t  pri_itvl_max[3];
+    uint8_t pri_itvl_min[3];
+    uint8_t pri_itvl_max[3];
     uint8_t pri_chan_map;
     uint8_t own_addr_type;
     uint8_t peer_addr_type;
@@ -594,12 +678,14 @@ struct ble_hci_le_set_ext_adv_params_cp {
     uint8_t scan_req_notif;
 } __attribute__((packed));
 
-struct ble_hci_le_set_ext_adv_params_rp {
-    int8_t  tx_power;
+struct ble_hci_le_set_ext_adv_params_rp
+{
+    int8_t tx_power;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_SET_EXT_ADV_DATA             (0x0037)
-struct ble_hci_le_set_ext_adv_data_cp {
+#define BLE_HCI_OCF_LE_SET_EXT_ADV_DATA (0x0037)
+struct ble_hci_le_set_ext_adv_data_cp
+{
     uint8_t adv_handle;
     uint8_t operation;
     uint8_t fragment_pref;
@@ -607,8 +693,9 @@ struct ble_hci_le_set_ext_adv_data_cp {
     uint8_t adv_data[0];
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_SET_EXT_SCAN_RSP_DATA        (0x0038)
-struct ble_hci_le_set_ext_scan_rsp_data_cp {
+#define BLE_HCI_OCF_LE_SET_EXT_SCAN_RSP_DATA (0x0038)
+struct ble_hci_le_set_ext_scan_rsp_data_cp
+{
     uint8_t adv_handle;
     uint8_t operation;
     uint8_t fragment_pref;
@@ -616,80 +703,92 @@ struct ble_hci_le_set_ext_scan_rsp_data_cp {
     uint8_t scan_rsp[0];
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_SET_EXT_ADV_ENABLE           (0x0039)
-struct adv_set {
+#define BLE_HCI_OCF_LE_SET_EXT_ADV_ENABLE (0x0039)
+struct adv_set
+{
     uint8_t adv_handle;
     uint16_t duration;
     uint8_t max_events;
 } __attribute__((packed));
-struct ble_hci_le_set_ext_adv_enable_cp {
+struct ble_hci_le_set_ext_adv_enable_cp
+{
     uint8_t enable;
     uint8_t num_sets;
     struct adv_set sets[0];
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_RD_MAX_ADV_DATA_LEN          (0x003A)
-struct ble_hci_le_rd_max_adv_data_len_rp {
+#define BLE_HCI_OCF_LE_RD_MAX_ADV_DATA_LEN (0x003A)
+struct ble_hci_le_rd_max_adv_data_len_rp
+{
     uint16_t max_adv_data_len;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_RD_NUM_OF_ADV_SETS           (0x003B)
-struct ble_hci_le_rd_num_of_adv_sets_rp {
+#define BLE_HCI_OCF_LE_RD_NUM_OF_ADV_SETS (0x003B)
+struct ble_hci_le_rd_num_of_adv_sets_rp
+{
     uint8_t num_sets;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_REMOVE_ADV_SET               (0x003C)
-struct ble_hci_le_remove_adv_set_cp {
+#define BLE_HCI_OCF_LE_REMOVE_ADV_SET (0x003C)
+struct ble_hci_le_remove_adv_set_cp
+{
     uint8_t adv_handle;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_CLEAR_ADV_SETS               (0x003D)
+#define BLE_HCI_OCF_LE_CLEAR_ADV_SETS (0x003D)
 
-#define BLE_HCI_OCF_LE_SET_PERIODIC_ADV_PARAMS      (0x003E)
-struct ble_hci_le_set_periodic_adv_params_cp {
+#define BLE_HCI_OCF_LE_SET_PERIODIC_ADV_PARAMS (0x003E)
+struct ble_hci_le_set_periodic_adv_params_cp
+{
     uint8_t adv_handle;
     uint16_t min_itvl;
     uint16_t max_itvl;
     uint16_t props;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_SET_PERIODIC_ADV_DATA        (0x003F)
-struct ble_hci_le_set_periodic_adv_data_cp {
+#define BLE_HCI_OCF_LE_SET_PERIODIC_ADV_DATA (0x003F)
+struct ble_hci_le_set_periodic_adv_data_cp
+{
     uint8_t adv_handle;
     uint8_t operation;
     uint8_t adv_data_len;
     uint8_t adv_data[0];
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_SET_PERIODIC_ADV_ENABLE      (0x0040)
-struct ble_hci_le_set_periodic_adv_enable_cp {
+#define BLE_HCI_OCF_LE_SET_PERIODIC_ADV_ENABLE (0x0040)
+struct ble_hci_le_set_periodic_adv_enable_cp
+{
     uint8_t enable;
     uint8_t adv_handle;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_SET_EXT_SCAN_PARAM           (0x0041)
-struct scan_params {
-    uint8_t  type;
+#define BLE_HCI_OCF_LE_SET_EXT_SCAN_PARAM (0x0041)
+struct scan_params
+{
+    uint8_t type;
     uint16_t itvl;
     uint16_t window;
 } __attribute__((packed));
-struct ble_hci_le_set_ext_scan_params_cp {
+struct ble_hci_le_set_ext_scan_params_cp
+{
     uint8_t own_addr_type;
     uint8_t filter_policy;
     uint8_t phys;
     struct scan_params scans[0];
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_SET_EXT_SCAN_ENABLE          (0x0042)
-struct ble_hci_le_set_ext_scan_enable_cp {
-    uint8_t  enable;
-    uint8_t  filter_dup;
+#define BLE_HCI_OCF_LE_SET_EXT_SCAN_ENABLE (0x0042)
+struct ble_hci_le_set_ext_scan_enable_cp
+{
+    uint8_t enable;
+    uint8_t filter_dup;
     uint16_t duration;
     uint16_t period;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_EXT_CREATE_CONN              (0x0043)
-struct conn_params {
+#define BLE_HCI_OCF_LE_EXT_CREATE_CONN (0x0043)
+struct conn_params
+{
     uint16_t scan_itvl;
     uint16_t scan_window;
     uint16_t conn_min_itvl;
@@ -699,7 +798,8 @@ struct conn_params {
     uint16_t min_ce;
     uint16_t max_ce;
 } __attribute__((packed));
-struct ble_hci_le_ext_create_conn_cp {
+struct ble_hci_le_ext_create_conn_cp
+{
     uint8_t filter_policy;
     uint8_t own_addr_type;
     uint8_t peer_addr_type;
@@ -708,147 +808,167 @@ struct ble_hci_le_ext_create_conn_cp {
     struct conn_params conn_params[0];
 } __attribute__((packed));
 
-#define BLE_HCI_LE_PERIODIC_ADV_CREATE_SYNC_OPT_FILTER      0x01
-#define BLE_HCI_LE_PERIODIC_ADV_CREATE_SYNC_OPT_DISABLED    0x02
-#define BLE_HCI_LE_PERIODIC_ADV_CREATE_SYNC_OPT_DUPLICATES  0x04
+#define BLE_HCI_LE_PERIODIC_ADV_CREATE_SYNC_OPT_FILTER 0x01
+#define BLE_HCI_LE_PERIODIC_ADV_CREATE_SYNC_OPT_DISABLED 0x02
+#define BLE_HCI_LE_PERIODIC_ADV_CREATE_SYNC_OPT_DUPLICATES 0x04
 
-#define BLE_HCI_OCF_LE_PERIODIC_ADV_CREATE_SYNC          (0x0044)
-struct ble_hci_le_periodic_adv_create_sync_cp {
-    uint8_t  options;
-    uint8_t  sid;
-    uint8_t  peer_addr_type;
-    uint8_t  peer_addr[6];
+#define BLE_HCI_OCF_LE_PERIODIC_ADV_CREATE_SYNC (0x0044)
+struct ble_hci_le_periodic_adv_create_sync_cp
+{
+    uint8_t options;
+    uint8_t sid;
+    uint8_t peer_addr_type;
+    uint8_t peer_addr[6];
     uint16_t skip;
     uint16_t sync_timeout;
-    uint8_t  sync_cte_type;
+    uint8_t sync_cte_type;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_PERIODIC_ADV_CREATE_SYNC_CANCEL   (0x0045)
+#define BLE_HCI_OCF_LE_PERIODIC_ADV_CREATE_SYNC_CANCEL (0x0045)
 
-#define BLE_HCI_OCF_LE_PERIODIC_ADV_TERM_SYNC            (0x0046)
-struct ble_hci_le_periodic_adv_term_sync_cp {
+#define BLE_HCI_OCF_LE_PERIODIC_ADV_TERM_SYNC (0x0046)
+struct ble_hci_le_periodic_adv_term_sync_cp
+{
     uint16_t sync_handle;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_ADD_DEV_TO_PERIODIC_ADV_LIST      (0x0047)
-struct ble_hci_le_add_dev_to_periodic_adv_list_cp {
+#define BLE_HCI_OCF_LE_ADD_DEV_TO_PERIODIC_ADV_LIST (0x0047)
+struct ble_hci_le_add_dev_to_periodic_adv_list_cp
+{
     uint8_t peer_addr_type;
     uint8_t peer_addr[6];
     uint8_t sid;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_REM_DEV_FROM_PERIODIC_ADV_LIST    (0x0048)
-struct ble_hci_le_rem_dev_from_periodic_adv_list_cp {
+#define BLE_HCI_OCF_LE_REM_DEV_FROM_PERIODIC_ADV_LIST (0x0048)
+struct ble_hci_le_rem_dev_from_periodic_adv_list_cp
+{
     uint8_t peer_addr_type;
     uint8_t peer_addr[6];
     uint8_t sid;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_CLEAR_PERIODIC_ADV_LIST           (0x0049)
+#define BLE_HCI_OCF_LE_CLEAR_PERIODIC_ADV_LIST (0x0049)
 
-#define BLE_HCI_OCF_LE_RD_PERIODIC_ADV_LIST_SIZE         (0x004A)
-struct ble_hci_le_rd_periodic_adv_list_size_rp {
+#define BLE_HCI_OCF_LE_RD_PERIODIC_ADV_LIST_SIZE (0x004A)
+struct ble_hci_le_rd_periodic_adv_list_size_rp
+{
     uint8_t list_size;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_RD_TRANSMIT_POWER            (0x004B)
-struct ble_hci_le_rd_transmit_power_rp {
+#define BLE_HCI_OCF_LE_RD_TRANSMIT_POWER (0x004B)
+struct ble_hci_le_rd_transmit_power_rp
+{
     int8_t min_tx_power;
     int8_t max_tx_power;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_RD_RF_PATH_COMPENSATION      (0x004C)
-struct ble_hci_le_rd_rf_path_compensation_rp {
+#define BLE_HCI_OCF_LE_RD_RF_PATH_COMPENSATION (0x004C)
+struct ble_hci_le_rd_rf_path_compensation_rp
+{
     int16_t tx_path_compensation;
     int16_t rx_path_compensation;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_WR_RF_PATH_COMPENSATION      (0x004D)
-struct ble_hci_le_wr_rf_path_compensation_cp {
+#define BLE_HCI_OCF_LE_WR_RF_PATH_COMPENSATION (0x004D)
+struct ble_hci_le_wr_rf_path_compensation_cp
+{
     int16_t tx_path_compensation;
     int16_t rx_path_compensation;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_SET_PRIVACY_MODE             (0x004E)
-struct ble_hci_le_set_privacy_mode_cp {
+#define BLE_HCI_OCF_LE_SET_PRIVACY_MODE (0x004E)
+struct ble_hci_le_set_privacy_mode_cp
+{
     uint8_t peer_id_addr_type;
     uint8_t peer_id_addr[6];
     uint8_t mode;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_RX_TEST_V3                        (0x004F)
-#define BLE_HCI_OCF_LE_TX_TEST_V3                        (0x0050)
-#define BLE_HCI_OCF_LE_SET_CONNLESS_CTE_TX_PARAMS        (0x0051)
-#define BLE_HCI_OCF_LE_SET_CONNLESS_CTE_TX_ENABLE        (0x0052)
-#define BLE_HCI_OCF_LE_SET_CONNLESS_IQ_SAMPLING_ENABLE   (0x0053)
-#define BLE_HCI_OCF_LE_SET_CONN_CTE_RX_PARAMS            (0x0054)
-#define BLE_HCI_OCF_LE_SET_CONN_CTE_TX_PARAMS            (0x0055)
-#define BLE_HCI_OCF_LE_SET_CONN_CTE_REQ_ENABLE           (0x0056)
-#define BLE_HCI_OCF_LE_SET_CONN_CTE_RESP_ENABLE          (0x0057)
-#define BLE_HCI_OCF_LE_RD_ANTENNA_INFO                   (0x0058)
+#define BLE_HCI_OCF_LE_RX_TEST_V3 (0x004F)
+#define BLE_HCI_OCF_LE_TX_TEST_V3 (0x0050)
+#define BLE_HCI_OCF_LE_SET_CONNLESS_CTE_TX_PARAMS (0x0051)
+#define BLE_HCI_OCF_LE_SET_CONNLESS_CTE_TX_ENABLE (0x0052)
+#define BLE_HCI_OCF_LE_SET_CONNLESS_IQ_SAMPLING_ENABLE (0x0053)
+#define BLE_HCI_OCF_LE_SET_CONN_CTE_RX_PARAMS (0x0054)
+#define BLE_HCI_OCF_LE_SET_CONN_CTE_TX_PARAMS (0x0055)
+#define BLE_HCI_OCF_LE_SET_CONN_CTE_REQ_ENABLE (0x0056)
+#define BLE_HCI_OCF_LE_SET_CONN_CTE_RESP_ENABLE (0x0057)
+#define BLE_HCI_OCF_LE_RD_ANTENNA_INFO (0x0058)
 
-#define BLE_HCI_OCF_LE_PERIODIC_ADV_RECEIVE_ENABLE       (0x0059)
-struct ble_hci_le_periodic_adv_receive_enable_cp {
+#define BLE_HCI_OCF_LE_PERIODIC_ADV_RECEIVE_ENABLE (0x0059)
+struct ble_hci_le_periodic_adv_receive_enable_cp
+{
     uint16_t sync_handle;
     uint8_t enable;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_PERIODIC_ADV_SYNC_TRANSFER        (0x005A)
-struct ble_hci_le_periodic_adv_sync_transfer_cp {
+#define BLE_HCI_OCF_LE_PERIODIC_ADV_SYNC_TRANSFER (0x005A)
+struct ble_hci_le_periodic_adv_sync_transfer_cp
+{
     uint16_t conn_handle;
     uint16_t service_data;
     uint16_t sync_handle;
 } __attribute__((packed));
-struct ble_hci_le_periodic_adv_sync_transfer_rp {
+struct ble_hci_le_periodic_adv_sync_transfer_rp
+{
     uint16_t conn_handle;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_PERIODIC_ADV_SET_INFO_TRANSFER    (0x005B)
-struct ble_hci_le_periodic_adv_set_info_transfer_cp {
+#define BLE_HCI_OCF_LE_PERIODIC_ADV_SET_INFO_TRANSFER (0x005B)
+struct ble_hci_le_periodic_adv_set_info_transfer_cp
+{
     uint16_t conn_handle;
     uint16_t service_data;
     uint8_t adv_handle;
 } __attribute__((packed));
-struct ble_hci_le_periodic_adv_set_info_transfer_rp {
+struct ble_hci_le_periodic_adv_set_info_transfer_rp
+{
     uint16_t conn_handle;
 } __attribute__((packed));
 
 #define BLE_HCI_OCF_LE_PERIODIC_ADV_SYNC_TRANSFER_PARAMS (0x005C)
-struct ble_hci_le_periodic_adv_sync_transfer_params_cp {
+struct ble_hci_le_periodic_adv_sync_transfer_params_cp
+{
     uint16_t conn_handle;
-    uint8_t  mode;
+    uint8_t mode;
     uint16_t skip;
     uint16_t sync_timeout;
-    uint8_t  sync_cte_type;
+    uint8_t sync_cte_type;
 } __attribute__((packed));
-struct ble_hci_le_periodic_adv_sync_transfer_params_rp {
+struct ble_hci_le_periodic_adv_sync_transfer_params_rp
+{
     uint16_t conn_handle;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_SET_DEFAULT_SYNC_TRANSFER_PARAMS  (0x005D)
-struct ble_hci_le_set_default_periodic_sync_transfer_params_cp {
-    uint8_t  mode;
+#define BLE_HCI_OCF_LE_SET_DEFAULT_SYNC_TRANSFER_PARAMS (0x005D)
+struct ble_hci_le_set_default_periodic_sync_transfer_params_cp
+{
+    uint8_t mode;
     uint16_t skip;
     uint16_t sync_timeout;
-    uint8_t  sync_cte_type;
+    uint8_t sync_cte_type;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_GENERATE_DHKEY_V2                 (0x005E)
-#define BLE_HCI_OCF_LE_MODIFY_SCA                        (0x005F)
+#define BLE_HCI_OCF_LE_GENERATE_DHKEY_V2 (0x005E)
+#define BLE_HCI_OCF_LE_MODIFY_SCA (0x005F)
 
-#define BLE_HCI_OCF_LE_READ_ISO_TX_SYNC                  (0x0061)
-struct ble_hci_le_read_iso_tx_sync_cp {
+#define BLE_HCI_OCF_LE_READ_ISO_TX_SYNC (0x0061)
+struct ble_hci_le_read_iso_tx_sync_cp
+{
     uint16_t conn_handle;
 } __attribute__((packed));
-struct ble_hci_le_read_iso_tx_sync_rp {
+struct ble_hci_le_read_iso_tx_sync_rp
+{
     uint16_t conn_handle;
     uint16_t packet_seq_num;
     uint32_t tx_timestamp;
     uint8_t time_offset[3];
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_SET_CIG_PARAMS                    (0x0062)
-struct ble_hci_le_cis_params {
+#define BLE_HCI_OCF_LE_SET_CIG_PARAMS (0x0062)
+struct ble_hci_le_cis_params
+{
     uint8_t cis_id;
     uint16_t max_sdu_c_to_p;
     uint16_t max_sdu_p_to_c;
@@ -857,7 +977,8 @@ struct ble_hci_le_cis_params {
     uint8_t rnt_c_to_p;
     uint8_t rnt_p_to_c;
 } __attribute__((packed));
-struct ble_hci_le_set_cig_params_cp {
+struct ble_hci_le_set_cig_params_cp
+{
     uint8_t cig_id;
     uint8_t sdu_interval_c_to_p[3];
     uint8_t sdu_interval_p_to_c[3];
@@ -869,14 +990,16 @@ struct ble_hci_le_set_cig_params_cp {
     uint8_t cis_count;
     struct ble_hci_le_cis_params cis[0];
 } __attribute__((packed));
-struct ble_hci_le_set_cig_params_rp {
+struct ble_hci_le_set_cig_params_rp
+{
     uint8_t cig_id;
     uint8_t cis_count;
     uint16_t conn_handle[0];
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_SET_CIG_PARAMS_TEST               (0x0063)
-struct ble_hci_le_cis_params_test {
+#define BLE_HCI_OCF_LE_SET_CIG_PARAMS_TEST (0x0063)
+struct ble_hci_le_cis_params_test
+{
     uint8_t cis_id;
     uint8_t nse;
     uint16_t max_sdu_c_to_p;
@@ -888,7 +1011,8 @@ struct ble_hci_le_cis_params_test {
     uint8_t bn_c_to_p;
     uint8_t bn_p_to_c;
 } __attribute__((packed));
-struct ble_hci_le_set_cig_params_test_cp {
+struct ble_hci_le_set_cig_params_test_cp
+{
     uint8_t cig_id;
     uint8_t sdu_interval_c_to_p[3];
     uint8_t sdu_interval_p_to_c[3];
@@ -901,46 +1025,55 @@ struct ble_hci_le_set_cig_params_test_cp {
     uint8_t cis_count;
     struct ble_hci_le_cis_params_test cis[0];
 } __attribute__((packed));
-struct ble_hci_le_set_cig_params_test_rp {
+struct ble_hci_le_set_cig_params_test_rp
+{
     uint8_t cig_id;
     uint8_t cis_count;
     uint16_t conn_handle[0];
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_CREATE_CIS                        (0x0064)
-struct ble_hci_le_create_cis_params {
+#define BLE_HCI_OCF_LE_CREATE_CIS (0x0064)
+struct ble_hci_le_create_cis_params
+{
     uint16_t cis_handle;
     uint16_t conn_handle;
 } __attribute__((packed));
-struct ble_hci_le_create_cis_cp {
+struct ble_hci_le_create_cis_cp
+{
     uint8_t cis_count;
     struct ble_hci_le_create_cis_params cis[0];
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_REMOVE_CIG                        (0x0065)
-struct ble_hci_le_remove_cig_cp {
+#define BLE_HCI_OCF_LE_REMOVE_CIG (0x0065)
+struct ble_hci_le_remove_cig_cp
+{
     uint8_t cig_id;
 } __attribute__((packed));
-struct ble_hci_le_remove_cig_rp {
+struct ble_hci_le_remove_cig_rp
+{
     uint8_t cig_id;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_ACCEPT_CIS_REQ                    (0x0066)
-struct ble_hci_le_accept_cis_request_cp {
+#define BLE_HCI_OCF_LE_ACCEPT_CIS_REQ (0x0066)
+struct ble_hci_le_accept_cis_request_cp
+{
     uint16_t conn_handle;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_REJECT_CIS_REQ                    (0x0067)
-struct ble_hci_le_reject_cis_request_cp {
+#define BLE_HCI_OCF_LE_REJECT_CIS_REQ (0x0067)
+struct ble_hci_le_reject_cis_request_cp
+{
     uint16_t conn_handle;
     uint8_t reason;
 } __attribute__((packed));
-struct ble_hci_le_reject_cis_request_rp {
+struct ble_hci_le_reject_cis_request_rp
+{
     uint16_t conn_handle;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_CREATE_BIG                        (0x0068)
-struct ble_hci_le_create_big_cp {
+#define BLE_HCI_OCF_LE_CREATE_BIG (0x0068)
+struct ble_hci_le_create_big_cp
+{
     uint8_t big_handle;
     uint8_t adv_handle;
     uint8_t num_bis;
@@ -955,8 +1088,9 @@ struct ble_hci_le_create_big_cp {
     uint8_t broadcast_code[16];
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_CREATE_BIG_TEST                   (0x0069)
-struct ble_hci_le_create_big_test_cp {
+#define BLE_HCI_OCF_LE_CREATE_BIG_TEST (0x0069)
+struct ble_hci_le_create_big_test_cp
+{
     uint8_t big_handle;
     uint8_t adv_handle;
     uint8_t num_bis;
@@ -975,14 +1109,16 @@ struct ble_hci_le_create_big_test_cp {
     uint8_t broadcast_code[16];
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_TERMINATE_BIG                     (0x006a)
-struct ble_hci_le_terminate_big_cp {
+#define BLE_HCI_OCF_LE_TERMINATE_BIG (0x006a)
+struct ble_hci_le_terminate_big_cp
+{
     uint8_t big_handle;
     uint8_t reason;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_BIG_CREATE_SYNC                   (0x006b)
-struct ble_hci_le_big_create_sync_cp {
+#define BLE_HCI_OCF_LE_BIG_CREATE_SYNC (0x006b)
+struct ble_hci_le_big_create_sync_cp
+{
     uint8_t big_handle;
     uint16_t sync_handle;
     uint8_t encryption;
@@ -993,21 +1129,25 @@ struct ble_hci_le_big_create_sync_cp {
     uint8_t bis[0];
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_BIG_TERMINATE_SYNC                (0x006c)
-struct ble_hci_le_big_terminate_sync_cp {
+#define BLE_HCI_OCF_LE_BIG_TERMINATE_SYNC (0x006c)
+struct ble_hci_le_big_terminate_sync_cp
+{
     uint8_t big_handle;
 } __attribute__((packed));
-struct ble_hci_le_big_terminate_sync_rp {
+struct ble_hci_le_big_terminate_sync_rp
+{
     uint8_t big_handle;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_REQ_PEER_SCA                      (0x006d)
-struct ble_hci_le_request_peer_sca_cp {
+#define BLE_HCI_OCF_LE_REQ_PEER_SCA (0x006d)
+struct ble_hci_le_request_peer_sca_cp
+{
     uint16_t conn_handle;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_SETUP_ISO_DATA_PATH               (0x006e)
-struct ble_hci_le_setup_iso_data_path_cp {
+#define BLE_HCI_OCF_LE_SETUP_ISO_DATA_PATH (0x006e)
+struct ble_hci_le_setup_iso_data_path_cp
+{
     uint16_t conn_handle;
     uint8_t data_path_dir;
     uint8_t data_path_id;
@@ -1016,70 +1156,84 @@ struct ble_hci_le_setup_iso_data_path_cp {
     uint8_t codec_config_len;
     uint8_t codec_config[0];
 } __attribute__((packed));
-struct ble_hci_le_setup_iso_data_path_rp {
+struct ble_hci_le_setup_iso_data_path_rp
+{
     uint16_t conn_handle;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_REMOVE_ISO_DATA_PATH              (0x006f)
-struct ble_hci_le_remove_iso_data_path_cp {
+#define BLE_HCI_OCF_LE_REMOVE_ISO_DATA_PATH (0x006f)
+struct ble_hci_le_remove_iso_data_path_cp
+{
     uint16_t conn_handle;
     uint8_t data_path_dir;
 } __attribute__((packed));
-struct ble_hci_le_remove_iso_data_path_rp {
+struct ble_hci_le_remove_iso_data_path_rp
+{
     uint16_t conn_handle;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_ISO_TRANSMIT_TEST                 (0x0070)
-struct ble_hci_le_iso_transmit_test_cp {
+#define BLE_HCI_OCF_LE_ISO_TRANSMIT_TEST (0x0070)
+struct ble_hci_le_iso_transmit_test_cp
+{
     uint16_t conn_handle;
     uint8_t payload_type;
 } __attribute__((packed));
-struct ble_hci_le_iso_transmit_test_rp {
+struct ble_hci_le_iso_transmit_test_rp
+{
     uint16_t conn_handle;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_ISO_RECEIVE_TEST                  (0x0071)
-struct ble_hci_le_iso_receive_test_cp {
+#define BLE_HCI_OCF_LE_ISO_RECEIVE_TEST (0x0071)
+struct ble_hci_le_iso_receive_test_cp
+{
     uint16_t conn_handle;
     uint8_t payload_type;
 } __attribute__((packed));
-struct ble_hci_le_iso_receive_test_rp {
+struct ble_hci_le_iso_receive_test_rp
+{
     uint16_t conn_handle;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_ISO_READ_TEST_COUNTERS            (0x0072)
-struct ble_hci_le_iso_read_test_counters_cp {
+#define BLE_HCI_OCF_LE_ISO_READ_TEST_COUNTERS (0x0072)
+struct ble_hci_le_iso_read_test_counters_cp
+{
     uint16_t conn_handle;
 } __attribute__((packed));
-struct ble_hci_le_iso_read_test_counters_rp {
+struct ble_hci_le_iso_read_test_counters_rp
+{
     uint16_t conn_handle;
     uint32_t received_sdu_count;
     uint32_t missed_sdu_count;
     uint32_t failed_sdu_count;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_ISO_TEST_END                      (0x0073)
-struct ble_hci_le_iso_test_end_cp {
+#define BLE_HCI_OCF_LE_ISO_TEST_END (0x0073)
+struct ble_hci_le_iso_test_end_cp
+{
     uint16_t conn_handle;
 } __attribute__((packed));
-struct ble_hci_le_iso_test_end_rp {
+struct ble_hci_le_iso_test_end_rp
+{
     uint16_t conn_handle;
     uint32_t received_sdu_count;
     uint32_t missed_sdu_count;
     uint32_t failed_sdu_count;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_SET_HOST_FEATURE                  (0x0074)
-struct ble_hci_le_set_host_feature_cp {
+#define BLE_HCI_OCF_LE_SET_HOST_FEATURE (0x0074)
+struct ble_hci_le_set_host_feature_cp
+{
     uint8_t bit_num;
     uint8_t bit_val;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_READ_ISO_LINK_QUALITY             (0x0075)
-struct ble_hci_le_read_iso_link_quality_cp {
+#define BLE_HCI_OCF_LE_READ_ISO_LINK_QUALITY (0x0075)
+struct ble_hci_le_read_iso_link_quality_cp
+{
     uint16_t conn_handle;
 } __attribute__((packed));
-struct ble_hci_le_read_iso_link_quality_rp {
+struct ble_hci_le_read_iso_link_quality_rp
+{
     uint16_t conn_handle;
     uint32_t tx_unacked_pkts;
     uint32_t tx_flushed_pkts;
@@ -1090,26 +1244,30 @@ struct ble_hci_le_read_iso_link_quality_rp {
     uint32_t duplicate_pkts;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_ENH_READ_TRANSMIT_POWER_LEVEL     (0x0076)
-struct ble_hci_le_enh_read_transmit_power_level_cp {
+#define BLE_HCI_OCF_LE_ENH_READ_TRANSMIT_POWER_LEVEL (0x0076)
+struct ble_hci_le_enh_read_transmit_power_level_cp
+{
     uint16_t conn_handle;
     uint8_t phy;
 } __attribute__((packed));
-struct ble_hci_le_enh_read_transmit_power_level_rp {
+struct ble_hci_le_enh_read_transmit_power_level_rp
+{
     uint16_t conn_handle;
     uint8_t phy;
     uint8_t curr_tx_power_level;
     uint8_t max_tx_power_level;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_READ_REMOTE_TRANSMIT_POWER_LEVEL  (0x0077)
-struct ble_hci_le_read_remote_transmit_power_level_cp {
+#define BLE_HCI_OCF_LE_READ_REMOTE_TRANSMIT_POWER_LEVEL (0x0077)
+struct ble_hci_le_read_remote_transmit_power_level_cp
+{
     uint16_t conn_handle;
     uint8_t phy;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_SET_PATH_LOSS_REPORT_PARAM        (0x0078)
-struct ble_hci_le_set_path_loss_report_param_cp {
+#define BLE_HCI_OCF_LE_SET_PATH_LOSS_REPORT_PARAM (0x0078)
+struct ble_hci_le_set_path_loss_report_param_cp
+{
     uint16_t conn_handle;
     uint8_t high_threshold;
     uint8_t high_hysteresis;
@@ -1118,21 +1276,24 @@ struct ble_hci_le_set_path_loss_report_param_cp {
     uint16_t min_time_spent;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_SET_PATH_LOSS_REPORT_ENABLE       (0x0079)
-struct ble_hci_le_set_path_loss_report_enable_cp {
+#define BLE_HCI_OCF_LE_SET_PATH_LOSS_REPORT_ENABLE (0x0079)
+struct ble_hci_le_set_path_loss_report_enable_cp
+{
     uint16_t conn_handle;
     uint8_t enable;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_SET_TRANS_PWR_REPORT_ENABLE       (0x007A)
-struct ble_hci_le_set_transmit_power_report_enable_cp {
+#define BLE_HCI_OCF_LE_SET_TRANS_PWR_REPORT_ENABLE (0x007A)
+struct ble_hci_le_set_transmit_power_report_enable_cp
+{
     uint16_t conn_handle;
     uint8_t local_enable;
     uint8_t remote_enable;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_SET_DEFAULT_SUBRATE               (0x007D)
-struct ble_hci_le_set_default_subrate_cp {
+#define BLE_HCI_OCF_LE_SET_DEFAULT_SUBRATE (0x007D)
+struct ble_hci_le_set_default_subrate_cp
+{
     uint16_t subrate_min;
     uint16_t subrate_max;
     uint16_t max_latency;
@@ -1140,8 +1301,9 @@ struct ble_hci_le_set_default_subrate_cp {
     uint16_t supervision_tmo;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_SUBRATE_REQ                       (0x007E)
-struct ble_hci_le_subrate_req_cp {
+#define BLE_HCI_OCF_LE_SUBRATE_REQ (0x007E)
+struct ble_hci_le_subrate_req_cp
+{
     uint16_t conn_handle;
     uint16_t subrate_min;
     uint16_t subrate_max;
@@ -1150,15 +1312,17 @@ struct ble_hci_le_subrate_req_cp {
     uint16_t supervision_tmo;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_SET_EXT_ADV_PARAM_V2             (0x007F)
-struct ble_hci_le_set_ext_adv_params_v2_cp {
+#define BLE_HCI_OCF_LE_SET_EXT_ADV_PARAM_V2 (0x007F)
+struct ble_hci_le_set_ext_adv_params_v2_cp
+{
     struct ble_hci_le_set_ext_adv_params_cp params_v1;
     uint8_t pri_phy_opt;
     uint8_t sec_phy_opt;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_CS_RD_LOC_SUPP_CAP                (0x0089)
-struct ble_hci_le_cs_rd_loc_supp_cap_rp {
+#define BLE_HCI_OCF_LE_CS_RD_LOC_SUPP_CAP (0x0089)
+struct ble_hci_le_cs_rd_loc_supp_cap_rp
+{
     uint8_t num_config_supported;
     uint16_t max_consecutive_procedures_supported;
     uint8_t num_antennas_supported;
@@ -1180,13 +1344,15 @@ struct ble_hci_le_cs_rd_loc_supp_cap_rp {
     uint8_t t_sw_time_supported;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_CS_RD_REM_SUPP_CAP                (0x008A)
-struct ble_hci_le_cs_rd_rem_supp_cap_cp {
+#define BLE_HCI_OCF_LE_CS_RD_REM_SUPP_CAP (0x008A)
+struct ble_hci_le_cs_rd_rem_supp_cap_cp
+{
     uint16_t conn_handle;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_CS_WR_CACHED_REM_SUPP_CAP         (0x008B)
-struct ble_hci_le_cs_wr_cached_rem_supp_cap_cp {
+#define BLE_HCI_OCF_LE_CS_WR_CACHED_REM_SUPP_CAP (0x008B)
+struct ble_hci_le_cs_wr_cached_rem_supp_cap_cp
+{
     uint16_t conn_handle;
     uint8_t num_config_supported;
     uint16_t max_consecutive_procedures_supported;
@@ -1208,42 +1374,50 @@ struct ble_hci_le_cs_wr_cached_rem_supp_cap_cp {
     uint16_t optional_t_pm_times_supported;
     uint8_t t_sw_time_supported;
 } __attribute__((packed));
-struct ble_hci_le_cs_wr_cached_rem_supp_cap_rp {
+struct ble_hci_le_cs_wr_cached_rem_supp_cap_rp
+{
     uint16_t conn_handle;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_CS_SEC_ENABLE                     (0x008C)
-struct ble_hci_le_cs_sec_enable_cp {
+#define BLE_HCI_OCF_LE_CS_SEC_ENABLE (0x008C)
+struct ble_hci_le_cs_sec_enable_cp
+{
     uint16_t conn_handle;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_CS_SET_DEF_SETTINGS               (0x008D)
-struct ble_hci_le_cs_set_def_settings_cp {
+#define BLE_HCI_OCF_LE_CS_SET_DEF_SETTINGS (0x008D)
+struct ble_hci_le_cs_set_def_settings_cp
+{
     uint16_t conn_handle;
     uint8_t role_enable;
     uint8_t cs_sync_antenna_selection;
     uint8_t max_tx_power;
 } __attribute__((packed));
-struct ble_hci_le_cs_set_def_settings_rp {
+struct ble_hci_le_cs_set_def_settings_rp
+{
     uint16_t conn_handle;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_CS_RD_REM_FAE                     (0x008E)
-struct ble_hci_le_cs_rd_rem_fae_cp {
+#define BLE_HCI_OCF_LE_CS_RD_REM_FAE (0x008E)
+struct ble_hci_le_cs_rd_rem_fae_cp
+{
     uint16_t conn_handle;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_CS_WR_CACHED_REM_FAE              (0x008F)
-struct ble_hci_le_cs_wr_cached_rem_fae_cp {
+#define BLE_HCI_OCF_LE_CS_WR_CACHED_REM_FAE (0x008F)
+struct ble_hci_le_cs_wr_cached_rem_fae_cp
+{
     uint16_t conn_handle;
     uint8_t remote_fae_table[72];
 } __attribute__((packed));
-struct ble_hci_le_cs_wr_cached_rem_fae_rp {
+struct ble_hci_le_cs_wr_cached_rem_fae_rp
+{
     uint16_t conn_handle;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_CS_CREATE_CONFIG                  (0x0090)
-struct ble_hci_le_cs_create_config_cp {
+#define BLE_HCI_OCF_LE_CS_CREATE_CONFIG (0x0090)
+struct ble_hci_le_cs_create_config_cp
+{
     uint16_t conn_handle;
     uint8_t config_id;
     uint8_t create_context;
@@ -1264,19 +1438,22 @@ struct ble_hci_le_cs_create_config_cp {
     uint8_t companion_signal_enable;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_CS_REMOVE_CONFIG                  (0x0091)
-struct ble_hci_le_cs_remove_config_cp {
+#define BLE_HCI_OCF_LE_CS_REMOVE_CONFIG (0x0091)
+struct ble_hci_le_cs_remove_config_cp
+{
     uint16_t conn_handle;
     uint8_t config_id;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_CS_SET_CHAN_CLASS                 (0x0092)
-struct ble_hci_le_cs_set_chan_class_cp {
+#define BLE_HCI_OCF_LE_CS_SET_CHAN_CLASS (0x0092)
+struct ble_hci_le_cs_set_chan_class_cp
+{
     uint8_t channel_classification[10];
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_CS_SET_PROC_PARAMS                (0x0093)
-struct ble_hci_le_cs_set_proc_params_cp {
+#define BLE_HCI_OCF_LE_CS_SET_PROC_PARAMS (0x0093)
+struct ble_hci_le_cs_set_proc_params_cp
+{
     uint16_t conn_handle;
     uint8_t config_id;
     uint16_t max_procedure_len;
@@ -1292,19 +1469,22 @@ struct ble_hci_le_cs_set_proc_params_cp {
     uint8_t snr_control_initiator;
     uint8_t snr_control_reflector;
 } __attribute__((packed));
-struct ble_hci_le_cs_set_proc_params_rp {
+struct ble_hci_le_cs_set_proc_params_rp
+{
     uint16_t conn_handle;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_CS_PROC_ENABLE                    (0x0094)
-struct ble_hci_le_cs_proc_enable_cp {
+#define BLE_HCI_OCF_LE_CS_PROC_ENABLE (0x0094)
+struct ble_hci_le_cs_proc_enable_cp
+{
     uint16_t conn_handle;
     uint8_t config_id;
     uint8_t enable;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_CS_TEST                           (0x0095)
-struct ble_hci_le_cs_test_cp {
+#define BLE_HCI_OCF_LE_CS_TEST (0x0095)
+struct ble_hci_le_cs_test_cp
+{
     uint8_t main_mode_type;
     uint8_t sub_mode_type;
     uint8_t main_mode_repetition;
@@ -1329,133 +1509,162 @@ struct ble_hci_le_cs_test_cp {
     uint8_t override_parameters_data[];
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_LE_CS_TEST_END                       (0x0096)
+#define BLE_HCI_OCF_LE_CS_TEST_END (0x0096)
+
+#define BLE_HCI_OCF_LE_F_ENCRYPT (0x0100)
+struct ble_hci_le_f_encrypt
+{
+    uint16_t conn_handle;
+    uint8_t ltk[16];
+} __attribute__((packed));
+
+#define BLE_HCI_OCF_LE_REKEY (0x0101)
 
 /* --- Vendor specific commands (OGF 0x003F) */
 /* Read Random Static Address */
-#define BLE_HCI_OCF_VS_RD_STATIC_ADDR                   (MYNEWT_VAL(BLE_HCI_VS_OCF_OFFSET) + (0x0001))
-struct ble_hci_vs_rd_static_addr_rp {
+#define BLE_HCI_OCF_VS_RD_STATIC_ADDR                                          \
+    (MYNEWT_VAL(BLE_HCI_VS_OCF_OFFSET) + (0x0001))
+struct ble_hci_vs_rd_static_addr_rp
+{
     uint8_t addr[6];
 } __attribute__((packed));
 
 /* Set default transmit power. Actual selected TX power is returned
  * in reply. Setting 0xff restores controller reset default.
  */
-#define BLE_HCI_OCF_VS_SET_TX_PWR                       (MYNEWT_VAL(BLE_HCI_VS_OCF_OFFSET) + (0x0002))
-struct ble_hci_vs_set_tx_pwr_cp {
+#define BLE_HCI_OCF_VS_SET_TX_PWR (MYNEWT_VAL(BLE_HCI_VS_OCF_OFFSET) + (0x0002))
+struct ble_hci_vs_set_tx_pwr_cp
+{
     int8_t tx_power;
 } __attribute__((packed));
-struct ble_hci_vs_set_tx_pwr_rp {
+struct ble_hci_vs_set_tx_pwr_rp
+{
     int8_t tx_power;
 } __attribute__((packed));
 
-#define BLE_HCI_OCF_VS_CSS_CONFIGURE                    (MYNEWT_VAL(BLE_HCI_VS_OCF_OFFSET) + (0x0003))
-struct ble_hci_vs_css_configure_cp {
+#define BLE_HCI_OCF_VS_CSS_CONFIGURE                                           \
+    (MYNEWT_VAL(BLE_HCI_VS_OCF_OFFSET) + (0x0003))
+struct ble_hci_vs_css_configure_cp
+{
     uint32_t slot_us;
     uint32_t period_slots;
 } __attribute__((packed));
-#define BLE_HCI_OCF_VS_CSS_ENABLE                       (MYNEWT_VAL(BLE_HCI_VS_OCF_OFFSET) + (0x0004))
-struct ble_hci_vs_css_enable_cp {
+#define BLE_HCI_OCF_VS_CSS_ENABLE (MYNEWT_VAL(BLE_HCI_VS_OCF_OFFSET) + (0x0004))
+struct ble_hci_vs_css_enable_cp
+{
     uint8_t enable;
 } __attribute__((packed));
-#define BLE_HCI_OCF_VS_CSS_SET_NEXT_SLOT                (MYNEWT_VAL(BLE_HCI_VS_OCF_OFFSET) + (0x0005))
-struct ble_hci_vs_css_set_next_slot_cp {
+#define BLE_HCI_OCF_VS_CSS_SET_NEXT_SLOT                                       \
+    (MYNEWT_VAL(BLE_HCI_VS_OCF_OFFSET) + (0x0005))
+struct ble_hci_vs_css_set_next_slot_cp
+{
     uint16_t slot_idx;
 } __attribute__((packed));
-#define BLE_HCI_OCF_VS_CSS_SET_CONN_SLOT                (MYNEWT_VAL(BLE_HCI_VS_OCF_OFFSET) + (0x0006))
-struct ble_hci_vs_css_set_conn_slot_cp {
+#define BLE_HCI_OCF_VS_CSS_SET_CONN_SLOT                                       \
+    (MYNEWT_VAL(BLE_HCI_VS_OCF_OFFSET) + (0x0006))
+struct ble_hci_vs_css_set_conn_slot_cp
+{
     uint16_t conn_handle;
     uint16_t slot_idx;
 } __attribute__((packed));
-#define BLE_HCI_OCF_VS_CSS_READ_CONN_SLOT               (MYNEWT_VAL(BLE_HCI_VS_OCF_OFFSET) + (0x0007))
-struct ble_hci_vs_css_read_conn_slot_cp {
+#define BLE_HCI_OCF_VS_CSS_READ_CONN_SLOT                                      \
+    (MYNEWT_VAL(BLE_HCI_VS_OCF_OFFSET) + (0x0007))
+struct ble_hci_vs_css_read_conn_slot_cp
+{
     uint16_t conn_handle;
 } __attribute__((packed));
-struct ble_hci_vs_css_read_conn_slot_rp {
+struct ble_hci_vs_css_read_conn_slot_rp
+{
     uint16_t conn_handle;
     uint16_t slot_idx;
 } __attribute__((packed));
-#define BLE_HCI_OCF_VS_SET_DATA_LEN                     (MYNEWT_VAL(BLE_HCI_VS_OCF_OFFSET) + (0x0008))
-struct ble_hci_vs_set_data_len_cp {
+#define BLE_HCI_OCF_VS_SET_DATA_LEN                                            \
+    (MYNEWT_VAL(BLE_HCI_VS_OCF_OFFSET) + (0x0008))
+struct ble_hci_vs_set_data_len_cp
+{
     uint16_t conn_handle;
     uint16_t tx_octets;
     uint16_t tx_time;
     uint16_t rx_octets;
     uint16_t rx_time;
 } __attribute__((packed));
-struct ble_hci_vs_set_data_len_rp {
+struct ble_hci_vs_set_data_len_rp
+{
     uint16_t conn_handle;
 } __attribute__((packed));
-#define BLE_HCI_OCF_VS_SET_ANTENNA                     (MYNEWT_VAL(BLE_HCI_VS_OCF_OFFSET) + (0x0009))
-struct ble_hci_vs_set_antenna_cp {
+#define BLE_HCI_OCF_VS_SET_ANTENNA                                             \
+    (MYNEWT_VAL(BLE_HCI_VS_OCF_OFFSET) + (0x0009))
+struct ble_hci_vs_set_antenna_cp
+{
     uint8_t antenna;
 } __attribute__((packed));
-#define BLE_HCI_OCF_VS_SET_LOCAL_IRK                   (MYNEWT_VAL(BLE_HCI_VS_OCF_OFFSET) + (0x000A))
-struct ble_hci_vs_set_local_irk_cp {
+#define BLE_HCI_OCF_VS_SET_LOCAL_IRK                                           \
+    (MYNEWT_VAL(BLE_HCI_VS_OCF_OFFSET) + (0x000A))
+struct ble_hci_vs_set_local_irk_cp
+{
     uint8_t own_addr_type;
     uint8_t irk[16];
 } __attribute__((packed));
 
 /* Command Specific Definitions */
 /* --- Set controller to host flow control (OGF 0x03, OCF 0x0031) --- */
-#define BLE_HCI_CTLR_TO_HOST_FC_OFF         (0)
-#define BLE_HCI_CTLR_TO_HOST_FC_ACL         (1)
-#define BLE_HCI_CTLR_TO_HOST_FC_SYNC        (2)
-#define BLE_HCI_CTLR_TO_HOST_FC_BOTH        (3)
+#define BLE_HCI_CTLR_TO_HOST_FC_OFF (0)
+#define BLE_HCI_CTLR_TO_HOST_FC_ACL (1)
+#define BLE_HCI_CTLR_TO_HOST_FC_SYNC (2)
+#define BLE_HCI_CTLR_TO_HOST_FC_BOTH (3)
 
 /* --- LE set advertising parameters (OCF 0x0006) */
 /* Advertising types */
-#define BLE_HCI_ADV_TYPE_ADV_IND            (0)
-#define BLE_HCI_ADV_TYPE_ADV_DIRECT_IND_HD  (1)
-#define BLE_HCI_ADV_TYPE_ADV_SCAN_IND       (2)
-#define BLE_HCI_ADV_TYPE_ADV_NONCONN_IND    (3)
-#define BLE_HCI_ADV_TYPE_ADV_DIRECT_IND_LD  (4)
-#define BLE_HCI_ADV_TYPE_MAX                (4)
-
-#define BLE_HCI_ADV_CONN_MASK               (0x0001)
-#define BLE_HCI_ADV_SCAN_MASK               (0x0002)
-#define BLE_HCI_ADV_DIRECT_MASK             (0x0004)
-#define BLE_HCI_ADV_SCAN_RSP_MASK           (0x0008)
-#define BLE_HCI_ADV_LEGACY_MASK             (0x0010)
-
-#define BLE_HCI_ADV_DATA_STATUS_COMPLETE    (0x0000)
-#define BLE_HCI_ADV_DATA_STATUS_INCOMPLETE  (0x0020)
-#define BLE_HCI_ADV_DATA_STATUS_TRUNCATED   (0x0040)
-#define BLE_HCI_ADV_DATA_STATUS_MASK        (0x0060)
+#define BLE_HCI_ADV_TYPE_ADV_IND (0)
+#define BLE_HCI_ADV_TYPE_ADV_DIRECT_IND_HD (1)
+#define BLE_HCI_ADV_TYPE_ADV_SCAN_IND (2)
+#define BLE_HCI_ADV_TYPE_ADV_NONCONN_IND (3)
+#define BLE_HCI_ADV_TYPE_ADV_DIRECT_IND_LD (4)
+#define BLE_HCI_ADV_TYPE_MAX (4)
+
+#define BLE_HCI_ADV_CONN_MASK (0x0001)
+#define BLE_HCI_ADV_SCAN_MASK (0x0002)
+#define BLE_HCI_ADV_DIRECT_MASK (0x0004)
+#define BLE_HCI_ADV_SCAN_RSP_MASK (0x0008)
+#define BLE_HCI_ADV_LEGACY_MASK (0x0010)
+
+#define BLE_HCI_ADV_DATA_STATUS_COMPLETE (0x0000)
+#define BLE_HCI_ADV_DATA_STATUS_INCOMPLETE (0x0020)
+#define BLE_HCI_ADV_DATA_STATUS_TRUNCATED (0x0040)
+#define BLE_HCI_ADV_DATA_STATUS_MASK (0x0060)
 
 /* Own address types */
-#define BLE_HCI_ADV_OWN_ADDR_PUBLIC         (0)
-#define BLE_HCI_ADV_OWN_ADDR_RANDOM         (1)
-#define BLE_HCI_ADV_OWN_ADDR_PRIV_PUB       (2)
-#define BLE_HCI_ADV_OWN_ADDR_PRIV_RAND      (3)
-#define BLE_HCI_ADV_OWN_ADDR_MAX            (3)
+#define BLE_HCI_ADV_OWN_ADDR_PUBLIC (0)
+#define BLE_HCI_ADV_OWN_ADDR_RANDOM (1)
+#define BLE_HCI_ADV_OWN_ADDR_PRIV_PUB (2)
+#define BLE_HCI_ADV_OWN_ADDR_PRIV_RAND (3)
+#define BLE_HCI_ADV_OWN_ADDR_MAX (3)
 
 /* Advertisement peer address Type */
-#define BLE_HCI_ADV_PEER_ADDR_PUBLIC        (0)
-#define BLE_HCI_ADV_PEER_ADDR_RANDOM        (1)
-#define BLE_HCI_ADV_PEER_ADDR_MAX           (1)
+#define BLE_HCI_ADV_PEER_ADDR_PUBLIC (0)
+#define BLE_HCI_ADV_PEER_ADDR_RANDOM (1)
+#define BLE_HCI_ADV_PEER_ADDR_MAX (1)
 
 /* --- LE advertising channel tx power (OCF 0x0007) */
 #if MYNEWT_VAL(BLE_VERSION) == 50
-#define BLE_HCI_ADV_CHAN_TXPWR_MIN          (-20)
-#define BLE_HCI_ADV_CHAN_TXPWR_MAX          (10)
+#define BLE_HCI_ADV_CHAN_TXPWR_MIN (-20)
+#define BLE_HCI_ADV_CHAN_TXPWR_MAX (10)
 #elif MYNEWT_VAL(BLE_VERSION) == 51
-#define BLE_HCI_ADV_CHAN_TXPWR_MIN          (-20)
-#define BLE_HCI_ADV_CHAN_TXPWR_MAX          (20)
+#define BLE_HCI_ADV_CHAN_TXPWR_MIN (-20)
+#define BLE_HCI_ADV_CHAN_TXPWR_MAX (20)
 #elif MYNEWT_VAL(BLE_VERSION) >= 52
-#define BLE_HCI_ADV_CHAN_TXPWR_MIN          (-127)
-#define BLE_HCI_ADV_CHAN_TXPWR_MAX          (20)
+#define BLE_HCI_ADV_CHAN_TXPWR_MIN (-127)
+#define BLE_HCI_ADV_CHAN_TXPWR_MAX (20)
 #endif
 
-
 /* --- LE set scan enable (OCF 0x000c) */
 
 /* Connect peer address type */
-#define BLE_HCI_CONN_PEER_ADDR_PUBLIC        (0)
-#define BLE_HCI_CONN_PEER_ADDR_RANDOM        (1)
-#define BLE_HCI_CONN_PEER_ADDR_PUBLIC_IDENT  (2)
-#define BLE_HCI_CONN_PEER_ADDR_RANDOM_IDENT  (3)
-#define BLE_HCI_CONN_PEER_ADDR_MAX           (3)
+#define BLE_HCI_CONN_PEER_ADDR_PUBLIC (0)
+#define BLE_HCI_CONN_PEER_ADDR_RANDOM (1)
+#define BLE_HCI_CONN_PEER_ADDR_PUBLIC_IDENT (2)
+#define BLE_HCI_CONN_PEER_ADDR_RANDOM_IDENT (3)
+#define BLE_HCI_CONN_PEER_ADDR_MAX (3)
 
 /*
  * Advertising filter policy
@@ -1467,39 +1676,39 @@ struct ble_hci_vs_set_local_irk_cp {
  *  CONN: process all scan request but only connection requests from white list
  *  BOTH: ignore all scan and connection requests unless in white list.
  */
-#define BLE_HCI_ADV_FILT_NONE               (0)
-#define BLE_HCI_ADV_FILT_SCAN               (1)
-#define BLE_HCI_ADV_FILT_CONN               (2)
-#define BLE_HCI_ADV_FILT_BOTH               (3)
-#define BLE_HCI_ADV_FILT_MAX                (3)
+#define BLE_HCI_ADV_FILT_NONE (0)
+#define BLE_HCI_ADV_FILT_SCAN (1)
+#define BLE_HCI_ADV_FILT_CONN (2)
+#define BLE_HCI_ADV_FILT_BOTH (3)
+#define BLE_HCI_ADV_FILT_MAX (3)
 
-#define BLE_HCI_ADV_FILT_DEF                (BLE_HCI_ADV_FILT_NONE)
+#define BLE_HCI_ADV_FILT_DEF (BLE_HCI_ADV_FILT_NONE)
 
 /* Advertising interval */
-#define BLE_HCI_ADV_ITVL                    (625)           /* usecs */
-#define BLE_HCI_ADV_ITVL_MIN                (32)            /* units */
-#define BLE_HCI_ADV_ITVL_MAX                (16384)         /* units */
-#define BLE_HCI_ADV_ITVL_NONCONN_MIN        (160)           /* units */
+#define BLE_HCI_ADV_ITVL (625)             /* usecs */
+#define BLE_HCI_ADV_ITVL_MIN (32)          /* units */
+#define BLE_HCI_ADV_ITVL_MAX (16384)       /* units */
+#define BLE_HCI_ADV_ITVL_NONCONN_MIN (160) /* units */
 
-#define BLE_HCI_ADV_ITVL_DEF                (0x800)         /* 1.28 seconds */
-#define BLE_HCI_ADV_CHANMASK_DEF            (0x7)           /* all channels */
+#define BLE_HCI_ADV_ITVL_DEF (0x800)   /* 1.28 seconds */
+#define BLE_HCI_ADV_CHANMASK_DEF (0x7) /* all channels */
 
-#define BLE_HCI_PERIODIC_ADV_ITVL           (1250)          /* usecs */
+#define BLE_HCI_PERIODIC_ADV_ITVL (1250) /* usecs */
 
 /* Set scan parameters */
-#define BLE_HCI_SCAN_TYPE_PASSIVE           (0)
-#define BLE_HCI_SCAN_TYPE_ACTIVE            (1)
+#define BLE_HCI_SCAN_TYPE_PASSIVE (0)
+#define BLE_HCI_SCAN_TYPE_ACTIVE (1)
 
 /* Scan interval and scan window timing */
-#define BLE_HCI_SCAN_ITVL                   (625)           /* usecs */
-#define BLE_HCI_SCAN_ITVL_MIN               (0x0004)        /* units */
-#define BLE_HCI_SCAN_ITVL_MAX               (0x4000)        /* units */
-#define BLE_HCI_SCAN_ITVL_MAX_EXT           (0xffff)        /* units */
-#define BLE_HCI_SCAN_ITVL_DEF               (16)            /* units */
-#define BLE_HCI_SCAN_WINDOW_MIN             (0x0004)        /* units */
-#define BLE_HCI_SCAN_WINDOW_MAX             (0x4000)        /* units */
-#define BLE_HCI_SCAN_WINDOW_MAX_EXT         (0xffff)        /* units */
-#define BLE_HCI_SCAN_WINDOW_DEF             (16)            /* units */
+#define BLE_HCI_SCAN_ITVL (625)              /* usecs */
+#define BLE_HCI_SCAN_ITVL_MIN (0x0004)       /* units */
+#define BLE_HCI_SCAN_ITVL_MAX (0x4000)       /* units */
+#define BLE_HCI_SCAN_ITVL_MAX_EXT (0xffff)   /* units */
+#define BLE_HCI_SCAN_ITVL_DEF (16)           /* units */
+#define BLE_HCI_SCAN_WINDOW_MIN (0x0004)     /* units */
+#define BLE_HCI_SCAN_WINDOW_MAX (0x4000)     /* units */
+#define BLE_HCI_SCAN_WINDOW_MAX_EXT (0xffff) /* units */
+#define BLE_HCI_SCAN_WINDOW_DEF (16)         /* units */
 
 /*
  * Scanning filter policy
@@ -1518,372 +1727,396 @@ struct ble_hci_vs_set_local_irk_cp {
  *      directed advertisement shall not be ignored if the InitA is a
  *      resolvable private address.
  */
-#define BLE_HCI_SCAN_FILT_NO_WL             (0)
-#define BLE_HCI_SCAN_FILT_USE_WL            (1)
-#define BLE_HCI_SCAN_FILT_NO_WL_INITA       (2)
-#define BLE_HCI_SCAN_FILT_USE_WL_INITA      (3)
-#define BLE_HCI_SCAN_FILT_MAX               (3)
+#define BLE_HCI_SCAN_FILT_NO_WL (0)
+#define BLE_HCI_SCAN_FILT_USE_WL (1)
+#define BLE_HCI_SCAN_FILT_NO_WL_INITA (2)
+#define BLE_HCI_SCAN_FILT_USE_WL_INITA (3)
+#define BLE_HCI_SCAN_FILT_MAX (3)
 
 /* Whitelist commands */
-#define BLE_HCI_ADD_WHITE_LIST_LEN          (7)
-#define BLE_HCI_RMV_WHITE_LIST_LEN          (7)
+#define BLE_HCI_ADD_WHITE_LIST_LEN (7)
+#define BLE_HCI_RMV_WHITE_LIST_LEN (7)
 
 /* Create Connection */
-#define BLE_HCI_CREATE_CONN_LEN             (25)
-#define BLE_HCI_CONN_ITVL                   (1250)  /* usecs */
-#define BLE_HCI_CONN_FILT_NO_WL             (0)
-#define BLE_HCI_CONN_FILT_USE_WL            (1)
-#define BLE_HCI_CONN_FILT_MAX               (1)
-#define BLE_HCI_CONN_ITVL_MIN               (0x0006)
-#define BLE_HCI_CONN_ITVL_MAX               (0x0c80)
-#define BLE_HCI_CONN_LATENCY_MIN            (0x0000)
-#define BLE_HCI_CONN_LATENCY_MAX            (0x01f3)
-#define BLE_HCI_CONN_SPVN_TIMEOUT_MIN       (0x000a)
-#define BLE_HCI_CONN_SPVN_TIMEOUT_MAX       (0x0c80)
-#define BLE_HCI_CONN_SPVN_TMO_UNITS         (10)    /* msecs */
-#define BLE_HCI_INITIATOR_FILT_POLICY_MAX   (1)
+#define BLE_HCI_CREATE_CONN_LEN (25)
+#define BLE_HCI_CONN_ITVL (1250) /* usecs */
+#define BLE_HCI_CONN_FILT_NO_WL (0)
+#define BLE_HCI_CONN_FILT_USE_WL (1)
+#define BLE_HCI_CONN_FILT_MAX (1)
+#define BLE_HCI_CONN_ITVL_MIN (0x0006)
+#define BLE_HCI_CONN_ITVL_MAX (0x0c80)
+#define BLE_HCI_CONN_LATENCY_MIN (0x0000)
+#define BLE_HCI_CONN_LATENCY_MAX (0x01f3)
+#define BLE_HCI_CONN_SPVN_TIMEOUT_MIN (0x000a)
+#define BLE_HCI_CONN_SPVN_TIMEOUT_MAX (0x0c80)
+#define BLE_HCI_CONN_SPVN_TMO_UNITS (10) /* msecs */
+#define BLE_HCI_INITIATOR_FILT_POLICY_MAX (1)
 
 /* Peer Address Type */
-#define BLE_HCI_CONN_PEER_ADDR_PUBLIC       (0)
-#define BLE_HCI_CONN_PEER_ADDR_RANDOM       (1)
-#define BLE_HCI_CONN_PEER_ADDR_PUB_ID       (2)
-#define BLE_HCI_CONN_PEER_ADDR_RAND_ID      (3)
-#define BLE_HCI_CONN_PEER_ADDR_MAX          (3)
-
+#define BLE_HCI_CONN_PEER_ADDR_PUBLIC (0)
+#define BLE_HCI_CONN_PEER_ADDR_RANDOM (1)
+#define BLE_HCI_CONN_PEER_ADDR_PUB_ID (2)
+#define BLE_HCI_CONN_PEER_ADDR_RAND_ID (3)
+#define BLE_HCI_CONN_PEER_ADDR_MAX (3)
 
 /* --- LE set data length (OCF 0x0022) */
-#define BLE_HCI_SET_DATALEN_TX_OCTETS_MIN   (0x001b)
-#define BLE_HCI_SET_DATALEN_TX_OCTETS_MAX   (0x00fb)
-#define BLE_HCI_SET_DATALEN_TX_TIME_MIN     (0x0148)
-#define BLE_HCI_SET_DATALEN_TX_TIME_MAX     (0x4290)
+#define BLE_HCI_SET_DATALEN_TX_OCTETS_MIN (0x001b)
+#define BLE_HCI_SET_DATALEN_TX_OCTETS_MAX (0x00fb)
+#define BLE_HCI_SET_DATALEN_TX_TIME_MIN (0x0148)
+#define BLE_HCI_SET_DATALEN_TX_TIME_MAX (0x4290)
 
 /* --- LE read/write suggested default data length (OCF 0x0023 and 0x0024) */
-#define BLE_HCI_SUGG_DEF_DATALEN_TX_OCTETS_MIN      (0x001b)
-#define BLE_HCI_SUGG_DEF_DATALEN_TX_OCTETS_MAX      (0x00fb)
-#define BLE_HCI_SUGG_DEF_DATALEN_TX_TIME_MIN        (0x0148)
-#define BLE_HCI_SUGG_DEF_DATALEN_TX_TIME_MAX        (0x4290)
+#define BLE_HCI_SUGG_DEF_DATALEN_TX_OCTETS_MIN (0x001b)
+#define BLE_HCI_SUGG_DEF_DATALEN_TX_OCTETS_MAX (0x00fb)
+#define BLE_HCI_SUGG_DEF_DATALEN_TX_TIME_MIN (0x0148)
+#define BLE_HCI_SUGG_DEF_DATALEN_TX_TIME_MAX (0x4290)
 
 /* --- LE read maximum default PHY (OCF 0x0030) */
-#define BLE_HCI_LE_PHY_1M                   (1)
-#define BLE_HCI_LE_PHY_2M                   (2)
-#define BLE_HCI_LE_PHY_CODED                (3)
+#define BLE_HCI_LE_PHY_1M (1)
+#define BLE_HCI_LE_PHY_2M (2)
+#define BLE_HCI_LE_PHY_CODED (3)
 
 /* --- LE set default PHY (OCF 0x0031) */
-#define BLE_HCI_LE_PHY_NO_TX_PREF_MASK              (0x01)
-#define BLE_HCI_LE_PHY_NO_RX_PREF_MASK              (0x02)
-#define BLE_HCI_LE_PHY_1M_PREF_MASK                 (0x01)
-#define BLE_HCI_LE_PHY_2M_PREF_MASK                 (0x02)
-#define BLE_HCI_LE_PHY_CODED_PREF_MASK              (0x04)
-
-#define BLE_HCI_LE_PHY_PREF_MASK_ALL                \
-    (BLE_HCI_LE_PHY_1M_PREF_MASK | BLE_HCI_LE_PHY_2M_PREF_MASK |  \
+#define BLE_HCI_LE_PHY_NO_TX_PREF_MASK (0x01)
+#define BLE_HCI_LE_PHY_NO_RX_PREF_MASK (0x02)
+#define BLE_HCI_LE_PHY_1M_PREF_MASK (0x01)
+#define BLE_HCI_LE_PHY_2M_PREF_MASK (0x02)
+#define BLE_HCI_LE_PHY_CODED_PREF_MASK (0x04)
+
+#define BLE_HCI_LE_PHY_PREF_MASK_ALL                                           \
+    (BLE_HCI_LE_PHY_1M_PREF_MASK | BLE_HCI_LE_PHY_2M_PREF_MASK |               \
      BLE_HCI_LE_PHY_CODED_PREF_MASK)
 
 /* --- LE set PHY (OCF 0x0032) */
-#define BLE_HCI_LE_PHY_CODED_ANY                    (0x0000)
-#define BLE_HCI_LE_PHY_CODED_S2_PREF                (0x0001)
-#define BLE_HCI_LE_PHY_CODED_S8_PREF                (0x0002)
+#define BLE_HCI_LE_PHY_CODED_ANY (0x0000)
+#define BLE_HCI_LE_PHY_CODED_S2_PREF (0x0001)
+#define BLE_HCI_LE_PHY_CODED_S8_PREF (0x0002)
 
 /* --- LE enhanced receiver test (OCF 0x0033) */
-#define BLE_HCI_LE_PHY_1M                           (1)
-#define BLE_HCI_LE_PHY_2M                           (2)
-#define BLE_HCI_LE_PHY_CODED                        (3)
+#define BLE_HCI_LE_PHY_1M (1)
+#define BLE_HCI_LE_PHY_2M (2)
+#define BLE_HCI_LE_PHY_CODED (3)
 
 /* --- LE enhanced transmitter test (OCF 0x0034) */
-#define BLE_HCI_LE_PHY_CODED_S8                     (3)
-#define BLE_HCI_LE_PHY_CODED_S2                     (4)
+#define BLE_HCI_LE_PHY_CODED_S8 (3)
+#define BLE_HCI_LE_PHY_CODED_S2 (4)
 
 /* --- LE set extended advertising parameters (OCF 0x0036) */
-#define BLE_HCI_LE_SET_EXT_ADV_PROP_CONNECTABLE     (0x0001)
-#define BLE_HCI_LE_SET_EXT_ADV_PROP_SCANNABLE       (0x0002)
-#define BLE_HCI_LE_SET_EXT_ADV_PROP_DIRECTED        (0x0004)
-#define BLE_HCI_LE_SET_EXT_ADV_PROP_HD_DIRECTED     (0x0008)
-#define BLE_HCI_LE_SET_EXT_ADV_PROP_LEGACY          (0x0010)
-#define BLE_HCI_LE_SET_EXT_ADV_PROP_ANON_ADV        (0x0020)
-#define BLE_HCI_LE_SET_EXT_ADV_PROP_INC_TX_PWR      (0x0040)
-#define BLE_HCI_LE_SET_EXT_ADV_PROP_MASK            (0x7F)
-
-#define BLE_HCI_LE_SET_EXT_ADV_PROP_LEGACY_IND      (0x0013)
-#define BLE_HCI_LE_SET_EXT_ADV_PROP_LEGACY_LD_DIR   (0x0015)
-#define BLE_HCI_LE_SET_EXT_ADV_PROP_LEGACY_HD_DIR   (0x001d)
-#define BLE_HCI_LE_SET_EXT_ADV_PROP_LEGACY_SCAN     (0x0012)
-#define BLE_HCI_LE_SET_EXT_ADV_PROP_LEGACY_NONCONN  (0x0010)
+#define BLE_HCI_LE_SET_EXT_ADV_PROP_CONNECTABLE (0x0001)
+#define BLE_HCI_LE_SET_EXT_ADV_PROP_SCANNABLE (0x0002)
+#define BLE_HCI_LE_SET_EXT_ADV_PROP_DIRECTED (0x0004)
+#define BLE_HCI_LE_SET_EXT_ADV_PROP_HD_DIRECTED (0x0008)
+#define BLE_HCI_LE_SET_EXT_ADV_PROP_LEGACY (0x0010)
+#define BLE_HCI_LE_SET_EXT_ADV_PROP_ANON_ADV (0x0020)
+#define BLE_HCI_LE_SET_EXT_ADV_PROP_INC_TX_PWR (0x0040)
+#define BLE_HCI_LE_SET_EXT_ADV_PROP_MASK (0x7F)
+
+#define BLE_HCI_LE_SET_EXT_ADV_PROP_LEGACY_IND (0x0013)
+#define BLE_HCI_LE_SET_EXT_ADV_PROP_LEGACY_LD_DIR (0x0015)
+#define BLE_HCI_LE_SET_EXT_ADV_PROP_LEGACY_HD_DIR (0x001d)
+#define BLE_HCI_LE_SET_EXT_ADV_PROP_LEGACY_SCAN (0x0012)
+#define BLE_HCI_LE_SET_EXT_ADV_PROP_LEGACY_NONCONN (0x0010)
 
 /* --- LE set extended advertising data (OCF 0x0037) */
-#define BLE_HCI_MAX_EXT_ADV_DATA_LEN                (251)
+#define BLE_HCI_MAX_EXT_ADV_DATA_LEN (251)
 
-#define BLE_HCI_LE_SET_DATA_OPER_INT        (0)
-#define BLE_HCI_LE_SET_DATA_OPER_FIRST      (1)
-#define BLE_HCI_LE_SET_DATA_OPER_LAST       (2)
-#define BLE_HCI_LE_SET_DATA_OPER_COMPLETE   (3)
-#define BLE_HCI_LE_SET_DATA_OPER_UNCHANGED  (4)
+#define BLE_HCI_LE_SET_DATA_OPER_INT (0)
+#define BLE_HCI_LE_SET_DATA_OPER_FIRST (1)
+#define BLE_HCI_LE_SET_DATA_OPER_LAST (2)
+#define BLE_HCI_LE_SET_DATA_OPER_COMPLETE (3)
+#define BLE_HCI_LE_SET_DATA_OPER_UNCHANGED (4)
 
 /* --- LE set extended scan response data (OCF 0x0038) */
-#define BLE_HCI_MAX_EXT_SCAN_RSP_DATA_LEN           (251)
+#define BLE_HCI_MAX_EXT_SCAN_RSP_DATA_LEN (251)
 
 /* --- LE set periodic advertising parameters (OCF 0x003E) */
 #define BLE_HCI_LE_SET_PERIODIC_ADV_PROP_INC_TX_PWR (0x0040)
-#define BLE_HCI_LE_SET_PERIODIC_ADV_PROP_MASK       (0x0040)
+#define BLE_HCI_LE_SET_PERIODIC_ADV_PROP_MASK (0x0040)
 
 /* --- LE set periodic advertising data (OCF 0x003F) */
-#define BLE_HCI_MAX_PERIODIC_ADV_DATA_LEN                (252)
+#define BLE_HCI_MAX_PERIODIC_ADV_DATA_LEN (252)
 
 /* --- LE remove device from periodic advertising list (OCF 0x0048) */
-#define BLE_HCI_PERIODIC_DATA_STATUS_COMPLETE   0x00
+#define BLE_HCI_PERIODIC_DATA_STATUS_COMPLETE 0x00
 #define BLE_HCI_PERIODIC_DATA_STATUS_INCOMPLETE 0x01
-#define BLE_HCI_PERIODIC_DATA_STATUS_TRUNCATED  0x02
+#define BLE_HCI_PERIODIC_DATA_STATUS_TRUNCATED 0x02
 
 /* --- LE set privacy mode (OCF 0x004E) */
-#define BLE_HCI_PRIVACY_NETWORK                     (0)
-#define BLE_HCI_PRIVACY_DEVICE                      (1)
+#define BLE_HCI_PRIVACY_NETWORK (0)
+#define BLE_HCI_PRIVACY_DEVICE (1)
 
 /* --- LE set advertising coded PHY options (OCF 0x007F) */
-#define BLE_HCI_ADVERTISING_PHY_OPT_NO_PREF      0x0
-#define BLE_HCI_ADVERTISING_PHY_OPT_S2_PREF      0x1
-#define BLE_HCI_ADVERTISING_PHY_OPT_S8_PREF      0x2
-#define BLE_HCI_ADVERTISING_PHY_OPT_S2_REQ       0x3
-#define BLE_HCI_ADVERTISING_PHY_OPT_S8_REQ       0x4
+#define BLE_HCI_ADVERTISING_PHY_OPT_NO_PREF 0x0
+#define BLE_HCI_ADVERTISING_PHY_OPT_S2_PREF 0x1
+#define BLE_HCI_ADVERTISING_PHY_OPT_S8_PREF 0x2
+#define BLE_HCI_ADVERTISING_PHY_OPT_S2_REQ 0x3
+#define BLE_HCI_ADVERTISING_PHY_OPT_S8_REQ 0x4
 
 /* Event Codes */
-#define BLE_HCI_EVCODE_INQUIRY_CMP          (0x01)
-#define BLE_HCI_EVCODE_INQUIRY_RESULT       (0x02)
-#define BLE_HCI_EVCODE_CONN_DONE            (0x03)
-#define BLE_HCI_EVCODE_CONN_REQUEST         (0x04)
-#define BLE_HCI_EVCODE_DISCONN_CMP          (0x05)
-struct ble_hci_ev_disconn_cmp {
+#define BLE_HCI_EVCODE_INQUIRY_CMP (0x01)
+#define BLE_HCI_EVCODE_INQUIRY_RESULT (0x02)
+#define BLE_HCI_EVCODE_CONN_DONE (0x03)
+#define BLE_HCI_EVCODE_CONN_REQUEST (0x04)
+#define BLE_HCI_EVCODE_DISCONN_CMP (0x05)
+struct ble_hci_ev_disconn_cmp
+{
     uint8_t status;
     uint16_t conn_handle;
     uint8_t reason;
 } __attribute__((packed));
 
-#define BLE_HCI_EVCODE_AUTH_CMP             (0x06)
-#define BLE_HCI_EVCODE_REM_NAME_REQ_CMP     (0x07)
+#define BLE_HCI_EVCODE_AUTH_CMP (0x06)
+#define BLE_HCI_EVCODE_REM_NAME_REQ_CMP (0x07)
 
-#define BLE_HCI_EVCODE_ENCRYPT_CHG          (0x08)
-struct ble_hci_ev_enrypt_chg {
+#define BLE_HCI_EVCODE_ENCRYPT_CHG (0x08)
+struct ble_hci_ev_enrypt_chg
+{
     uint8_t status;
     uint16_t connection_handle;
     uint8_t enabled;
 } __attribute__((packed));
 
-#define BLE_HCI_EVCODE_CHG_LINK_KEY_CMP     (0x09)
-#define BLE_HCI_EVCODE_MASTER_LINK_KEY_CMP  (0x0A)
+#define BLE_HCI_EVCODE_CHG_LINK_KEY_CMP (0x09)
+#define BLE_HCI_EVCODE_MASTER_LINK_KEY_CMP (0x0A)
 #define BLE_HCI_EVCODE_RD_REM_SUPP_FEAT_CMP (0x0B)
-#define BLE_HCI_EVCODE_RD_REM_VER_INFO_CMP  (0x0C)
-struct ble_hci_ev_rd_rem_ver_info_cmp {
-    uint8_t  status;
+#define BLE_HCI_EVCODE_RD_REM_VER_INFO_CMP (0x0C)
+struct ble_hci_ev_rd_rem_ver_info_cmp
+{
+    uint8_t status;
     uint16_t conn_handle;
-    uint8_t  version;
+    uint8_t version;
     uint16_t manufacturer;
     uint16_t subversion;
 } __attribute__((packed));
 
-#define BLE_HCI_EVCODE_QOS_SETUP_CMP        (0x0D)
+#define BLE_HCI_EVCODE_QOS_SETUP_CMP (0x0D)
 
-#define BLE_HCI_EVCODE_COMMAND_COMPLETE     (0x0E)
-struct ble_hci_ev_command_complete {
-    uint8_t  num_packets;
+#define BLE_HCI_EVCODE_COMMAND_COMPLETE (0x0E)
+struct ble_hci_ev_command_complete
+{
+    uint8_t num_packets;
     uint16_t opcode;
-    uint8_t  status;
-    uint8_t  return_params[0];
+    uint8_t status;
+    uint8_t return_params[0];
 } __attribute__((packed));
 /* NOP is exception and has no return parameters */
-struct ble_hci_ev_command_complete_nop {
-    uint8_t  num_packets;
+struct ble_hci_ev_command_complete_nop
+{
+    uint8_t num_packets;
     uint16_t opcode;
 } __attribute__((packed));
 
-#define BLE_HCI_EVCODE_COMMAND_STATUS       (0x0F)
-struct ble_hci_ev_command_status {
+#define BLE_HCI_EVCODE_COMMAND_STATUS (0x0F)
+struct ble_hci_ev_command_status
+{
     uint8_t status;
-    uint8_t  num_packets;
+    uint8_t num_packets;
     uint16_t opcode;
 } __attribute__((packed));
 
-#define BLE_HCI_EVCODE_HW_ERROR             (0x10)
-struct ble_hci_ev_hw_error {
+#define BLE_HCI_EVCODE_HW_ERROR (0x10)
+struct ble_hci_ev_hw_error
+{
     uint8_t hw_code;
 } __attribute__((packed));
 
-#define BLE_HCI_EVCODE_NUM_COMP_PKTS        (0x13)
-struct comp_pkt {
+#define BLE_HCI_EVCODE_NUM_COMP_PKTS (0x13)
+struct comp_pkt
+{
     uint16_t handle;
     uint16_t packets;
-} __attribute__((packed));;
-struct ble_hci_ev_num_comp_pkts {
+} __attribute__((packed));
+;
+struct ble_hci_ev_num_comp_pkts
+{
     uint8_t count;
     struct comp_pkt completed[0];
 } __attribute__((packed));
 
-#define BLE_HCI_EVCODE_MODE_CHANGE          (0x14)
-#define BLE_HCI_EVCODE_RETURN_LINK_KEYS     (0x15)
-#define BLE_HCI_EVCODE_PIN_CODE_REQ         (0x16)
-#define BLE_HCI_EVCODE_LINK_KEY_REQ         (0x17)
-#define BLE_HCI_EVCODE_LINK_KEY_NOTIFY      (0x18)
-#define BLE_HCI_EVCODE_LOOPBACK_CMD         (0x19)
+#define BLE_HCI_EVCODE_MODE_CHANGE (0x14)
+#define BLE_HCI_EVCODE_RETURN_LINK_KEYS (0x15)
+#define BLE_HCI_EVCODE_PIN_CODE_REQ (0x16)
+#define BLE_HCI_EVCODE_LINK_KEY_REQ (0x17)
+#define BLE_HCI_EVCODE_LINK_KEY_NOTIFY (0x18)
+#define BLE_HCI_EVCODE_LOOPBACK_CMD (0x19)
 
-#define BLE_HCI_EVCODE_DATA_BUF_OVERFLOW    (0x1A)
-struct ble_hci_ev_data_buf_overflow {
+#define BLE_HCI_EVCODE_DATA_BUF_OVERFLOW (0x1A)
+struct ble_hci_ev_data_buf_overflow
+{
     uint8_t link_type;
 } __attribute__((packed));
 
-#define BLE_HCI_EVCODE_MAX_SLOTS_CHG        (0x1B)
-#define BLE_HCI_EVCODE_READ_CLK_OFF_COMP    (0x1C)
-#define BLE_HCI_EVCODE_CONN_PKT_TYPE_CHG    (0x1D)
-#define BLE_HCI_EVCODE_QOS_VIOLATION        (0x1E)
+#define BLE_HCI_EVCODE_MAX_SLOTS_CHG (0x1B)
+#define BLE_HCI_EVCODE_READ_CLK_OFF_COMP (0x1C)
+#define BLE_HCI_EVCODE_CONN_PKT_TYPE_CHG (0x1D)
+#define BLE_HCI_EVCODE_QOS_VIOLATION (0x1E)
 /* NOTE: 0x1F not defined */
-#define BLE_HCI_EVCODE_PSR_MODE_CHG         (0x20)
-#define BLE_HCI_EVCODE_FLOW_SPEC_COMP       (0x21)
-#define BLE_HCI_EVCODE_INQ_RESULT_RSSI      (0x22)
-#define BLE_HCI_EVCODE_READ_REM_EXT_FEAT    (0x23)
+#define BLE_HCI_EVCODE_PSR_MODE_CHG (0x20)
+#define BLE_HCI_EVCODE_FLOW_SPEC_COMP (0x21)
+#define BLE_HCI_EVCODE_INQ_RESULT_RSSI (0x22)
+#define BLE_HCI_EVCODE_READ_REM_EXT_FEAT (0x23)
 /* NOTE: 0x24 - 0x2B not defined */
-#define BLE_HCI_EVCODE_SYNCH_CONN_COMP      (0x2C)
-#define BLE_HCI_EVCODE_SYNCH_CONN_CHG       (0x2D)
-#define BLE_HCI_EVCODE_SNIFF_SUBRATING      (0x2E)
-#define BLE_HCI_EVCODE_EXT_INQ_RESULT       (0x2F)
+#define BLE_HCI_EVCODE_SYNCH_CONN_COMP (0x2C)
+#define BLE_HCI_EVCODE_SYNCH_CONN_CHG (0x2D)
+#define BLE_HCI_EVCODE_SNIFF_SUBRATING (0x2E)
+#define BLE_HCI_EVCODE_EXT_INQ_RESULT (0x2F)
 
-#define BLE_HCI_EVCODE_ENC_KEY_REFRESH      (0x30)
-struct ble_hci_ev_enc_key_refresh {
+#define BLE_HCI_EVCODE_ENC_KEY_REFRESH (0x30)
+struct ble_hci_ev_enc_key_refresh
+{
     uint8_t status;
     uint16_t conn_handle;
 } __attribute__((packed));
 
-#define BLE_HCI_EVOCDE_IO_CAP_REQ           (0x31)
-#define BLE_HCI_EVCODE_IO_CAP_RSP           (0x32)
-#define BLE_HCI_EVCODE_USER_CONFIRM_REQ     (0x33)
-#define BLE_HCI_EVCODE_PASSKEY_REQ          (0x34)
-#define BLE_HCI_EVCODE_REM_OOB_DATA_REQ     (0x35)
-#define BLE_HCI_EVCODE_SIMPLE_PAIR_COMP     (0x36)
+#define BLE_HCI_EVOCDE_IO_CAP_REQ (0x31)
+#define BLE_HCI_EVCODE_IO_CAP_RSP (0x32)
+#define BLE_HCI_EVCODE_USER_CONFIRM_REQ (0x33)
+#define BLE_HCI_EVCODE_PASSKEY_REQ (0x34)
+#define BLE_HCI_EVCODE_REM_OOB_DATA_REQ (0x35)
+#define BLE_HCI_EVCODE_SIMPLE_PAIR_COMP (0x36)
 /* NOTE: 0x37 not defined */
-#define BLE_HCI_EVCODE_LNK_SPVN_TMO_CHG     (0x38)
-#define BLE_HCI_EVCODE_ENH_FLUSH_COMP       (0x39)
-#define BLE_HCI_EVCODE_USER_PASSKEY_NOTIFY  (0x3B)
-#define BLE_HCI_EVCODE_KEYPRESS_NOTIFY      (0x3C)
-#define BLE_HCI_EVCODE_REM_HOST_SUPP_FEAT   (0x3D)
-
-#define BLE_HCI_EVCODE_LE_META              (0x3E)
-struct ble_hci_ev_le_meta {
+#define BLE_HCI_EVCODE_LNK_SPVN_TMO_CHG (0x38)
+#define BLE_HCI_EVCODE_ENH_FLUSH_COMP (0x39)
+#define BLE_HCI_EVCODE_USER_PASSKEY_NOTIFY (0x3B)
+#define BLE_HCI_EVCODE_KEYPRESS_NOTIFY (0x3C)
+#define BLE_HCI_EVCODE_REM_HOST_SUPP_FEAT (0x3D)
+
+#define BLE_HCI_EVCODE_LE_META (0x3E)
+struct ble_hci_ev_le_meta
+{
     uint8_t subevent;
     uint8_t data[0];
 } __attribute__((packed));
 
 /* NOTE: 0x3F not defined */
-#define BLE_HCI_EVCODE_PHYS_LINK_COMP       (0x40)
-#define BLE_HCI_EVCODE_CHAN_SELECTED        (0x41)
-#define BLE_HCI_EVCODE_DISCONN_PHYS_LINK    (0x42)
+#define BLE_HCI_EVCODE_PHYS_LINK_COMP (0x40)
+#define BLE_HCI_EVCODE_CHAN_SELECTED (0x41)
+#define BLE_HCI_EVCODE_DISCONN_PHYS_LINK (0x42)
 #define BLE_HCI_EVCODE_PHYS_LINK_LOSS_EARLY (0x43)
-#define BLE_HCI_EVCODE_PHYS_LINK_RECOVERY   (0x44)
-#define BLE_HCI_EVCODE_LOGICAL_LINK_COMP    (0x45)
+#define BLE_HCI_EVCODE_PHYS_LINK_RECOVERY (0x44)
+#define BLE_HCI_EVCODE_LOGICAL_LINK_COMP (0x45)
 #define BLE_HCI_EVCODE_DISCONN_LOGICAL_LINK (0x46)
-#define BLE_HCI_EVCODE_FLOW_SPEC_MODE_COMP  (0x47)
-#define BLE_HCI_EVCODE_NUM_COMP_DATA_BLKS   (0x48)
-#define BLE_HCI_EVCODE_AMP_START_TEST       (0x49)
-#define BLE_HCI_EVOCDE_AMP_TEST_END         (0x4A)
-#define BLE_HCI_EVOCDE_AMP_RCVR_REPORT      (0x4B)
+#define BLE_HCI_EVCODE_FLOW_SPEC_MODE_COMP (0x47)
+#define BLE_HCI_EVCODE_NUM_COMP_DATA_BLKS (0x48)
+#define BLE_HCI_EVCODE_AMP_START_TEST (0x49)
+#define BLE_HCI_EVOCDE_AMP_TEST_END (0x4A)
+#define BLE_HCI_EVOCDE_AMP_RCVR_REPORT (0x4B)
 #define BLE_HCI_EVCODE_SHORT_RANGE_MODE_CHG (0x4C)
-#define BLE_HCI_EVCODE_AMP_STATUS_CHG       (0x4D)
-#define BLE_HCI_EVCODE_TRIG_CLK_CAPTURE     (0x4E)
-#define BLE_HCI_EVCODE_SYNCH_TRAIN_COMP     (0x4F)
-#define BLE_HCI_EVCODE_SYNCH_TRAIN_RCVD     (0x50)
-#define BLE_HCI_EVCODE_SLAVE_BCAST_RX       (0x51)
-#define BLE_HCI_EVCODE_SLAVE_BCAST_TMO      (0x52)
-#define BLE_HCI_EVCODE_TRUNC_PAGE_COMP      (0x53)
-#define BLE_HCI_EVCODE_SLAVE_PAGE_RSP_TMO   (0x54)
+#define BLE_HCI_EVCODE_AMP_STATUS_CHG (0x4D)
+#define BLE_HCI_EVCODE_TRIG_CLK_CAPTURE (0x4E)
+#define BLE_HCI_EVCODE_SYNCH_TRAIN_COMP (0x4F)
+#define BLE_HCI_EVCODE_SYNCH_TRAIN_RCVD (0x50)
+#define BLE_HCI_EVCODE_SLAVE_BCAST_RX (0x51)
+#define BLE_HCI_EVCODE_SLAVE_BCAST_TMO (0x52)
+#define BLE_HCI_EVCODE_TRUNC_PAGE_COMP (0x53)
+#define BLE_HCI_EVCODE_SLAVE_PAGE_RSP_TMO (0x54)
 #define BLE_HCI_EVCODE_SLAVE_BCAST_CHAN_MAP (0x55)
-#define BLE_HCI_EVCODE_INQ_RSP_NOTIFY       (0x56)
+#define BLE_HCI_EVCODE_INQ_RSP_NOTIFY (0x56)
 
-#define BLE_HCI_EVCODE_AUTH_PYLD_TMO        (0x57)
-struct ble_hci_ev_auth_pyld_tmo {
+#define BLE_HCI_EVCODE_AUTH_PYLD_TMO (0x57)
+struct ble_hci_ev_auth_pyld_tmo
+{
     uint16_t conn_handle;
 } __attribute__((packed));
 
-#define BLE_HCI_EVCODE_SAM_STATUS_CHG       (0x58)
+#define BLE_HCI_EVCODE_SAM_STATUS_CHG (0x58)
 
-#define BLE_HCI_EVCODE_VS                   (0xff)
-struct ble_hci_ev_vs {
+#define BLE_HCI_EVCODE_VS (0xff)
+struct ble_hci_ev_vs
+{
     uint8_t id;
     uint8_t data[0];
 } __attribute__((packed));
 
-#define BLE_HCI_VS_SUBEV_ID_ASSERT              (0x01)
-#define BLE_HCI_VS_SUBEV_ID_CSS_SLOT_CHANGED    (0x02)
-struct ble_hci_ev_vs_css_slot_changed {
+#define BLE_HCI_VS_SUBEV_ID_ASSERT (0x01)
+#define BLE_HCI_VS_SUBEV_ID_CSS_SLOT_CHANGED (0x02)
+struct ble_hci_ev_vs_css_slot_changed
+{
     uint16_t conn_handle;
     uint16_t slot_idx;
 };
 
-#define BLE_HCI_VS_SUBEV_ISO_HCI_FEEDBACK       (0x03)
-struct feedback_pkt {
+#define BLE_HCI_VS_SUBEV_ISO_HCI_FEEDBACK (0x03)
+struct feedback_pkt
+{
     uint16_t handle;
     uint8_t sdu_per_interval;
     int8_t diff;
 } __attribute__((packed));
-struct ble_hci_vs_subev_iso_hci_feedback {
+struct ble_hci_vs_subev_iso_hci_feedback
+{
     uint8_t big_handle;
     uint8_t count;
     struct feedback_pkt feedback[0];
 } __attribute__((packed));
 
-#define BLE_HCI_VS_SUBEV_ID_LLCP_TRACE          (0x17)
+#define BLE_HCI_VS_SUBEV_ID_LLCP_TRACE (0x17)
 
 /* LE sub-event codes */
-#define BLE_HCI_LE_SUBEV_CONN_COMPLETE          (0x01)
-struct ble_hci_ev_le_subev_conn_complete {
-    uint8_t  subev_code;
-    uint8_t  status;
-    uint16_t conn_handle;
-    uint8_t  role;
-    uint8_t  peer_addr_type;
-    uint8_t  peer_addr[6];
+#define BLE_HCI_LE_SUBEV_CONN_COMPLETE (0x01)
+struct ble_hci_ev_le_subev_conn_complete
+{
+    uint8_t subev_code;
+    uint8_t status;
+    uint16_t conn_handle;
+    uint8_t role;
+    uint8_t peer_addr_type;
+    uint8_t peer_addr[6];
     uint16_t conn_itvl;
     uint16_t conn_latency;
     uint16_t supervision_timeout;
-    uint8_t  mca;
+    uint8_t mca;
 } __attribute__((packed));
 
-#define BLE_HCI_LE_SUBEV_ADV_RPT                (0x02)
-struct adv_report {
+#define BLE_HCI_LE_SUBEV_ADV_RPT (0x02)
+struct adv_report
+{
     uint8_t type;
     uint8_t addr_type;
     uint8_t addr[6];
     uint8_t data_len;
     uint8_t data[0];
 } __attribute__((packed));
-struct ble_hci_ev_le_subev_adv_rpt {
-    uint8_t  subev_code;
-    uint8_t  num_reports;
+struct ble_hci_ev_le_subev_adv_rpt
+{
+    uint8_t subev_code;
+    uint8_t num_reports;
     struct adv_report reports[0];
 } __attribute__((packed));
 
-#define BLE_HCI_LE_SUBEV_CONN_UPD_COMPLETE      (0x03)
-struct ble_hci_ev_le_subev_conn_upd_complete {
-    uint8_t  subev_code;
-    uint8_t  status;
+#define BLE_HCI_LE_SUBEV_CONN_UPD_COMPLETE (0x03)
+struct ble_hci_ev_le_subev_conn_upd_complete
+{
+    uint8_t subev_code;
+    uint8_t status;
     uint16_t conn_handle;
     uint16_t conn_itvl;
     uint16_t conn_latency;
     uint16_t supervision_timeout;
 } __attribute__((packed));
 
-#define BLE_HCI_LE_SUBEV_RD_REM_USED_FEAT       (0x04)
-struct ble_hci_ev_le_subev_rd_rem_used_feat {
-    uint8_t  subev_code;
-    uint8_t  status;
+#define BLE_HCI_LE_SUBEV_RD_REM_USED_FEAT (0x04)
+struct ble_hci_ev_le_subev_rd_rem_used_feat
+{
+    uint8_t subev_code;
+    uint8_t status;
     uint16_t conn_handle;
     uint8_t features[8];
 } __attribute__((packed));
 
-#define BLE_HCI_LE_SUBEV_LT_KEY_REQ             (0x05)
-struct ble_hci_ev_le_subev_lt_key_req {
-    uint8_t  subev_code;
+#define BLE_HCI_LE_SUBEV_LT_KEY_REQ (0x05)
+struct ble_hci_ev_le_subev_lt_key_req
+{
+    uint8_t subev_code;
     uint16_t conn_handle;
     uint64_t rand;
     uint16_t div;
 } __attribute__((packed));
 
-#define BLE_HCI_LE_SUBEV_REM_CONN_PARM_REQ      (0x06)
-struct ble_hci_ev_le_subev_rem_conn_param_req {
-    uint8_t  subev_code;
+#define BLE_HCI_LE_SUBEV_REM_CONN_PARM_REQ (0x06)
+struct ble_hci_ev_le_subev_rem_conn_param_req
+{
+    uint8_t subev_code;
     uint16_t conn_handle;
     uint16_t min_interval;
     uint16_t max_interval;
@@ -1891,9 +2124,10 @@ struct ble_hci_ev_le_subev_rem_conn_param_req {
     uint16_t timeout;
 } __attribute__((packed));
 
-#define BLE_HCI_LE_SUBEV_DATA_LEN_CHG           (0x07)
-struct ble_hci_ev_le_subev_data_len_chg {
-    uint8_t  subev_code;
+#define BLE_HCI_LE_SUBEV_DATA_LEN_CHG (0x07)
+struct ble_hci_ev_le_subev_data_len_chg
+{
+    uint8_t subev_code;
     uint16_t conn_handle;
     uint16_t max_tx_octets;
     uint16_t max_tx_time;
@@ -1901,163 +2135,180 @@ struct ble_hci_ev_le_subev_data_len_chg {
     uint16_t max_rx_time;
 } __attribute__((packed));
 
-#define BLE_HCI_LE_SUBEV_RD_LOC_P256_PUBKEY     (0x08)
-struct ble_hci_ev_le_subev_rd_loc_p256_pubkey {
+#define BLE_HCI_LE_SUBEV_RD_LOC_P256_PUBKEY (0x08)
+struct ble_hci_ev_le_subev_rd_loc_p256_pubkey
+{
     uint8_t subev_code;
     uint8_t status;
     uint8_t public_key[64];
 } __attribute__((packed));
 
-#define BLE_HCI_LE_SUBEV_GEN_DHKEY_COMPLETE     (0x09)
-struct ble_hci_ev_le_subev_gen_dhkey_complete {
+#define BLE_HCI_LE_SUBEV_GEN_DHKEY_COMPLETE (0x09)
+struct ble_hci_ev_le_subev_gen_dhkey_complete
+{
     uint8_t subev_code;
     uint8_t status;
     uint8_t dh_key[32];
 } __attribute__((packed));
 
-#define BLE_HCI_LE_SUBEV_ENH_CONN_COMPLETE      (0x0A)
-struct ble_hci_ev_le_subev_enh_conn_complete {
-    uint8_t  subev_code;
-    uint8_t  status;
+#define BLE_HCI_LE_SUBEV_ENH_CONN_COMPLETE (0x0A)
+struct ble_hci_ev_le_subev_enh_conn_complete
+{
+    uint8_t subev_code;
+    uint8_t status;
     uint16_t conn_handle;
-    uint8_t  role;
-    uint8_t  peer_addr_type;
-    uint8_t  peer_addr[6];
-    uint8_t  local_rpa[6];
-    uint8_t  peer_rpa[6];
+    uint8_t role;
+    uint8_t peer_addr_type;
+    uint8_t peer_addr[6];
+    uint8_t local_rpa[6];
+    uint8_t peer_rpa[6];
     uint16_t conn_itvl;
     uint16_t conn_latency;
     uint16_t supervision_timeout;
-    uint8_t  mca;
+    uint8_t mca;
 } __attribute__((packed));
 
-#define BLE_HCI_LE_SUBEV_DIRECT_ADV_RPT         (0x0B)
-struct dir_adv_report {
+#define BLE_HCI_LE_SUBEV_DIRECT_ADV_RPT (0x0B)
+struct dir_adv_report
+{
     uint8_t type;
     uint8_t addr_type;
     uint8_t addr[6];
     uint8_t dir_addr_type;
     uint8_t dir_addr[6];
-    int8_t  rssi;
+    int8_t rssi;
 } __attribute__((packed));
-struct ble_hci_ev_le_subev_direct_adv_rpt {
+struct ble_hci_ev_le_subev_direct_adv_rpt
+{
     uint8_t subev_code;
     uint8_t num_reports;
     struct dir_adv_report reports[0];
 } __attribute__((packed));
 
-#define BLE_HCI_LE_SUBEV_PHY_UPDATE_COMPLETE    (0x0C)
-struct ble_hci_ev_le_subev_phy_update_complete {
-    uint8_t  subev_code;
-    uint8_t  status;
+#define BLE_HCI_LE_SUBEV_PHY_UPDATE_COMPLETE (0x0C)
+struct ble_hci_ev_le_subev_phy_update_complete
+{
+    uint8_t subev_code;
+    uint8_t status;
     uint16_t conn_handle;
-    uint8_t  tx_phy;
-    uint8_t  rx_phy;
+    uint8_t tx_phy;
+    uint8_t rx_phy;
 } __attribute__((packed));
 
-#define BLE_HCI_LE_SUBEV_EXT_ADV_RPT            (0x0D)
-struct ext_adv_report {
-    uint16_t  evt_type;
-    uint8_t  addr_type;
-    uint8_t  addr[6];
-    uint8_t  pri_phy;
-    uint8_t  sec_phy;
-    uint8_t  sid;
-    int8_t   tx_power;
-    int8_t   rssi;
+#define BLE_HCI_LE_SUBEV_EXT_ADV_RPT (0x0D)
+struct ext_adv_report
+{
+    uint16_t evt_type;
+    uint8_t addr_type;
+    uint8_t addr[6];
+    uint8_t pri_phy;
+    uint8_t sec_phy;
+    uint8_t sid;
+    int8_t tx_power;
+    int8_t rssi;
     uint16_t periodic_itvl;
-    uint8_t  dir_addr_type;
-    uint8_t  dir_addr[6];
-    uint8_t  data_len;
-    uint8_t  data[0];
+    uint8_t dir_addr_type;
+    uint8_t dir_addr[6];
+    uint8_t data_len;
+    uint8_t data[0];
 } __attribute__((packed));
-struct ble_hci_ev_le_subev_ext_adv_rpt {
+struct ble_hci_ev_le_subev_ext_adv_rpt
+{
     uint8_t subev_code;
     uint8_t num_reports;
     struct ext_adv_report reports[0];
 } __attribute__((packed));
 
-#define BLE_HCI_LE_SUBEV_PERIODIC_ADV_SYNC_ESTAB     (0x0E)
-struct ble_hci_ev_le_subev_periodic_adv_sync_estab {
-    uint8_t  subev_code;
-    uint8_t  status;
+#define BLE_HCI_LE_SUBEV_PERIODIC_ADV_SYNC_ESTAB (0x0E)
+struct ble_hci_ev_le_subev_periodic_adv_sync_estab
+{
+    uint8_t subev_code;
+    uint8_t status;
     uint16_t sync_handle;
-    uint8_t  sid;
-    uint8_t  peer_addr_type;
-    uint8_t  peer_addr[6];
-    uint8_t  phy;
+    uint8_t sid;
+    uint8_t peer_addr_type;
+    uint8_t peer_addr[6];
+    uint8_t phy;
     uint16_t interval;
-    uint8_t  aca;
+    uint8_t aca;
 } __attribute__((packed));
 
-#define BLE_HCI_LE_SUBEV_PERIODIC_ADV_RPT            (0x0F)
-struct ble_hci_ev_le_subev_periodic_adv_rpt {
-    uint8_t  subev_code;
+#define BLE_HCI_LE_SUBEV_PERIODIC_ADV_RPT (0x0F)
+struct ble_hci_ev_le_subev_periodic_adv_rpt
+{
+    uint8_t subev_code;
     uint16_t sync_handle;
-    int8_t   tx_power;
-    int8_t   rssi;
-    uint8_t  cte_type;
-    uint8_t  data_status;
-    uint8_t  data_len;
-    uint8_t  data[0];
+    int8_t tx_power;
+    int8_t rssi;
+    uint8_t cte_type;
+    uint8_t data_status;
+    uint8_t data_len;
+    uint8_t data[0];
 } __attribute__((packed));
 
-#define BLE_HCI_LE_SUBEV_PERIODIC_ADV_SYNC_LOST      (0x10)
-struct ble_hci_ev_le_subev_periodic_adv_sync_lost {
-    uint8_t  subev_code;
+#define BLE_HCI_LE_SUBEV_PERIODIC_ADV_SYNC_LOST (0x10)
+struct ble_hci_ev_le_subev_periodic_adv_sync_lost
+{
+    uint8_t subev_code;
     uint16_t sync_handle;
 } __attribute__((packed));
 
-#define BLE_HCI_LE_SUBEV_SCAN_TIMEOUT           (0x11)
-struct ble_hci_ev_le_subev_scan_timeout {
-    uint8_t  subev_code;
+#define BLE_HCI_LE_SUBEV_SCAN_TIMEOUT (0x11)
+struct ble_hci_ev_le_subev_scan_timeout
+{
+    uint8_t subev_code;
 } __attribute__((packed));
 
-#define BLE_HCI_LE_SUBEV_ADV_SET_TERMINATED     (0x12)
-struct ble_hci_ev_le_subev_adv_set_terminated {
-    uint8_t  subev_code;
-    uint8_t  status;
-    uint8_t  adv_handle;
+#define BLE_HCI_LE_SUBEV_ADV_SET_TERMINATED (0x12)
+struct ble_hci_ev_le_subev_adv_set_terminated
+{
+    uint8_t subev_code;
+    uint8_t status;
+    uint8_t adv_handle;
     uint16_t conn_handle;
-    uint8_t  num_events;
+    uint8_t num_events;
 } __attribute__((packed));
 
-#define BLE_HCI_LE_SUBEV_SCAN_REQ_RCVD          (0x13)
-struct ble_hci_ev_le_subev_scan_req_rcvd {
+#define BLE_HCI_LE_SUBEV_SCAN_REQ_RCVD (0x13)
+struct ble_hci_ev_le_subev_scan_req_rcvd
+{
     uint8_t subev_code;
     uint8_t adv_handle;
     uint8_t peer_addr_type;
     uint8_t peer_addr[6];
 } __attribute__((packed));
 
-#define BLE_HCI_LE_SUBEV_CHAN_SEL_ALG           (0x14)
-struct ble_hci_ev_le_subev_chan_sel_alg {
-    uint8_t  subev_code;
+#define BLE_HCI_LE_SUBEV_CHAN_SEL_ALG (0x14)
+struct ble_hci_ev_le_subev_chan_sel_alg
+{
+    uint8_t subev_code;
     uint16_t conn_handle;
-    uint8_t  csa;
+    uint8_t csa;
 } __attribute__((packed));
 
-#define BLE_HCI_LE_SUBEV_CONNLESS_IQ_RPT        (0x15)
-#define BLE_HCI_LE_SUBEV_CONN_IQ_RPT            (0x16)
-#define BLE_HCI_LE_SUBEV_CTE_REQ_FAILED         (0x17)
+#define BLE_HCI_LE_SUBEV_CONNLESS_IQ_RPT (0x15)
+#define BLE_HCI_LE_SUBEV_CONN_IQ_RPT (0x16)
+#define BLE_HCI_LE_SUBEV_CTE_REQ_FAILED (0x17)
 
-#define BLE_HCI_LE_SUBEV_PERIODIC_ADV_SYNC_TRANSFER   (0x18)
-struct ble_hci_ev_le_subev_periodic_adv_sync_transfer {
-    uint8_t  subev_code;
-    uint8_t  status;
+#define BLE_HCI_LE_SUBEV_PERIODIC_ADV_SYNC_TRANSFER (0x18)
+struct ble_hci_ev_le_subev_periodic_adv_sync_transfer
+{
+    uint8_t subev_code;
+    uint8_t status;
     uint16_t conn_handle;
     uint16_t service_data;
     uint16_t sync_handle;
-    uint8_t  sid;
-    uint8_t  peer_addr_type;
-    uint8_t  peer_addr[6];
-    uint8_t  phy;
+    uint8_t sid;
+    uint8_t peer_addr_type;
+    uint8_t peer_addr[6];
+    uint8_t phy;
     uint16_t interval;
-    uint8_t  aca;
+    uint8_t aca;
 } __attribute__((packed));
 
-#define BLE_HCI_LE_SUBEV_CIS_ESTABLISHED        (0x19)
-struct ble_hci_ev_le_subev_cis_established {
+#define BLE_HCI_LE_SUBEV_CIS_ESTABLISHED (0x19)
+struct ble_hci_ev_le_subev_cis_established
+{
     uint8_t subev_code;
     uint8_t status;
     uint16_t conn_handle;
@@ -2077,8 +2328,9 @@ struct ble_hci_ev_le_subev_cis_established {
     uint16_t iso_interval;
 } __attribute__((packed));
 
-#define BLE_HCI_LE_SUBEV_CIS_REQUEST            (0x1A)
-struct ble_hci_ev_le_subev_cis_request {
+#define BLE_HCI_LE_SUBEV_CIS_REQUEST (0x1A)
+struct ble_hci_ev_le_subev_cis_request
+{
     uint8_t subev_code;
     uint16_t acl_conn_handle;
     uint16_t cis_conn_handle;
@@ -2086,8 +2338,9 @@ struct ble_hci_ev_le_subev_cis_request {
     uint8_t cis_id;
 } __attribute__((packed));
 
-#define BLE_HCI_LE_SUBEV_CREATE_BIG_COMPLETE    (0x1B)
-struct ble_hci_ev_le_subev_create_big_complete {
+#define BLE_HCI_LE_SUBEV_CREATE_BIG_COMPLETE (0x1B)
+struct ble_hci_ev_le_subev_create_big_complete
+{
     uint8_t subev_code;
     uint8_t status;
     uint8_t big_handle;
@@ -2105,14 +2358,16 @@ struct ble_hci_ev_le_subev_create_big_complete {
 } __attribute__((packed));
 
 #define BLE_HCI_LE_SUBEV_TERMINATE_BIG_COMPLETE (0x1C)
-struct ble_hci_ev_le_subev_terminate_big_complete {
+struct ble_hci_ev_le_subev_terminate_big_complete
+{
     uint8_t subev_code;
     uint8_t big_handle;
     uint8_t reason;
 } __attribute__((packed));
 
-#define BLE_HCI_LE_SUBEV_BIG_SYNC_ESTABLISHED    (0x1D)
-struct ble_hci_ev_le_subev_big_sync_established {
+#define BLE_HCI_LE_SUBEV_BIG_SYNC_ESTABLISHED (0x1D)
+struct ble_hci_ev_le_subev_big_sync_established
+{
     uint8_t subev_code;
     uint8_t status;
     uint8_t big_handle;
@@ -2127,31 +2382,35 @@ struct ble_hci_ev_le_subev_big_sync_established {
     uint16_t conn_handle[0];
 } __attribute__((packed));
 
-#define BLE_HCI_LE_SUBEV_BIG_SYNC_LOST          (0x1E)
-struct ble_hci_ev_le_subev_big_sync_lost {
+#define BLE_HCI_LE_SUBEV_BIG_SYNC_LOST (0x1E)
+struct ble_hci_ev_le_subev_big_sync_lost
+{
     uint8_t subev_code;
     uint8_t big_handle;
     uint8_t reason;
 } __attribute__((packed));
 
-#define BLE_HCI_LE_SUBEV_REQ_PEER_SCA_COMP      (0x1F)
-struct ble_hci_ev_le_subev_peer_sca_complete {
+#define BLE_HCI_LE_SUBEV_REQ_PEER_SCA_COMP (0x1F)
+struct ble_hci_ev_le_subev_peer_sca_complete
+{
     uint8_t subev_code;
     uint8_t status;
     uint16_t conn_handle;
     uint8_t sca;
 } __attribute__((packed));
 
-#define BLE_HCI_LE_SUBEV_PATH_LOSS_THRESHOLD     (0x20)
-struct ble_hci_ev_le_subev_path_loss_threshold {
+#define BLE_HCI_LE_SUBEV_PATH_LOSS_THRESHOLD (0x20)
+struct ble_hci_ev_le_subev_path_loss_threshold
+{
     uint8_t subev_code;
     uint16_t conn_handle;
     uint8_t current_path_loss;
     uint8_t zone_entered;
 } __attribute__((packed));
 
-#define BLE_HCI_LE_SUBEV_TRANSMIT_POWER_REPORT   (0x21)
-struct ble_hci_ev_le_subev_transmit_power_report {
+#define BLE_HCI_LE_SUBEV_TRANSMIT_POWER_REPORT (0x21)
+struct ble_hci_ev_le_subev_transmit_power_report
+{
     uint8_t subev_code;
     uint8_t status;
     uint16_t conn_handle;
@@ -2162,8 +2421,9 @@ struct ble_hci_ev_le_subev_transmit_power_report {
     int8_t delta;
 } __attribute__((packed));
 
-#define BLE_HCI_LE_SUBEV_BIGINFO_ADV_REPORT         (0x22)
-struct ble_hci_ev_le_subev_biginfo_adv_report {
+#define BLE_HCI_LE_SUBEV_BIGINFO_ADV_REPORT (0x22)
+struct ble_hci_ev_le_subev_biginfo_adv_report
+{
     uint8_t subev_code;
     uint16_t sync_handle;
     uint8_t bis_cnt;
@@ -2180,8 +2440,9 @@ struct ble_hci_ev_le_subev_biginfo_adv_report {
     uint8_t encryption;
 } __attribute__((packed));
 
-#define BLE_HCI_LE_SUBEV_SUBRATE_CHANGE             (0x23)
-struct ble_hci_ev_le_subev_subrate_change {
+#define BLE_HCI_LE_SUBEV_SUBRATE_CHANGE (0x23)
+struct ble_hci_ev_le_subev_subrate_change
+{
     uint8_t subev_code;
     uint8_t status;
     uint16_t conn_handle;
@@ -2191,8 +2452,9 @@ struct ble_hci_ev_le_subev_subrate_change {
     uint16_t supervision_tmo;
 } __attribute__((packed));
 
-#define BLE_HCI_LE_SUBEV_CS_RD_REM_SUPP_CAP_COMPLETE   (0x2C)
-struct ble_hci_ev_le_subev_cs_rd_rem_supp_cap_complete {
+#define BLE_HCI_LE_SUBEV_CS_RD_REM_SUPP_CAP_COMPLETE (0x2C)
+struct ble_hci_ev_le_subev_cs_rd_rem_supp_cap_complete
+{
     uint8_t subev_code;
     uint8_t status;
     uint16_t conn_handle;
@@ -2217,23 +2479,26 @@ struct ble_hci_ev_le_subev_cs_rd_rem_supp_cap_complete {
     uint8_t t_sw_time_supported;
 } __attribute__((packed));
 
-#define BLE_HCI_LE_SUBEV_CS_RD_REM_FAE_COMPLETE        (0x2D)
-struct ble_hci_ev_le_subev_cs_rd_rem_fae_complete {
+#define BLE_HCI_LE_SUBEV_CS_RD_REM_FAE_COMPLETE (0x2D)
+struct ble_hci_ev_le_subev_cs_rd_rem_fae_complete
+{
     uint8_t subev_code;
     uint8_t status;
     uint16_t conn_handle;
     uint8_t remote_fae_table[72];
 } __attribute__((packed));
 
-#define BLE_HCI_LE_SUBEV_CS_SEC_ENABLE_COMPLETE        (0x2E)
-struct ble_hci_ev_le_subev_cs_sec_enable_complete {
+#define BLE_HCI_LE_SUBEV_CS_SEC_ENABLE_COMPLETE (0x2E)
+struct ble_hci_ev_le_subev_cs_sec_enable_complete
+{
     uint8_t subev_code;
     uint8_t status;
     uint16_t conn_handle;
 } __attribute__((packed));
 
-#define BLE_HCI_LE_SUBEV_CS_CONFIG_COMPLETE            (0x2F)
-struct ble_hci_ev_le_subev_cs_config_complete {
+#define BLE_HCI_LE_SUBEV_CS_CONFIG_COMPLETE (0x2F)
+struct ble_hci_ev_le_subev_cs_config_complete
+{
     uint8_t subev_code;
     uint8_t status;
     uint16_t conn_handle;
@@ -2260,8 +2525,9 @@ struct ble_hci_ev_le_subev_cs_config_complete {
     uint8_t t_pm_time;
 } __attribute__((packed));
 
-#define BLE_HCI_LE_SUBEV_CS_PROC_ENABLE_COMPLETE       (0x30)
-struct ble_hci_ev_le_subev_cs_proc_enable_complete {
+#define BLE_HCI_LE_SUBEV_CS_PROC_ENABLE_COMPLETE (0x30)
+struct ble_hci_ev_le_subev_cs_proc_enable_complete
+{
     uint8_t subev_code;
     uint8_t status;
     uint16_t conn_handle;
@@ -2277,14 +2543,16 @@ struct ble_hci_ev_le_subev_cs_proc_enable_complete {
     uint16_t procedure_count;
 } __attribute__((packed));
 
-#define BLE_HCI_LE_SUBEV_CS_SUBEVENT_RESULT            (0x31)
-struct cs_steps_data {
+#define BLE_HCI_LE_SUBEV_CS_SUBEVENT_RESULT (0x31)
+struct cs_steps_data
+{
     uint8_t mode;
     uint8_t channel;
     uint8_t data_len;
     uint8_t data[];
 } __attribute__((packed));
-struct ble_hci_ev_le_subev_cs_subevent_result {
+struct ble_hci_ev_le_subev_cs_subevent_result
+{
     uint8_t subev_code;
     uint16_t conn_handle;
     uint8_t config_id;
@@ -2300,8 +2568,9 @@ struct ble_hci_ev_le_subev_cs_subevent_result {
     struct cs_steps_data steps[];
 } __attribute__((packed));
 
-#define BLE_HCI_LE_SUBEV_CS_SUBEVENT_RESULT_CONTINUE   (0x32)
-struct ble_hci_ev_le_subev_cs_subevent_result_continue {
+#define BLE_HCI_LE_SUBEV_CS_SUBEVENT_RESULT_CONTINUE (0x32)
+struct ble_hci_ev_le_subev_cs_subevent_result_continue
+{
     uint8_t subev_code;
     uint16_t conn_handle;
     uint8_t config_id;
@@ -2313,71 +2582,72 @@ struct ble_hci_ev_le_subev_cs_subevent_result_continue {
     struct cs_steps_data steps[];
 } __attribute__((packed));
 
-#define BLE_HCI_LE_SUBEV_CS_TEST_END_COMPLETE          (0x33)
-struct ble_hci_ev_le_subev_cs_test_end_complete {
+#define BLE_HCI_LE_SUBEV_CS_TEST_END_COMPLETE (0x33)
+struct ble_hci_ev_le_subev_cs_test_end_complete
+{
     uint8_t subev_code;
     uint8_t status;
 } __attribute__((packed));
 
 /* Data buffer overflow event */
-#define BLE_HCI_EVENT_ACL_BUF_OVERFLOW      (0x01)
+#define BLE_HCI_EVENT_ACL_BUF_OVERFLOW (0x01)
 
 /* Advertising report */
-#define BLE_HCI_ADV_RPT_EVTYPE_ADV_IND      (0)
-#define BLE_HCI_ADV_RPT_EVTYPE_DIR_IND      (1)
-#define BLE_HCI_ADV_RPT_EVTYPE_SCAN_IND     (2)
-#define BLE_HCI_ADV_RPT_EVTYPE_NONCONN_IND  (3)
-#define BLE_HCI_ADV_RPT_EVTYPE_SCAN_RSP     (4)
+#define BLE_HCI_ADV_RPT_EVTYPE_ADV_IND (0)
+#define BLE_HCI_ADV_RPT_EVTYPE_DIR_IND (1)
+#define BLE_HCI_ADV_RPT_EVTYPE_SCAN_IND (2)
+#define BLE_HCI_ADV_RPT_EVTYPE_NONCONN_IND (3)
+#define BLE_HCI_ADV_RPT_EVTYPE_SCAN_RSP (4)
 
 /* Bluetooth 5, Vol 2, Part E, 7.7.65.13 */
-#define BLE_HCI_LEGACY_ADV_EVTYPE_ADV_IND                 (0x13)
-#define BLE_HCI_LEGACY_ADV_EVTYPE_ADV_DIRECT_IND          (0x15)
-#define BLE_HCI_LEGACY_ADV_EVTYPE_ADV_SCAN_IND            (0x12)
-#define BLE_HCI_LEGACY_ADV_EVTYPE_ADV_NONCON_IND          (0x10)
-#define BLE_HCI_LEGACY_ADV_EVTYPE_SCAN_RSP_ADV_IND        (0x1b)
-#define BLE_HCI_LEGACY_ADV_EVTYPE_SCAN_RSP_ADV_SCAN_IND   (0x1a)
+#define BLE_HCI_LEGACY_ADV_EVTYPE_ADV_IND (0x13)
+#define BLE_HCI_LEGACY_ADV_EVTYPE_ADV_DIRECT_IND (0x15)
+#define BLE_HCI_LEGACY_ADV_EVTYPE_ADV_SCAN_IND (0x12)
+#define BLE_HCI_LEGACY_ADV_EVTYPE_ADV_NONCON_IND (0x10)
+#define BLE_HCI_LEGACY_ADV_EVTYPE_SCAN_RSP_ADV_IND (0x1b)
+#define BLE_HCI_LEGACY_ADV_EVTYPE_SCAN_RSP_ADV_SCAN_IND (0x1a)
 
 /* LE connection complete event (sub event 0x01) */
-#define BLE_HCI_LE_CONN_COMPLETE_ROLE_MASTER    (0x00)
-#define BLE_HCI_LE_CONN_COMPLETE_ROLE_SLAVE     (0x01)
+#define BLE_HCI_LE_CONN_COMPLETE_ROLE_MASTER (0x00)
+#define BLE_HCI_LE_CONN_COMPLETE_ROLE_SLAVE (0x01)
 
 /* Maximum valid connection handle value */
-#define BLE_HCI_LE_CONN_HANDLE_MAX              (0x0eff)
+#define BLE_HCI_LE_CONN_HANDLE_MAX (0x0eff)
 
 /* LE advertising report event. (sub event 0x02) */
-#define BLE_HCI_LE_ADV_RPT_NUM_RPTS_MIN     (1)
-#define BLE_HCI_LE_ADV_RPT_NUM_RPTS_MAX     (0x19)
+#define BLE_HCI_LE_ADV_RPT_NUM_RPTS_MIN (1)
+#define BLE_HCI_LE_ADV_RPT_NUM_RPTS_MAX (0x19)
 
 /* Bluetooth Assigned numbers for version information.*/
-#define BLE_HCI_VER_BCS_1_0b                (0)
-#define BLE_HCI_VER_BCS_1_1                 (1)
-#define BLE_HCI_VER_BCS_1_2                 (2)
-#define BLE_HCI_VER_BCS_2_0_EDR             (3)
-#define BLE_HCI_VER_BCS_2_1_EDR             (4)
-#define BLE_HCI_VER_BCS_3_0_HCS             (5)
-#define BLE_HCI_VER_BCS_4_0                 (6)
-#define BLE_HCI_VER_BCS_4_1                 (7)
-#define BLE_HCI_VER_BCS_4_2                 (8)
-#define BLE_HCI_VER_BCS_5_0                 (9)
-#define BLE_HCI_VER_BCS_5_1                 (10)
-#define BLE_HCI_VER_BCS_5_2                 (11)
-#define BLE_HCI_VER_BCS_5_3                 (12)
-#define BLE_HCI_VER_BCS_5_4                 (13)
-
-#define BLE_LMP_VER_BCS_1_0b                (0)
-#define BLE_LMP_VER_BCS_1_1                 (1)
-#define BLE_LMP_VER_BCS_1_2                 (2)
-#define BLE_LMP_VER_BCS_2_0_EDR             (3)
-#define BLE_LMP_VER_BCS_2_1_EDR             (4)
-#define BLE_LMP_VER_BCS_3_0_HCS             (5)
-#define BLE_LMP_VER_BCS_4_0                 (6)
-#define BLE_LMP_VER_BCS_4_1                 (7)
-#define BLE_LMP_VER_BCS_4_2                 (8)
-#define BLE_LMP_VER_BCS_5_0                 (9)
-#define BLE_LMP_VER_BCS_5_1                 (10)
-#define BLE_LMP_VER_BCS_5_2                 (11)
-#define BLE_LMP_VER_BCS_5_3                 (12)
-#define BLE_LMP_VER_BCS_5_4                 (13)
+#define BLE_HCI_VER_BCS_1_0b (0)
+#define BLE_HCI_VER_BCS_1_1 (1)
+#define BLE_HCI_VER_BCS_1_2 (2)
+#define BLE_HCI_VER_BCS_2_0_EDR (3)
+#define BLE_HCI_VER_BCS_2_1_EDR (4)
+#define BLE_HCI_VER_BCS_3_0_HCS (5)
+#define BLE_HCI_VER_BCS_4_0 (6)
+#define BLE_HCI_VER_BCS_4_1 (7)
+#define BLE_HCI_VER_BCS_4_2 (8)
+#define BLE_HCI_VER_BCS_5_0 (9)
+#define BLE_HCI_VER_BCS_5_1 (10)
+#define BLE_HCI_VER_BCS_5_2 (11)
+#define BLE_HCI_VER_BCS_5_3 (12)
+#define BLE_HCI_VER_BCS_5_4 (13)
+
+#define BLE_LMP_VER_BCS_1_0b (0)
+#define BLE_LMP_VER_BCS_1_1 (1)
+#define BLE_LMP_VER_BCS_1_2 (2)
+#define BLE_LMP_VER_BCS_2_0_EDR (3)
+#define BLE_LMP_VER_BCS_2_1_EDR (4)
+#define BLE_LMP_VER_BCS_3_0_HCS (5)
+#define BLE_LMP_VER_BCS_4_0 (6)
+#define BLE_LMP_VER_BCS_4_1 (7)
+#define BLE_LMP_VER_BCS_4_2 (8)
+#define BLE_LMP_VER_BCS_5_0 (9)
+#define BLE_LMP_VER_BCS_5_1 (10)
+#define BLE_LMP_VER_BCS_5_2 (11)
+#define BLE_LMP_VER_BCS_5_3 (12)
+#define BLE_LMP_VER_BCS_5_4 (13)
 
 /* selected HCI and LMP version */
 #if MYNEWT_VAL(BLE_VERSION) == 50
@@ -2397,10 +2667,10 @@ struct ble_hci_ev_le_subev_cs_test_end_complete {
 #define BLE_LMP_VER_BCS BLE_LMP_VER_BCS_5_4
 #endif
 
-#define BLE_HCI_DATA_HDR_SZ                 4
-#define BLE_HCI_DATA_HANDLE(handle_pb_bc)   (((handle_pb_bc) & 0x0fff) >> 0)
-#define BLE_HCI_DATA_PB(handle_pb_bc)       (((handle_pb_bc) & 0x3000) >> 12)
-#define BLE_HCI_DATA_BC(handle_pb_bc)       (((handle_pb_bc) & 0xc000) >> 14)
+#define BLE_HCI_DATA_HDR_SZ 4
+#define BLE_HCI_DATA_HANDLE(handle_pb_bc) (((handle_pb_bc) & 0x0fff) >> 0)
+#define BLE_HCI_DATA_PB(handle_pb_bc) (((handle_pb_bc) & 0x3000) >> 12)
+#define BLE_HCI_DATA_BC(handle_pb_bc) (((handle_pb_bc) & 0xc000) >> 14)
 
 struct hci_data_hdr
 {
@@ -2408,56 +2678,59 @@ struct hci_data_hdr
     uint16_t hdh_len;
 };
 
-#define BLE_HCI_PB_FIRST_NON_FLUSH          0
-#define BLE_HCI_PB_MIDDLE                   1
-#define BLE_HCI_PB_FIRST_FLUSH              2
-#define BLE_HCI_PB_FULL                     3
+#define BLE_HCI_PB_FIRST_NON_FLUSH 0
+#define BLE_HCI_PB_MIDDLE 1
+#define BLE_HCI_PB_FIRST_FLUSH 2
+#define BLE_HCI_PB_FULL 3
 
-#define BLE_HCI_ISO_CONN_HANDLE_MASK        (0x07ff)
-#define BLE_HCI_ISO_PB_FLAG_MASK            (0x3000)
-#define BLE_HCI_ISO_TS_FLAG_MASK            (0x4000)
-#define BLE_HCI_ISO_LENGTH_MASK             (0x7fff)
-#define BLE_HCI_ISO_SDU_LENGTH_MASK         (0x0fff)
-#define BLE_HCI_ISO_PKT_STATUS_FLAG_MASK    (0xC000)
+#define BLE_HCI_ISO_CONN_HANDLE_MASK (0x07ff)
+#define BLE_HCI_ISO_PB_FLAG_MASK (0x3000)
+#define BLE_HCI_ISO_TS_FLAG_MASK (0x4000)
+#define BLE_HCI_ISO_LENGTH_MASK (0x7fff)
+#define BLE_HCI_ISO_SDU_LENGTH_MASK (0x0fff)
+#define BLE_HCI_ISO_PKT_STATUS_FLAG_MASK (0xC000)
 
-#define BLE_HCI_ISO_HANDLE(ch, pb, ts)  ((ch) | ((pb) << 12) | ((ts) << 14))
+#define BLE_HCI_ISO_HANDLE(ch, pb, ts) ((ch) | ((pb) << 12) | ((ts) << 14))
 
-#define BLE_HCI_ISO_CONN_HANDLE(h)      ((h) & BLE_HCI_ISO_CONN_HANDLE_MASK)
-#define BLE_HCI_ISO_PB_FLAG(h)          (((h) & BLE_HCI_ISO_PB_FLAG_MASK) >> 12)
-#define BLE_HCI_ISO_TS_FLAG(h)          (((h) & BLE_HCI_ISO_TS_FLAG_MASK) >> 14)
-#define BLE_HCI_ISO_LENGTH(l)           ((l) & BLE_HCI_ISO_LENGTH_MASK)
-#define BLE_HCI_ISO_SDU_LENGTH(l)       ((l) & BLE_HCI_ISO_SDU_LENGTH_MASK)
-#define BLE_HCI_ISO_PKT_STATUS_FLAG(l)  (((l) & BLE_HCI_ISO_PKT_STATUS_FLAG_MASK) >> 14)
+#define BLE_HCI_ISO_CONN_HANDLE(h) ((h) & BLE_HCI_ISO_CONN_HANDLE_MASK)
+#define BLE_HCI_ISO_PB_FLAG(h) (((h) & BLE_HCI_ISO_PB_FLAG_MASK) >> 12)
+#define BLE_HCI_ISO_TS_FLAG(h) (((h) & BLE_HCI_ISO_TS_FLAG_MASK) >> 14)
+#define BLE_HCI_ISO_LENGTH(l) ((l) & BLE_HCI_ISO_LENGTH_MASK)
+#define BLE_HCI_ISO_SDU_LENGTH(l) ((l) & BLE_HCI_ISO_SDU_LENGTH_MASK)
+#define BLE_HCI_ISO_PKT_STATUS_FLAG(l)                                         \
+    (((l) & BLE_HCI_ISO_PKT_STATUS_FLAG_MASK) >> 14)
 
-#define BLE_HCI_ISO_PB_FIRST            (0)
-#define BLE_HCI_ISO_PB_CONTINUATION     (1)
-#define BLE_HCI_ISO_PB_COMPLETE         (2)
-#define BLE_HCI_ISO_PB_LAST             (3)
+#define BLE_HCI_ISO_PB_FIRST (0)
+#define BLE_HCI_ISO_PB_CONTINUATION (1)
+#define BLE_HCI_ISO_PB_COMPLETE (2)
+#define BLE_HCI_ISO_PB_LAST (3)
 
-#define BLE_HCI_ISO_PKT_STATUS_VALID    0x00
-#define BLE_HCI_ISO_PKT_STATUS_INVALID  0x01
-#define BLE_HCI_ISO_PKT_STATUS_LOST     0x10
+#define BLE_HCI_ISO_PKT_STATUS_VALID 0x00
+#define BLE_HCI_ISO_PKT_STATUS_INVALID 0x01
+#define BLE_HCI_ISO_PKT_STATUS_LOST 0x10
 
-#define BLE_HCI_ISO_BIG_HANDLE_MIN      0x00
-#define BLE_HCI_ISO_BIG_HANDLE_MAX      0xEF
+#define BLE_HCI_ISO_BIG_HANDLE_MIN 0x00
+#define BLE_HCI_ISO_BIG_HANDLE_MAX 0xEF
 
-#define BLE_HCI_ISO_BIG_ENCRYPTION_UNENCRYPTED  0x00
-#define BLE_HCI_ISO_BIG_ENCRYPTION_ENCRYPTED    0x01
+#define BLE_HCI_ISO_BIG_ENCRYPTION_UNENCRYPTED 0x00
+#define BLE_HCI_ISO_BIG_ENCRYPTION_ENCRYPTED 0x01
 
-#define BLE_HCI_ISO_DATA_PATH_DIR_INPUT         0x00
-#define BLE_HCI_ISO_DATA_PATH_DIR_OUTPUT        0x01
+#define BLE_HCI_ISO_DATA_PATH_DIR_INPUT 0x00
+#define BLE_HCI_ISO_DATA_PATH_DIR_OUTPUT 0x01
 
-#define BLE_HCI_ISO_DATA_PATH_ID_HCI            0x00
+#define BLE_HCI_ISO_DATA_PATH_ID_HCI 0x00
 
-struct ble_hci_iso {
+struct ble_hci_iso
+{
     uint16_t handle;
     uint16_t length;
     uint8_t data[0];
 } __attribute__((packed));
 
-#define BLE_HCI_ISO_HDR_SDU_LENGTH_MASK     (0x07ff)
+#define BLE_HCI_ISO_HDR_SDU_LENGTH_MASK (0x07ff)
 
-struct ble_hci_iso_data {
+struct ble_hci_iso_data
+{
     uint16_t packet_seq_num;
     uint16_t sdu_len;
     uint8_t data[0];
